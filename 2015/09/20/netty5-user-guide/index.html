<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="https://fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="java netty">





  <link rel="alternate" href="/atom.xml" title="TonyDeng's Blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="Netty是一个NIO client/server网络编程框架，可以快速且容易的开发基于协议（protocol）的网络客户端/服务端的程序，它极大简化了TCP和UDP socket编程，提供流水线化的操作。 “快速且容易”并不会导致应用难以维护和性能低下。Netty经过仔细设计，基于许多协议实现的经验如：FTP、SMTP、HTTP以及各种二进制和基于本文的老的协议，Netty成功的找到一种保证开发">
<meta name="keywords" content="java netty">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 5用户指南">
<meta property="og:url" content="http://tonydeng.github.io/2015/09/20/netty5-user-guide/index.html">
<meta property="og:site_name" content="TonyDeng&#39;s Blog">
<meta property="og:description" content="Netty是一个NIO client/server网络编程框架，可以快速且容易的开发基于协议（protocol）的网络客户端/服务端的程序，它极大简化了TCP和UDP socket编程，提供流水线化的操作。 “快速且容易”并不会导致应用难以维护和性能低下。Netty经过仔细设计，基于许多协议实现的经验如：FTP、SMTP、HTTP以及各种二进制和基于本文的老的协议，Netty成功的找到一种保证开发">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://tonydeng.github.io/images/blog/netty/components.png">
<meta property="og:image" content="http://tonydeng.github.io/images/blog/netty/netty5_1.png">
<meta property="og:image" content="http://tonydeng.github.io/images/blog/netty/netty5_2.png">
<meta property="og:image" content="http://tonydeng.github.io/images/blog/netty/netty5_3.png">
<meta property="og:updated_time" content="2019-06-20T12:10:27.469Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Netty 5用户指南">
<meta name="twitter:description" content="Netty是一个NIO client/server网络编程框架，可以快速且容易的开发基于协议（protocol）的网络客户端/服务端的程序，它极大简化了TCP和UDP socket编程，提供流水线化的操作。 “快速且容易”并不会导致应用难以维护和性能低下。Netty经过仔细设计，基于许多协议实现的经验如：FTP、SMTP、HTTP以及各种二进制和基于本文的老的协议，Netty成功的找到一种保证开发">
<meta name="twitter:image" content="http://tonydeng.github.io/images/blog/netty/components.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://tonydeng.github.io/2015/09/20/netty5-user-guide/">





<link rel="stylesheet" href="https://cdn.bootcss.com/mermaid/6.0.0/mermaid.min.css?v=6.0.0">


  <title> Netty 5用户指南 | TonyDeng's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-80673215-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?43d979b191269e68beffa09e2d17a081";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1261975682&web_id=1261975682" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">TonyDeng's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">“In me the tiger sniffes the rose.” -- Siegfried Sasson</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-ppts">
          <a href="/ppts" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            PPT
          </a>
        </li>
      
        
        <li class="menu-item menu-item-gitbook">
          <a href="/gitbook-zh" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            GitBook
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://tonydeng.github.io/2015/09/20/netty5-user-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tony Deng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/629519?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TonyDeng's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Netty 5用户指南
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-20T21:03:35+08:00">
                2015-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/程序设计/" itemprop="url" rel="index">
                    <span itemprop="name">程序设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Netty是一个<code>NIO client/server</code>网络编程框架，可以快速且容易的开发基于协议（protocol）的网络客户端/服务端的程序，它极大简化了TCP和UDP socket编程，提供流水线化的操作。</p>
<p>“快速且容易”并不会导致应用难以维护和性能低下。Netty经过仔细设计，基于许多协议实现的经验如：<code>FTP</code>、<code>SMTP</code>、<code>HTTP</code>以及各种二进制和基于本文的老的协议，Netty成功的找到一种保证开发，稳定性，灵活性的方式，毋需折中。</p>
<p><img src="/images/blog/netty/components.png" alt="netty components"></p>
<a id="more"></a>

<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul>
<li>为各种传输类型提供统一的API，阻塞和非阻塞的socket</li>
<li>灵活和可扩展的事件模型，将关注点分离</li>
<li>高度可定制的线程模型-单线程，一种或多个线程池，如<a href="http://en.wikipedia.org/wiki/Staged_event-driven_architecture" target="_blank" rel="noopener">SEDA</a></li>
<li>真正无连接的数据报socket支持（since 3.1）</li>
</ul>
<h2 id="易用"><a href="#易用" class="headerlink" title="易用"></a>易用</h2><ul>
<li>提供Javadoc，用户指南和例子</li>
<li>JDK1.5以上版本不需要第三方库支持</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>更好的吞吐率，低延迟</li>
<li>较少的资源占用</li>
<li>最小化不必要的内存拷贝</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>完整的SSL/TLS， StartTLS支持</li>
</ul>
<h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><ul>
<li>作者从2003就开始写类似的框架（<code>mina</code>），一直收集用户反馈。官方的<a href="http://netty.io/wiki/user-guide-for-5.x.html" target="_blank" rel="noopener">user guide</a>，中文翻译的<a href="http://www.getsetter.cn/2014/07/15/netty5/" target="_blank" rel="noopener">用户指南</a></li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现如今我们使用通用的应用程序或者类库来实现系统之间的互相访问，比如，我们经常使用一个HTTP客户端来从web服务器上获取信息，或者通过web service来执行一个远程的调用。</p>
<p>然而，一个通用的协议和它的实现有时候并没用覆盖到一些场景。比如我们无法使用通用的http服务器来对庞大的文件和电子邮件进行交互，再比如我们无法处理那中准实时消息，比如财务信息和多人游戏数据。我们需要一个高效的协议实现用来处理一些特殊的场景。例如你可以实现一个基于AJAX的聊天应用，媒体流传输或者大文件传输的http服务器，你甚至可以想自己设计一个新的协议来准确定制你自己的需求。</p>
<p>另外，不可避免的事情是你不得不处理这些私有协议来确保和原有系统的互通。在这个例子中会告诉你实现一个对应该程序不损耗稳定性和性能的协议是多么的快。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="http://netty.io" target="_blank" rel="noopener">Netty</a>是一个提供异步事件驱动的网络应用框架，可以为服务端和客户端提供一个快速迭代开发的高性能、高伸缩性的协议。</p>
<p>换句话说，Netty是一个能够快速简单地来开发网络应用程序的NIO框架比如客户端和服务端的协议，Netty大大简化了网络程序的开发过程比如TCP和UDP的 Socket的开发。</p>
<p>快速和简单并不等于一个应用会产生可维护性和性能的问题，Netty是一个被精心设计的框架，他从许多协议的实现中吸收了很多的经验比如FTP,SMTP,HTTP和许多二进制和基于文本的传统协议，Netty已经成功地找出了解决方案并且在不妥协开发效率、性能、稳定性、灵活性情况下。</p>
<p>有一些用户可能已经发现其他的一些网络框架声称自己也有同样的优势，所以你可能会问是Netty和他们有什么不一样。答案就是Netty的哲学设计理念。Netty从第一天开始就把API和实现设计成为你提供最舒适的使用体验。Netty的设计理念会使当你阅读本指南并且和Netty打交道的时候，让你的使用变得更加简单。</p>
<h1 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h1><p>这个章节会围绕Netty核心的结构并附上一些简单的例子让你快速的入门。当你读完本章节你马上就可以用Netty写出一个客户端和一个服务端。<br>如果你在学习某些东西的时候喜欢自顶向下的方法，你可能想要从第二个章节架构概述开始，然后再回到这里。</p>
<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>如果要运行本章节中的2个例子最低要求是：Netty的最新版本(Netty5)和JDK1.6及以上。最新的Netty版本在项目<a href="http://netty.io/downloads.html" target="_blank" rel="noopener">下载页面</a>。为了下载到正确的JDK版本，请到你偏爱的网站下载。<br>当你在读的过程中，你可能有很多关于本章节介绍的类相关的问题，每当你想知道他们的更多的信息那么请参考API说明文档。为了方便，所有文档中涉及到的类名字都会被关联到一个在线的API说明。当然如果有任何错误信息、语法错误或者你有任何好的建议来改进文档说明，那么请联系<a href="http://netty.io/community.html" target="_blank" rel="noopener">netty社区</a>。</p>
<h2 id="实现Discard服务器"><a href="#实现Discard服务器" class="headerlink" title="实现Discard服务器"></a>实现Discard服务器</h2><p>世界上最简单的协议不是”Hello,World!”，是<a href="http://tools.ietf.org/html/rfc863" target="_blank" rel="noopener">DISCARD</a>，他是一种丢弃所有接收的数据，并不做有任何响应的协议。<br>为了实现DISCARD协议，你唯一需要做的就是忽略所有收到的数据。让我们从处理器的实现开始，处理器是由Netty生成用来处理I/O事件的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.discard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles a server-side channel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123; <span class="comment">// (2)</span></span><br><span class="line">        <span class="comment">// Discard the received data silently.</span></span><br><span class="line">        ((ByteBuf) msg).release(); <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123; <span class="comment">// (4)</span></span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>DisCardServerHandler 继承自 <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" target="_blank" rel="noopener">ChannelHandlerAdapter</a>，这个类实现了<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>接口，ChannelHandler提供了许多事件处理的接口方法，然后你可以覆盖这些方法。现在仅仅只需要继承<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" target="_blank" rel="noopener">ChannelHandlerAdapter</a>类而不是你自己去实现接口方法。</p>
</li>
<li><p>这里我们覆盖了<code>chanelRead()</code>事件处理方法。每当从客户端收到新的数据时，这个方法会在收到消息时被调用，这个例子中，收到的消息的类型是<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a></p>
</li>
<li><p>为了实现DISCARD协议，处理器不得不忽略所有接受到的消息。<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a>是一个引用计数对象，这个对象必须显示地调用release()方法来释放。请记住处理器的职责是释放所有传递到处理器的引用计数对象。通常，channelRead()方法的实现就像下面的这段代码：</p>
</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Do something with msg</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>exceptionCaught()</code>事件处理方法是当出现Throwable对象才会被调用，即当Netty由于IO错误或者处理器在处理事件时抛出的异常时。在大部分情况下，捕获的异常应该被记录下来并且把关联的channel给关闭掉。然而这个方法的处理方式会在遇到不同异常的情况下有不同的实现，比如你可能想在关闭连接之前发送一个错误码的响应消息。</li>
</ul>
<p>到目前为止一切都还比较顺利，我们已经实现了DISCARD服务的一半功能，剩下的需要编写一个<code>main()</code>方法来启动服务端的DiscardServerHandler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.discard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Discards any incoming data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// (1)</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// (2)</span></span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class) <span class="comment">// (3)</span></span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; <span class="comment">// (4)</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)          <span class="comment">// (5)</span></span><br><span class="line">             .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Bind and start to accept incoming connections.</span></span><br><span class="line">            ChannelFuture f = b.bind(port).sync(); <span class="comment">// (7)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            <span class="comment">// In this example, this does not happen, but you can do that to gracefully</span></span><br><span class="line">            <span class="comment">// shut down your server.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            port = <span class="number">8080</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> DiscardServer(port).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="noopener">NioEventLoopGroup</a> 是用来处理I/O操作的多线程事件循环器，Netty提供了许多不同的<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="noopener">EventLoopGroup</a>的实现用来处理不同传输协议。在这个例子中我们实现了一个服务端的应用，因此会有2个<a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="noopener">NioEventLoopGroup</a>会被使用。第一个经常被叫做‘<code>boss</code>’，用来接收进来的连接。第二个经常被叫做‘<code>worker</code>’，用来处理已经被接收的连接，一旦‘<code>boss</code>’接收到连接，就会把连接信息注册到‘<code>worker</code>’上。如何知道多少个线程已经被使用，如何映射到已经创建的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channels</a>上都需要依赖于<a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="noopener">EventLoopGroup</a>的实现，并且可以通过构造函数来配置他们的关系。</li>
<li><a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="noopener">ServerBootstrap</a> 是一个启动NIO服务的辅助启动类。你可以在这个服务中直接使用<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>，但是这会是一个复杂的处理过程，在很多情况下你并不需要这样做。</li>
<li>这里我们指定使用<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="noopener">NioServerSocketChannel</a>类来举例说明一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>如何接收进来的连接。</li>
<li>这里的事件处理类经常会被用来处理一个最近的已经接收的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>。<a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="noopener">ChannelInitializer</a>是一个特殊的处理类，他的目的是帮助使用者配置一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>。也许你想通过增加一些处理类比如DiscardServerHandle来配置一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>或者其对应的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="noopener">ChannelPipeline</a>来实现你的网络程序。当你的程序变的复杂时，可能你会增加更多的处理类到<code>pipline</code>上，然后提取这些匿名类到最顶层的类上。</li>
<li>你可以设置这里指定的通道实现的配置参数。我们正在写一个TCP/IP的服务端，因此我们被允许设置socket的参数选项比如<code>tcpNoDelay</code>和<code>keepAlive</code>。请参考<a href="http://netty.io/5.0/api/io/netty/channel/ChannelOption.html" target="_blank" rel="noopener">ChannelOption</a>和详细的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelConfig.html" target="_blank" rel="noopener">ChannelConfig</a>实现的接口文档以此可以对<a href="http://netty.io/5.0/api/io/netty/channel/ChannelOption.html" target="_blank" rel="noopener">ChannelOptions</a>的有一个大概的认识。</li>
<li>你关注过<code>option()</code>和<code>childOption()</code>吗？<code>option()</code>是提供给<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="noopener">NioServerSocketChannel</a>用来接收进来的连接。childOption()是提供给由父管道<a href="http://netty.io/5.0/api/io/netty/channel/ServerChannel.html" target="_blank" rel="noopener">ServerChannel</a>接收到的连接，在这个例子中也是<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="noopener">NioServerSocketChannel</a>。</li>
<li>我们继续，剩下的就是绑定端口然后启动服务。这里我们在机器上绑定了机器所有网卡上的8080端口。当然现在你可以多次调用<code>bind()</code>方法(基于不同绑定地址)。</li>
</ul>
<p>恭喜！你已经完成熟练地完成了第一个基于NETTY的服务端程序。</p>
<h3 id="观察接收到的数据"><a href="#观察接收到的数据" class="headerlink" title="观察接收到的数据"></a>观察接收到的数据</h3><p>现在我们已经编写出我们第一个服务端，我们需要测试一下他是否真的可以运行。最简单的测试方法是用<code>telnet</code> 命令。例如，你可以在命令行上输入<code>telnet localhost 8080</code>或者其他类型参数。</p>
<p>然而我们能说这个服务端是正常运行了吗？事实上我们也不知道因为他是一个discard服务，你根本不可能得到任何的响应。为了证明他仍然是在工作的，让我们修改服务端的程序来打印出他到底接收到了什么。</p>
<p>我们已经知道<code>channelRead()</code>方法是在数据被接收的时候调用。让我们放一些代码到DiscardServerHandler类的<code>channelRead()</code>方法。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span>(<span class="params">ChannelHandlerContext ctx, Object msg</span>)</span> &#123;</span><br><span class="line">    ByteBuf <span class="keyword">in</span> = (ByteBuf) msg;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">in</span>.isReadable()) &#123; <span class="comment">// (1)</span></span><br><span class="line">            System.<span class="keyword">out</span>.print((<span class="keyword">char</span>) <span class="keyword">in</span>.readByte());</span><br><span class="line">            System.<span class="keyword">out</span>.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg); <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这个低效的循环事实上可以简化为:<code>System.out.println(in.toString(io.netty.util.CharsetUtil.US_ASCII))</code></p>
</li>
<li><p>或者，你可以在这里调用<code>in.release()</code>。</p>
</li>
</ul>
<p>如果你再次运行<code>telnet</code>命令，你将会看到服务端打印出了他所接收到的消息。</p>
<p>完整的discard server代码放在了<a href="http://netty.io/5.0/xref/io/netty/example/discard/package-summary.html" target="_blank" rel="noopener">io.netty.example.discard</a>包下面。</p>
<h2 id="ECHO服务（响应式协议）"><a href="#ECHO服务（响应式协议）" class="headerlink" title="ECHO服务（响应式协议）"></a>ECHO服务（响应式协议）</h2><p>到目前为止，我们虽然接收到了数据，但没有做任何的响应。然而一个服务端通常会对一个请求作出响应。让我们学习怎样在<a href="http://tools.ietf.org/html/rfc862" target="_blank" rel="noopener">ECHO</a>协议的实现下编写一个响应消息给客户端，这个协议针对任何接收的数据都会返回一个响应。</p>
<p>和discard server唯一不同的是把在此之前我们实现的<code>channelRead()</code>方法，返回所有的数据替代打印接收数据到控制台上的逻辑。因此，需要把<code>channelRead()</code>方法修改如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    ctx.<span class="built_in">write</span>(msg); <span class="comment">// (1)</span></span><br><span class="line">    ctx.<span class="built_in">flush</span>(); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerContext.html," target="_blank" rel="noopener">ChannelHandlerContext</a>对象提供了许多操作，使你能够触发各种各样的I/O事件和操作。这里我们调用了<code>write(Object)</code>方法来逐字地把接受到的消息写入。请注意不同于DISCARD的例子我们并没有释放接受到的消息，这是因为当写入的时候NETTY已经帮我们释放了。</li>
<li><code>ctx.write(Object)</code>方法不会使消息写入到通道上，他被缓冲在了内部，你需要调用<code>ctx.flush()</code>方法来把缓冲区中数据强行输出。或者你可以用更简洁的<code>cxt.writeAndFlush(msg)</code>以达到同样的目的。</li>
</ul>
<p>如果你再一次运行telnet命令，你会看到服务端会发回一个你已经发送的消息。<br>完整的echo服务的代码放在了<a href="http://netty.io/5.0/xref/io/netty/example/echo/package-summary.html" target="_blank" rel="noopener">io.netty.example.echo</a>包下面。</p>
<h2 id="TIME服务-时间协议的服务"><a href="#TIME服务-时间协议的服务" class="headerlink" title="TIME服务(时间协议的服务)"></a>TIME服务(时间协议的服务)</h2><p>在这个部分被实现的协议是<a href="http://tools.ietf.org/html/rfc868" target="_blank" rel="noopener">TIME</a>协议。和之前的例子不同的是在不接受任何请求时他会发送一个含32位的整数的消息，并且一旦消息发送就会立即关闭连接。在这个例子中，你会学习到如何构建和发送一个消息，然后在完成时主动关闭连接。</p>
<p>因为我们将会忽略任何接收到的数据，而只是在连接被创建发送一个消息，所以这次我们不能使用<code>channelRead()</code>方法了，代替他的是，我们需要覆盖<code>channelActive()</code>方法，下面的就是实现的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx)</span> </span>&#123; <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">final</span> ByteBuf time = ctx.alloc().buffer(<span class="number">4</span>); <span class="comment">// (2)</span></span><br><span class="line">        time.writeInt((<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000L</span> + <span class="number">2208988800L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ChannelFuture f = ctx.writeAndFlush(time); <span class="comment">// (3)</span></span><br><span class="line">        f.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">assert</span> f == future;</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// (4)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>channelActive()</code>方法将会在连接被建立并且准备进行通信时被调用。因此让我们在这个方法里完成一个代表当前时间的32位整数消息的构建工作。</li>
<li>为了发送一个新的消息，我们需要分配一个包含这个消息的新的缓冲。因为我们需要写入一个32位的整数，因此我们需要一个至少有4个字节的<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a>。通过<code>ChannelHandlerContext.alloc()</code>得到一个当前的ByteBufAllocator，然后分配一个新的缓冲。</li>
<li>和往常一样我们需要编写一个构建好的消息。但是等一等，flip在哪？难道我们使用NIO发送消息时不是调用<code>java.nio.ByteBuffer.flip()</code>吗？ByteBuf之所以没有这个方法因为有两个指针，一个对应读操作一个对应写操作。当你向ByteBuf里写入数据的时候写指针的索引就会增加，同时读指针的索引没有变化。读指针索引和写指针索引分别代表了消息的开始和结束。</li>
</ul>
<p>比较起来，NIO缓冲并没有提供一种简洁的方式来计算出消息内容的开始和结尾，除非你调用<code>flip</code>方法。当你忘记调用flip方法而引起没有数据或者错误数据被发送时，你会陷入困境。这样的一个错误不会发生在Netty上，因为我们对于不同的操作类型有不同的指针。你会发现这样的使用方法会让你过程变得更加的容易，因为你已经习惯一种没有使用<code>flip</code>的方式。</p>
<p>另外一个点需要注意的是<code>ChannelHandlerContext.write()</code>(和<code>writeAndFlush()</code>)方法会返回一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="noopener">ChannelFuture</a>对象，一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="noopener">ChannelFuture</a>代表了一个还没有发生的I/O操作。这意味着任何一个请求操作都不会马上被执行，因为在Netty里所有的操作都是异步的。举个例子下面的代码中在消息被发送之前可能会先关闭连接。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Channel ch = ...<span class="comment">;</span></span><br><span class="line">ch.writeAndFlush(message)<span class="comment">;</span></span><br><span class="line">ch.close()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>因此你需要在<code>write()</code>方法返回的ChannelFuture完成后调用<code>close()</code>方法，然后当他的写操作已经完成他会通知他的监听者。请注意,<code>close()</code>方法也可能不会立马关闭，他也会返回一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="noopener">ChannelFuture</a>。</p>
<ul>
<li>当一个写请求已经完成是如何通知到我们？这个只需要简单地在返回的ChannelFuture上增加一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html" target="_blank" rel="noopener">ChannelFutureListener</a>。这里我们构建了一个匿名的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html" target="_blank" rel="noopener">ChannelFutureListener</a>类用来在操作完成时关闭Channel。</li>
</ul>
<p>或者，你可以使用简单的预定义监听器代码:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">f</span><span class="selector-class">.addListener</span>(<span class="selector-tag">ChannelFutureListener</span><span class="selector-class">.CLOSE</span>);</span><br></pre></td></tr></table></figure>

<p>为了测试我们的time服务如我们期望的一样工作，你可以使用UNIX的<code>rdate</code>命令</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ rdate -o <span class="tag">&lt;<span class="name">port</span>&gt;</span> -p <span class="tag">&lt;<span class="name">host</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>port是你在<code>main()</code>函数中指定的端口，host使用locahost就可以了。</p>
<h2 id="Time客户端"><a href="#Time客户端" class="headerlink" title="Time客户端"></a>Time客户端</h2><p>不像DISCARD和ECHO的服务端，对于TIME协议我们需要一个客户端因为人们不能把一个32位的二进制数据翻译成一个日期或者日历。在这一部分，我们将会讨论如何确保服务端是正常工作的，并且学习怎样用NETTY编写一个客户端。</p>
<p>在Netty中,编写服务端和客户端最大的并且唯一不同的使用了不同的<a href="http://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="noopener">BootStrap</a>和<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>的实现。请看一下下面的代码：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String host = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap(); <span class="comment">// (1)</span></span><br><span class="line">            b.group(workerGroup); <span class="comment">// (2)</span></span><br><span class="line">            b.channel(NioSocketChannel.class); <span class="comment">// (3)</span></span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (4)</span></span><br><span class="line">            b.<span class="keyword">handler</span>(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the client.</span></span><br><span class="line">            ChannelFuture f = b.connect(host, port).sync(); <span class="comment">// (5)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the connection is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="noopener">BootStrap</a>和<a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="noopener">ServerBootstrap</a>类似,不过他是对非服务端的channel而言，比如客户端或者无连接传输模式的channel。</li>
<li>如果你只指定了一个<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="noopener">EventLoopGroup</a>，那他就会即作为一个‘<code>boss</code>’线程，也会作为一个‘<code>workder</code>’线程，尽管客户端不需要使用到‘<code>boss</code>’线程。</li>
<li>代替<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="noopener">NioServerSocketChannel</a>的是<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioSocketChannel.html" target="_blank" rel="noopener">NioSocketChannel</a>,这个类在客户端channel被创建时使用。</li>
<li>不像在使用ServerBootstrap时需要用<code>childOption()</code>方法，因为客户端的<a href="http://netty.io/5.0/api/io/netty/channel/socket/SocketChannel.html" target="_blank" rel="noopener">SocketChannel</a>没有父channel的概念。</li>
<li>我们用<code>connect()</code>方法代替了<code>bind()</code>方法。<br>正如你看到的，他和服务端的代码是不一样的。<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>是如何实现的?他应该从服务端接受一个32位的整数消息，把他翻译成人们能读懂的格式，并打印翻译好的时间，最后关闭连接:</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span>;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void channelRead(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg) &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> m = (<span class="type">ByteBuf</span>) msg; <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            long currentTimeMillis = (m.readUnsignedInt() - <span class="number">2208988800</span>L) * <span class="number">1000</span>L;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="keyword">new</span> <span class="type">Date</span>(currentTimeMillis));</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            m.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void exceptionCaught(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Throwable</span> cause) &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在TCP/IP中，NETTY会把读到的数据放到ByteBuf的数据结构中。</li>
</ul>
<p>这样看起来非常简单，并且和服务端的那个例子的代码也相差不多。然而，处理器有时候会因为抛出<code>IndexOutOfBoundsException</code>而拒绝工作。在下个部分我们会讨论为什么会发生这种情况。</p>
<h1 id="流数据的传输处理"><a href="#流数据的传输处理" class="headerlink" title="流数据的传输处理"></a>流数据的传输处理</h1><h2 id="一个小的Socket-Buffer问题"><a href="#一个小的Socket-Buffer问题" class="headerlink" title="一个小的Socket Buffer问题"></a>一个小的Socket Buffer问题</h2><p>在基于流的传输里比如TCP/IP，接收到的数据会先被存储到一个socket接收缓冲里。不幸的是，基于流的传输并不是一个数据包队列，而是一个字节队列。即使你发送了2个独立的数据包，操作系统也不会作为2个消息处理而仅仅是作为一连串的字节而言。因此这是不能保证你远程写入的数据就会准确地读取。举个例子，让我们假设操作系统的TCP/TP协议栈已经接收了3个数据包：</p>
<p><img src="/images/blog/netty/netty5_1.png" alt="netty socket buffer"></p>
<p>由于基于流传输的协议的这种普通的性质，在你的应用程序里读取数据的时候会有很高的可能性被分成下面的片段。</p>
<p><img src="/images/blog/netty/netty5_2.png" alt="netty socket buffer"></p>
<p>因此，一个接收方不管他是客户端还是服务端，都应该把接收到的数据整理成一个或者多个更有意思并且能够让程序的业务逻辑更好理解的数据。在上面的例子中，接收到的数据应该被构造成下面的格式：</p>
<p><img src="/images/blog/netty/netty5_3.png" alt="netty socket buffer"></p>
<h3 id="第一个解决方案"><a href="#第一个解决方案" class="headerlink" title="第一个解决方案"></a>第一个解决方案</h3><p>现在让我们回到TIME客户端的例子上。这里我们遇到了同样的问题，一个32字节数据是非常小的数据量，他并不见得会被经常拆分到到不同的数据段内。然而，问题是他确实可能会被拆分到不同的数据段内，并且拆分的可能性会随着通信量的增加而增加。</p>
<p>最简单的方案是构造一个内部的可积累的缓冲，直到4个字节全部接收到了内部缓冲。下面的代码修改了TimeClientHandler的实现类修复了这个问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ByteBuf buf;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        buf = ctx.alloc().buffer(<span class="number">4</span>); <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        buf.release(); <span class="comment">// (1)</span></span><br><span class="line">        buf = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf m = (ByteBuf) msg;</span><br><span class="line">        buf.writeBytes(m); <span class="comment">// (2)</span></span><br><span class="line">        m.release();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf.readableBytes() &gt;= <span class="number">4</span>) &#123; <span class="comment">// (3)</span></span><br><span class="line">            <span class="keyword">long</span> currentTimeMillis = (buf.readInt() - <span class="number">2208988800L</span>) * <span class="number">1000L</span>;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date(currentTimeMillis));</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>有2个生命周期的监听方法：handlerAdded()和handlerRemoved()。你可以完成任意初始化任务只要他不会被阻塞很长的时间。</li>
<li>首先，所有接收的数据都应该被累积在buf变量里。</li>
<li>然后，处理器必须检查buf变量是否有足够的数据，在这个例子中是4个字节，然后处理实际的业务逻辑。否则，Netty会重复调用channelRead()当有更多数据到达直到4个字节的数据被积累。</li>
</ul>
<h3 id="第二个解决方案"><a href="#第二个解决方案" class="headerlink" title="第二个解决方案"></a>第二个解决方案</h3><p>尽管第一个解决方案已经解决了Time客户端的问题了，但是修改后的处理器看起来不那么的简洁，想象一下如果由多个字段比如可变长度的字段组成的更为复杂的协议时，你的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>的实现将很快地变得难以维护。</p>
<p>正如你所知的，你可以增加多个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="noopener">ChannelPipeline</a> ,因此你可以把一整个ChannelHandler拆分成多个模块以减少应用的复杂程度，比如你可以把TimeClientHandler拆分成2个处理器：</p>
<ul>
<li>TimeDecoder处理数据拆分的问题</li>
<li>TimeClientHandler原始版本的实现</li>
</ul>
<p>幸运地是，Netty提供了一个可扩展的类，帮你完成TimeDecoder的开发。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void decode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> in, <span class="type">List</span>&lt;<span class="type">Object</span>&gt; out) &#123; <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// (3)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.add(in.readBytes(<span class="number">4</span>)); <span class="comment">// (4)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="noopener">ByteToMessageDecoder</a>是<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>的一个实现类，他可以在处理数据拆分的问题上变得很简单。</li>
<li>每当有新数据接收的时候，<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="noopener">ByteToMessageDecoder</a>都会调用decode()方法来处理内部的那个累积缓冲。</li>
<li><code>Decode()</code>方法可以决定当累积缓冲里没有足够数据时可以往out对象里放任意数据。当有更多的数据被接收了<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="noopener">ByteToMessageDecoder</a>会再一次调用<code>decode()</code>方法。</li>
<li>如果在<code>decode()</code>方法里增加了一个对象到out对象里，这意味着解码器解码消息成功。<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="noopener">ByteToMessageDecoder</a>将会丢弃在累积缓冲里已经被读过的数据。请记得你不需要对多条消息调用<code>decode()</code>，<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="noopener">ByteToMessageDecoder</a>会持续调用<code>decode()</code>直到不放任何数据到out里。</li>
</ul>
<p>现在我们有另外一个处理器插入到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="noopener">ChannelPipeline</a>里，我们应该在TimeClient里修改<a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="noopener">ChannelInitializer</a> 的实现：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">b.<span class="keyword">handler</span>(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> TimeDecoder(), <span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果你是一个大胆的人，你可能会尝试使用更简单的解码类<a href="http://netty.io/5.0/api/io/netty/handler/codec/ReplayingDecoder.html" target="_blank" rel="noopener">ReplayingDecoder</a>。不过你还是需要参考一下API文档来获取更多的信息。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void decode(</span><br><span class="line">        <span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> in, <span class="type">List</span> out) &#123;</span><br><span class="line">        out.add(in.readBytes(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，Netty还提供了更多可以直接拿来用的解码器使你可以更简单地实现更多的协议，帮助你避免开发一个难以维护的处理器实现。请参考下面的包以获取更多更详细的例子：</p>
<ul>
<li>对于二进制协议请看<a href="http://netty.io/5.0/xref/io/netty/example/factorial/package-summary.html" target="_blank" rel="noopener">io.netty.example.factorial</a></li>
<li>对于基于文本协议请看<a href="http://netty.io/5.0/xref/io/netty/example/telnet/package-summary.html" target="_blank" rel="noopener">io.netty.example.telnet</a></li>
</ul>
<h2 id="用POJO代替ByteBuf"><a href="#用POJO代替ByteBuf" class="headerlink" title="用POJO代替ByteBuf"></a>用POJO代替ByteBuf</h2><p>我们已经讨论了所有的例子，到目前为止一个消息的消息都是使用<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a>作为一个基本的数据结构。在这一部分，我们会改进TIME协议的客户端和服务端的例子，用POJO替代<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a>。</p>
<p>在你的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandlerS</a>中使用POJO优势是比较明显的。通过从<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>中提取出ByteBuf的代码，将会使<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>的实现变得更加可维护和可重用。在TIME客户端和服务端的例子中，我们读取的仅仅是一个32位的整形数据，直接使用ByteBuf不会是一个主要的问题。然后，你会发现当你需要实现一个真实的协议，分离代码变得非常的必要。</p>
<p>首先，让我们定义一个新的类型叫做UnixTime。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">package io.netty.example.time;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnixTime</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnixTime</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>((<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000L</span> + <span class="number">2208988800L</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnixTime</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date((<span class="keyword">value</span>() - <span class="number">2208988800L</span>) * <span class="number">1000L</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以修改下TimeDecoder类，返回一个UnixTime，以替代<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a></p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span>(<span class="params">ChannelHandlerContext ctx, ByteBuf <span class="keyword">in</span>, List&lt;Object&gt; <span class="keyword">out</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">in</span>.readableBytes() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">out</span>.<span class="keyword">add</span>(<span class="keyword">new</span> UnixTime(<span class="keyword">in</span>.readInt()));</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>下面是修改后的解码器，TimeClientHandler不再有任何的<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a>代码了。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    UnixTime m = (UnixTime) msg;</span><br><span class="line">    System.out.<span class="built_in">println</span>(m);</span><br><span class="line">    ctx.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是变得更加简单和优雅了？相同的技术可以被运用到服务端。让我们修改一下TimeServerHandler的代码。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    ChannelFuture f = ctx.writeAndFlush(<span class="keyword">new</span> UnixTime());</span><br><span class="line">    f.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，仅仅需要修改的是ChannelHandler的实现，这里需要把UnixTime对象重新转化为一个ByteBuf。不过这已经是非常简单了，因为当你对一个消息编码的时候，你不需要再处理拆包和组装的过程。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void write(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg, <span class="type">ChannelPromise</span> promise) &#123;</span><br><span class="line">        <span class="type">UnixTime</span> m = (<span class="type">UnixTime</span>) msg;</span><br><span class="line">        <span class="type">ByteBuf</span> encoded = ctx.alloc().buffer(<span class="number">4</span>);</span><br><span class="line">        encoded.writeInt(m.value());</span><br><span class="line">        ctx.write(encoded, promise); <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这几行代码里还有几个重要的事情。</p>
<ul>
<li>第一， 通过ChannelPromise，当编码后的数据被写到了通道上Netty可以通过这个对象标记是成功还是失败。</li>
<li>第二， 我们不需要调用<code>cxt.flush()</code>。因为处理器已经单独分离出了一个方法<code>void flush(ChannelHandlerContext cxt)</code>,如果像自己实现<code>flush</code>方法内容可以自行覆盖这个方法。</li>
</ul>
<p>进一步简化操作，你可以使用<a href="http://netty.io/5.0/api/io/netty/handler/codec/MessageToByteEncoder.html" target="_blank" rel="noopener">MessageToByteEncode</a>:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder&lt;UnixTime&gt;</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void encode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">UnixTime</span> msg, <span class="type">ByteBuf</span> out) &#123;</span><br><span class="line">        out.writeInt(msg.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的任务就是在TimeServerHandler之前把TimeEncoder插入到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="noopener">ChannelPipeline</a>。但这是不那么重要的工作。</p>
<h2 id="关闭你的应用"><a href="#关闭你的应用" class="headerlink" title="关闭你的应用"></a>关闭你的应用</h2><p>关闭一个Netty应用往往只需要简单地通过<code>shutdownGracefully()</code>方法来关闭你构建的所有的<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="noopener">NioEventLoopGroup</a>S.当<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="noopener">EventLoopGroup</a>被完全地终止,并且对应的所有channels都已经被关闭时，Netty会返回一个<a href="http://netty.io/5.0/api/io/netty/util/concurrent/Future.html" target="_blank" rel="noopener">Future</a>对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一章节中，我们会快速地回顾下如果在熟练掌握Netty的情况下编写出一个健壮能运行的网络应用程序。<br>在Netty接下去的章节中还会有更多更相信的信息。我们也鼓励你去重新复习下在<a href="https://github.com/netty/netty/tree/master/example/src/main/java/io/netty/example" target="_blank" rel="noopener">io.netty.example</a>包下的例子。<br>请注意<a href="http://netty.io/community.html" target="_blank" rel="noopener">社区</a>一直在等待你的问题和想法以帮助Netty的持续改进，Netty的文档也是基于你们的快速反馈上。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/netty/" rel="tag"># netty</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/09/18/maven-generate-project/" rel="next" title="解决Maven使用artchetype:create创建工程失败的问题">
                <i class="fa fa-chevron-left"></i> 解决Maven使用artchetype:create创建工程失败的问题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/10/19/etcd-application-scenarios/" rel="prev" title="ETCD应用场景">
                ETCD应用场景 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://avatars1.githubusercontent.com/u/629519?v=3&s=460" alt="Tony Deng">
          <p class="site-author-name" itemprop="name">Tony Deng</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">68</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">130</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/tonydeng" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/wolfdeng" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/tonydeng" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-global"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#特性"><span class="nav-number">1.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设计"><span class="nav-number">1.1.</span> <span class="nav-text">设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#易用"><span class="nav-number">1.2.</span> <span class="nav-text">易用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能"><span class="nav-number">1.3.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安全"><span class="nav-number">1.4.</span> <span class="nav-text">安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#社区"><span class="nav-number">1.5.</span> <span class="nav-text">社区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">2.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题"><span class="nav-number">2.1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决方案"><span class="nav-number">2.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#入门指南"><span class="nav-number">3.</span> <span class="nav-text">入门指南</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#开始之前"><span class="nav-number">3.1.</span> <span class="nav-text">开始之前</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现Discard服务器"><span class="nav-number">3.2.</span> <span class="nav-text">实现Discard服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#观察接收到的数据"><span class="nav-number">3.2.1.</span> <span class="nav-text">观察接收到的数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ECHO服务（响应式协议）"><span class="nav-number">3.3.</span> <span class="nav-text">ECHO服务（响应式协议）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIME服务-时间协议的服务"><span class="nav-number">3.4.</span> <span class="nav-text">TIME服务(时间协议的服务)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Time客户端"><span class="nav-number">3.5.</span> <span class="nav-text">Time客户端</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流数据的传输处理"><span class="nav-number">4.</span> <span class="nav-text">流数据的传输处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一个小的Socket-Buffer问题"><span class="nav-number">4.1.</span> <span class="nav-text">一个小的Socket Buffer问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一个解决方案"><span class="nav-number">4.1.1.</span> <span class="nav-text">第一个解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二个解决方案"><span class="nav-number">4.1.2.</span> <span class="nav-text">第二个解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用POJO代替ByteBuf"><span class="nav-number">4.2.</span> <span class="nav-text">用POJO代替ByteBuf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关闭你的应用"><span class="nav-number">4.3.</span> <span class="nav-text">关闭你的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2005 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tony Deng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>



<script type="text/javascript" src="//cdn.bootcss.com/mermaid/6.0.0/mermaid.min.js?v=6.0.0"></script>

  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  

  

  

</body>
</html>
