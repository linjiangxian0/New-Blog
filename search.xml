<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于STRIDE进行威胁建模</title>
      <link href="2022/04/20/threat-modeling-was-conducted-based-on-STRIDE/"/>
      <url>2022/04/20/threat-modeling-was-conducted-based-on-STRIDE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是STRIDE威胁建模"><a href="#1-什么是STRIDE威胁建模" class="headerlink" title="1. 什么是STRIDE威胁建模"></a>1. 什么是STRIDE威胁建模</h2><p>计算机发明后不久，人脉就发现需要为这些信息系统处理威胁。早在1994年，NSA和DARPA就提出攻击树、威胁树等概念。1999年微软内部发表了《The threats to out products》的文章，为定义Windows全系列产品面临的安全威胁正式提出了<code>STRIDE</code>。随着2002年比尔.盖茨著名的<a href="https://www.wired.com/2002/01/bill-gates-trustworthy-computing/" target="_blank" rel="noopener">《可信任计算备忘》</a>发布，微软承诺改善软件产品的安全性，随即正式在SDL（安全开发生命周期）中采用了威胁建模。</p><p>研发团队的安全例行活动中，对于一些拥有重要数据资产、安全事件影响力大的系统除了要进行常规的渗透测试、黑白盒代码扫描以外，更应该系统定期开展威胁建模活动并对业务赋能。所以对于研发团队来说，引入先进的安全技术设计能力，构建全方位、多维度防御体系，是不懈追求的目标。</p><p>通过威胁建模，我们能够实现以下这些价值：</p><ul><li><strong>识别体系化的结构缺陷</strong>：大多数安全问题是设计缺陷问题，而不是安全性错误。威胁建模能帮助识别这些设计缺陷，从而减少风险敞口，指导安全测试，并降低因安全漏洞而造成的品牌损害或财务损失等可能性。</li><li><strong>节约组织安全成本</strong>：通过对威胁进行建模，并在设计阶段建立安全性需求，降低安全设计缺陷导致的修复成本。在需求管理和威胁分析阶段，与业务开发团队高效互动，释放安全团队的专业能力，专注于高性价比的安全建设。</li><li><strong>落地DevSecOps文化</strong>：通过威胁建模跑通开发和安全工具的流程集成，把风险管理嵌入产品的完整生命周期，从而推动形成完整的<code>DevSecOps</code>工具链。</li><li><strong>满足合规要求</strong>：威胁建模是国际安全行业通用的方法论，通过向管理层和监管机构提供产品的风险管理活动的完整记录，帮助团队遵守全球法律法规要求，包括<code>PCI DSS</code>、<code>GDPR</code>、<code>HIPAA</code>、<code>CSA STAR</code>等。</li></ul><p><code>STRIDE</code>作为当前最流行的威胁建模方法，是值得研发团队引入的威胁建模的方法。<code>STRIDE</code>是以下英文的首字母缩写，把威胁分为6类，基本上涵盖了所有的威胁类型，帮助建模者对威胁进行建模。</p><ul><li><code>S</code>：<code>Spoofing</code>（假冒）</li><li><code>T</code>：<code>Tampering</code>（篡改）</li><li><code>R</code>：<code>Repudiation</code>（抵赖）</li><li><code>I</code>：<code>Information Disclosure</code>（信息泄露）</li><li><code>D</code>：<code>Denial of Service</code>（拒绝服务）</li><li><code>E</code>：<code>Elevation of Privilege</code>（权限提升）</li></ul><h2 id="2-STRIDE威胁建模整体流程"><a href="#2-STRIDE威胁建模整体流程" class="headerlink" title="2. STRIDE威胁建模整体流程"></a>2. STRIDE威胁建模整体流程</h2><p><code>STRIDE</code>威胁建模方法贯穿于整体风险分析流程，将安全需求分析和安全设计相互融合。<code>STRIDE</code>威胁建模不仅仅可以用于安全需求分析和设计，也可用于后续安全开发环节。</p><p><img src="/images/blog/stride/STRIDE-Activity-Main.png" alt="STRIDE整体活动流程"></p><a id="more"></a><p>在威胁建模过程中起主导作用的是软件设计者、开发人员和测试人员。威胁建模的对象并不一定是一个完整的软件。根据需求的不同，建模对象可以是整个应用、安全和隐私相关的功能、跨信任边界的功能等等。</p><p><img src="/images/blog/stride/STRIDE-Entity-Main.png" alt="stride entity main"></p><p>威胁建模的整体过程，本质上就是通过分析系统中的各个组件本身的安全弱点和影响，形成安全风险评估，同时基于安全风险提出相应的安全要求和采用相关的安全措施，缓解安全威胁，降低安全风险。</p><h2 id="3-威胁建模"><a href="#3-威胁建模" class="headerlink" title="3. 威胁建模"></a>3. 威胁建模</h2><p>建模是对软件进行抽象，数据流图、统一UML图表、泳道图和状态图等都可用于软件建模。接下来主要介绍数据流图建模过程。</p><p><img src="/images/blog/stride/Threat-Model-Main.png" alt="威胁建模活动"></p><p>数据流图建模过程的主要步骤包括：</p><ul><li><strong>定义应用场景</strong>：为了明确应用或系统的关键威胁场景，包括部署方式、配置信息、用户使用方式。</li><li><strong>收集外部依赖</strong>：收集应用或系统所依赖的外部产品、功能或服务信息。典型外部依赖包括操作系统、数据库、Web服务器、应用服务器。</li><li><strong>定义安全假设</strong>：采用来自其他功能组件所提供的安全服务假设，定义安全假设是为了对应用所依赖的系统环境做出准确的安全假设。</li><li><strong>创建外部安全备注</strong>：为了让与产品相关的用户或其他应用的设计者都可以利用外部安全备注，辅助理解应用的安全边界，以及在使用应用时应如何保障安全不受侵害。</li><li><strong>绘制数据流图</strong>：描述系统的一种方法，是威胁建模的重要产物，它使用易于理解的一种图形表示工具分析系统或应用可能面临的攻击。</li></ul><p><strong>其中绘制数据流图是建模过程的重点，其余步骤都是为绘制正确的数据流图做准备。</strong></p><p><img src="/images/blog/stride/stride-dataflows-diagram-elements.png" alt="数据流图的元素及其含义"></p><blockquote><p>建模首先确定要分析的应用程序边界或作用范围，确定可信任部分与不可信任部分的界限。</p></blockquote><p>在数据流图中创建和命名实体应遵循以下规则：</p><ul><li>一个过程必须<strong>至少有一个数据流流入和一个数据流流出</strong></li><li>所有的数据流<strong>都从某个过程开始，到某个过程结束</strong></li><li>数据存储<strong>通过数据流</strong>与过程相连</li><li>数据存储不能直接连接，<strong>必须通过过程相连</strong></li></ul><h3 id="3-1-High-Level威胁建模"><a href="#3-1-High-Level威胁建模" class="headerlink" title="3.1. High Level威胁建模"></a>3.1. High Level威胁建模</h3><p>High Level你可以理解为系统上下文图（System Context Diagram），这一层级中细节并不重要，只显示系统概况。 重点应该放在人员（角色）和软件系统上，而不是技术，协议和其他低层级细节上，从而使非技术人员也能够看得懂。这个图也是明确需求的重要图示。这表示一个应用和其他系统的下辖有调用关系。不需要完整表示数据的流向，只要大致描述清楚系统的周边关系，不遗漏关键步骤。</p><p><img src="/images/blog/stride/Azure-stride-dataflows.jpeg" alt="Azure high level dataflow"></p><blockquote><p>微软Azure的威胁建模的数据流图，有点是通过数字表示流程顺序</p></blockquote><h3 id="3-2-Low-Level威胁建模"><a href="#3-2-Low-Level威胁建模" class="headerlink" title="3.2. Low Level威胁建模"></a>3.2. Low Level威胁建模</h3><p>Low Level可以采用两种建模方式。</p><h4 id="3-2-1-应用图（Application-Diagram）"><a href="#3-2-1-应用图（Application-Diagram）" class="headerlink" title="3.2.1. 应用图（Application Diagram）"></a>3.2.1. 应用图（Application Diagram）</h4><p>应用是可单独运行/可部署的单元（例如，单独的进程空间）执行代码或存储数据。应用图显示了软件体系结构的高层结构以及如何分配职责。它还显示了主要的技术选择以及容器之间的通信方式。</p><p>一个应用包含多个服务，如果一个系统有多个子系统，应该对每个子系统都进行分析。通过威胁建模应该尝试了解整体情况，包含应用本身、数据库、交互、部署场景、云服务、接入的基础服务。</p><p><img src="/images/blog/stride/pay-stride-dataflow.jpeg" alt="支付应用示例"></p><h4 id="3-2-2-服务图（Service-Component-diagram）"><a href="#3-2-2-服务图（Service-Component-diagram）" class="headerlink" title="3.2.2. 服务图（Service Component diagram）"></a>3.2.2. 服务图（Service Component diagram）</h4><p>服务图显示了服务如何由多个“组件”组成，每个组件是什么，它们的职责以及技术/实现接口（API）或者细节。这个细粒度的分解是建模最大的工作量，为分解的各个通用组件创建的威胁模型结果可以复用在其他应用上。比如Kubernetes被分为Kube-Proxy、ETCD、Kubelet、Kube-APIServer、Scheduler、Container、Pods等。</p><p><img src="/images/blog/stride/k8s-dataflows.jpeg" alt="k8s示例"></p><h2 id="4-威胁识别"><a href="#4-威胁识别" class="headerlink" title="4. 威胁识别"></a>4. 威胁识别</h2><p>建模完成后，进入威胁识别过程。</p><p><img src="/images/blog/stride/Threat-Identification-Main.png" alt="威胁识别主要活动"></p><p>威胁识别方法包括<code>STRIDE</code>方法、攻击树、攻击库等。主要关注<code>STRIDE</code>威胁识别方法。</p><p>该方法分析各个数据流及其关联的资产是否受到<code>S、T、R、I、D、E</code>威胁的影响，识别并记录这些威胁，然后使用<code>DREAD</code>方法对威胁进行量化分析，评估可能造成的危害程度。</p><h3 id="4-1-STRIDE-per-Element模型"><a href="#4-1-STRIDE-per-Element模型" class="headerlink" title="4.1. STRIDE-per-Element模型"></a>4.1. STRIDE-per-Element模型</h3><p><code>STRIDE-per-Element</code>使得STRIDE更加规范，通过关注每一个元素的一系列威胁，可以更容易地找到威胁。</p><table><thead><tr><th>元素</th><th>交互</th><th>S（假冒）</th><th>T（篡改）</th><th>R（抵赖）</th><th>I（信息泄露）</th><th>D（拒绝服务）</th><th>E（权限提升）</th></tr></thead><tbody><tr><td>外部实体(浏览器)</td><td>外部交互实体将输入传入到过程</td><td>*</td><td></td><td>*</td><td>*</td><td></td><td></td></tr><tr><td></td><td>外部交互实体从进程得到输入</td><td>*</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>进程</td><td>进程有外来数据攒送至数据存储</td><td>*</td><td></td><td>*</td><td></td><td></td><td></td></tr><tr><td></td><td>进程向另一个进程输出数据</td><td>*</td><td></td><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td></td><td>进程向外部交互实体（代码）发送输出</td><td>*</td><td></td><td>*</td><td>*</td><td>*</td><td></td></tr><tr><td></td><td>进程向外部交互实体（人类）发送输出</td><td></td><td></td><td>*</td><td></td><td></td><td></td></tr><tr><td></td><td>进程有来自数据存储的输入数据流</td><td>*</td><td>*</td><td></td><td></td><td>*</td><td>*</td></tr><tr><td></td><td>进程有来自另一个进程的输入数据流</td><td>*</td><td></td><td>*</td><td></td><td>*</td><td>*</td></tr><tr><td></td><td>进程有来自外部交互实体的输入数据流</td><td>*</td><td></td><td></td><td></td><td>*</td><td>*</td></tr><tr><td>数据流（命令/响应）</td><td>跨越机器边界</td><td></td><td>*</td><td></td><td>*</td><td>*</td><td></td></tr><tr><td>数据存储（数据库）</td><td>进程有输出数据流至数据存储</td><td></td><td>*</td><td>*</td><td>*</td><td>*</td><td></td></tr><tr><td></td><td>进程有来自数据存储的输入数据流</td><td>*</td><td></td><td>*</td><td>*</td><td></td><td></td></tr></tbody></table><p>如何进行威胁识别，可以参考下面这个的例子，场景是租户通过第三方开放平台登录后通过微服务处理业务。</p><p><img src="/images/blog/stride/openapi-platform-example.jpeg" alt="openapi platform"></p><ul><li><p>对于API网关，存在的威胁包括：</p><ul><li>认证和授权</li><li>未强制HTTPS</li><li>缺失二次认证措施</li><li>日志和监控</li><li>缺失日志记录和审计模块</li><li>日志本地留存</li></ul></li><li><p>对于IAM服务服务器，存在的威胁包括：</p><ul><li>信息泄露：用户身份信息泄露</li><li>认证<ul><li>暴力破解对外发送的管理平台Token</li><li>授权策略绕过</li></ul></li><li>可用性<ul><li>单机实例，误操作可导致宕机风险</li></ul></li></ul></li><li><p>对于MySQL服务，部分存在的威胁包括：</p><ul><li>认证：攻击者获取凭据后可以直接访问、修改、删除业务数据</li><li>权限提升：攻击者可以从普通用户提升至Root，获取数据库完全控制权限</li><li>信息泄露：SQL注入导致所保存的业务数据泄露</li></ul></li></ul><h3 id="4-2-威胁发现"><a href="#4-2-威胁发现" class="headerlink" title="4.2. 威胁发现"></a>4.2. 威胁发现</h3><p>使用STRIDE对威胁分类后，可以使用威胁树分析程序中的威胁和漏洞。</p><blockquote><p>硬件领域常用“故障树”识别可能存在的故障模式，同样的方法也适用于描述软件安全问题。</p></blockquote><p><strong>威胁树起源于故障树，采用树形结构描述系统面临的威胁。</strong></p><p>用根节点表示系统所面临威胁的抽象描述，逐层细化威胁的细节信息，直到用叶节点表示具体攻击方式。</p><p>威胁树描述了攻击者破坏各组件所经历的决策过程。</p><h3 id="4-3-威胁评估"><a href="#4-3-威胁评估" class="headerlink" title="4.3. 威胁评估"></a>4.3. 威胁评估</h3><p>建立威胁树后，就可以对威胁进行量化评估，评定其严重程度，可以使用DREAD方法来完成。</p><p>DREAD方法是以下单词的首字母缩写，分别从五个方面描述威胁的危害程度，每个方面危害程度的评分范围是1～10,10表示威胁造成的危害程度最大。</p><ul><li><strong><code>Damage potential</code>（潜在破坏性）</strong>: 用于衡量威胁可能造成的实际破坏程度，如10可以表示攻击者可能绕开所有安全限制，实际上能做任何事情；7～8表示攻击者能读取机密数据；6表示攻击者能使服务器暂时不可用。</li><li><strong><code>Reproducibility</code>（再现性）</strong>：即衡量威胁可能造成的实际破坏程度，如10可以表示攻击者可能绕开所有安全限制，实际上能做任何事情；7～8表示攻击者能读取机密数据；6表示攻击者能使服务器暂时不可用。</li><li><strong><code>Exploitability</code>（可利用性）</strong>：指的是进行一次攻击需要的努力和专业知识。如果一个普通用户使用一台家庭计算机就能实施攻击，可以评定为10。如果需要动用大量人力物力才能进行一次攻击，那么可利用性评为1。</li><li><strong><code>Affected users</code>（受影响用户）</strong>：指如果威胁被利用并成功攻击，有多少用户会受到影响，10指所有用户都会受到影响，1～9表示受影响用户的百分比。</li><li><strong><code>Discoverability</code>（可发现性）</strong>：指如果威胁被利用并成功攻击，有多少用户会受到影响，10指所有用户都会受到影响，1～9表示受影响用户的百分比。</li></ul><p>依据公式 *<em>“风险=受攻击概率</em>危害程度”** ，可以计算出五个风险值，然后对五个风险值求平均数，平均数越大，则威胁对系统造成的风险就越大。假设受攻击概率为100%，最高风险值是10。</p><h2 id="5-威胁缓解"><a href="#5-威胁缓解" class="headerlink" title="5. 威胁缓解"></a>5. 威胁缓解</h2><p>识别威胁后，就可以对已经暴露的威胁进行缓解。</p><p>不同风险等级的威胁可以采取不同处理策略：</p><ul><li>低风险安全威胁，可以保持现状</li><li>潜在的用户危险操作，要及时提醒</li><li>可以缓解的威胁，要采取加密、认证等技术缓解措施</li><li>风险过高并且难以实施缓解措施的威胁，可以考虑删除/关闭相应功能</li></ul><h3 id="5-1-确立缓解顺序"><a href="#5-1-确立缓解顺序" class="headerlink" title="5.1. 确立缓解顺序"></a>5.1. 确立缓解顺序</h3><p>威胁的缓解顺序在整体设计上要有条理性和层次性。</p><blockquote><p>例如，对闯入家里进行威胁建模。考虑窗户是受攻击面，那么威胁包括打破窗户进入和打开窗户进入的人。</p><p>打破窗户可以通过使用强化玻璃来阻止，这就是一阶缓解措施；</p><p>打破玻璃威胁也可以通过警报来解决，这就是二阶防御措施。</p><p>如果切掉电源，警报失效，为了解决这个三阶威胁，系统设计人员可以添加更多的防御措施，例如，警报包含剪断电源警报，防御者可以添加电池、手机或者其他无线设备。</p></blockquote><p>虽然具体威胁所采用的缓解措施截然不同，但是一定要有全面的缓解措施，因为一旦底层的措施出现纰漏，无论高层措施多么完善，攻击者依然可以以很低成本进行攻击。</p><h3 id="5-2-常用缓解方法"><a href="#5-2-常用缓解方法" class="headerlink" title="5.2. 常用缓解方法"></a>5.2. 常用缓解方法</h3><p>不同安全威胁需要采用不同的技术缓解方法。</p><p><img src="/images/blog/stride/threat-mitigation-program.png" alt="威胁缓解方案"></p><blockquote><p>上面是几种常用的缓解方法，包括认证、授权、防篡改和增强保密性的技术。</p></blockquote><p>在建模、识别及缓解威胁的过程中，必须记录每一个操作的详细信息，以便于理解和管理。</p><h2 id="6-威胁验证"><a href="#6-威胁验证" class="headerlink" title="6. 威胁验证"></a>6. 威胁验证</h2><p>验证是为了确保威胁模型准确反映应用程序的潜在安全问题，验证的内容包括:</p><ul><li>威胁模型</li><li>列举的威胁</li><li>缓解措施和假设</li></ul><p>验证威胁是说明列举出的威胁如何进行攻击，攻击的内容及影响。</p><p>如果验证威胁出现问题，说明威胁没有被正确识别，可能需要重新建模。</p><p>此外，还要分析威胁列举是否全面，如与可信边界接触的元素都可能被污染，这些元素都应该考虑STRIDE威胁。</p><p>如果建模时得到的威胁不够全面，需要进一步补充。</p><p>验证缓解措施是指检验缓解措施能否有效降低威胁影响，是否正确实施，每个威胁是否都有相应缓解措施。一旦措施无效，或者低效，必须重新选择缓解方法。如果没有正确实施，应该发出警告，确保缓解措施的有效性。</p><p><strong>危害较为严重的威胁都要有缓解措施，以减少危害程度</strong>。</p><p>验证假设是为了判断假设是否正确，只有假设合理，才能保证在假设条件下进行的操作是合理的。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.wired.com/2002/01/bill-gates-trustworthy-computing/" target="_blank" rel="noopener">Trustworthy Computing - Bill Gates</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">可信计算-维基百科</a></li><li><a href="https://github.com/google/end-to-end/wiki/Threat-model" target="_blank" rel="noopener">Threat Model- Google</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 威胁建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STRIDE </tag>
            
            <tag> SDL </tag>
            
            <tag> 威胁建模 </tag>
            
            <tag> Threat-Modeling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFX中的可测试性是什么？</title>
      <link href="2020/11/26/what-is-testability-in-DFX/"/>
      <url>2020/11/26/what-is-testability-in-DFX/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/DFX/DFX.jpg" alt="DFX"></p><h2 id="为什么引入可测试性设计？"><a href="#为什么引入可测试性设计？" class="headerlink" title="为什么引入可测试性设计？"></a>为什么引入可测试性设计？</h2><p>在讨论可测试性之前，我们不妨先来思考一个问题：</p><p>当我们来盖一栋楼，如果不能保证钢筋、水泥、砖土质量合格，却想要盖出合格的大楼来，这个可能吗？</p><p>然而，很多团队的软件开发就是这么做的。很荒唐吧！</p><a id="more"></a><p><img src="/images/blog/DFX/DFX-Type.png" alt="DFX类型"></p><p>在非功能性需求中，执行质量是很多程序员的心头所爱，一般也不会被忽略。但<strong>演化质量的地位却很低，常常为人忽略，尤其是其中的“可测试性”</strong>。</p><p>可测试性为什么如此重要？因为我们做设计，其实就是把<strong>一个软件拆分成一个一个的小模块</strong>。</p><p>如果不尽可能地保证每个小模块的正确性，而只是从最外围的系统角度去验证系统的正确性，这将会是一个非常困难的过程。</p><h2 id="可测试性的定义"><a href="#可测试性的定义" class="headerlink" title="可测试性的定义"></a>可测试性的定义</h2><p>软件的可测试性是指在<strong>一定时间和成本前提下</strong>，进行<strong>测试设计、测试执行</strong>以此来<strong>发现软件的问题</strong>，以及<strong>发现故障并隔离、定位其故障</strong>的能力特点。</p><p>采用<a href="https://en.wikipedia.org/wiki/James_Marcus_Bach" target="_blank" rel="noopener">James Bach</a>的定义，<strong>可测试性就是一个计算机程序能够被测试的容易程度</strong>。</p><p> 我设计了一个公式来用于计算 *<em>软件可测试性 = (测试方法覆盖度 * 测试资源保障度) / 测试目标*</em></p><blockquote><p>维基百科中是这样定义<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E5%8F%AF%E6%B8%AC%E8%A9%A6%E6%80%A7" target="_blank" rel="noopener">软件可测试性(Software testability)</a>：<strong>一个软件工件（软件系统、组件、需求文档或设计文档等）在一给定的测试环境下，可支持测试的程度</strong>。</p></blockquote><p>一般来说，可测试性好的软件必然是一个<strong>强内聚</strong>、<strong>弱耦合</strong>、<strong>接口明确</strong>、<strong>意图清晰</strong>的软件。</p><h2 id="可测试性的分析"><a href="#可测试性的分析" class="headerlink" title="可测试性的分析"></a>可测试性的分析</h2><p>那可测试性到底包括什么呢？我们从不同的维度来看可测试性的特征。</p><h3 id="角色和职责"><a href="#角色和职责" class="headerlink" title="角色和职责"></a>角色和职责</h3><blockquote><p>不同的岗位在可测试性中的角色</p></blockquote><p><img src="/images/blog/DFX/testability/actors.png" alt="Actors"></p><h3 id="可测试性的各个视角"><a href="#可测试性的各个视角" class="headerlink" title="可测试性的各个视角"></a>可测试性的各个视角</h3><blockquote><p>从不同的视角来看可测试性包含哪些特征</p></blockquote><p><img src="/images/blog/DFX/testability/Usecase.png" alt="可测试性的各个视角"></p><h3 id="可观察"><a href="#可观察" class="headerlink" title="可观察"></a>可观察</h3><blockquote><p>你所看见的就是你所测试的</p></blockquote><p><img src="/images/blog/DFX/testability/can-be-viewed-usecase.png" alt="可观察用例"></p><h3 id="可操作"><a href="#可操作" class="headerlink" title="可操作"></a>可操作</h3><blockquote><p>运行的越好，被测试的效率越高</p></blockquote><p><img src="/images/blog/DFX/testability/operability-usecase.png" alt="可操作用例"></p><h3 id="可控制"><a href="#可控制" class="headerlink" title="可控制"></a>可控制</h3><blockquote><p>对软件控制的越好，测试越能够被自动执行与优化</p></blockquote><p><img src="/images/blog/DFX/testability/can-be-controlled-usecase.png" alt="可控制用例"></p><h3 id="可理解性"><a href="#可理解性" class="headerlink" title="可理解性"></a>可理解性</h3><blockquote><p>得到的信息越多，进行的测试越准确、精细</p></blockquote><p><img src="/images/blog/DFX/testability/can-understand-usecase.png" alt="可理解性用例"></p><h3 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h3><blockquote><p>需要测试的内容越少，测试的速度越快</p></blockquote><p><img src="/images/blog/DFX/testability/simplicity-usecase.png" alt="简单性用例"></p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><blockquote><p>改变越少，对测试的破坏越小</p></blockquote><p><img src="/images/blog/DFX/testability/stability-usecase.png" alt="稳定性用例"></p><h3 id="可分解"><a href="#可分解" class="headerlink" title="可分解"></a>可分解</h3><blockquote><p>通过控制测试范围，能够更好分解问题，执行测试</p></blockquote><p><img src="/images/blog/DFX/testability/decomposability-usecase.png" alt="可分解性用例"></p>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
            <tag> DFX </tag>
            
            <tag> 可测试性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust的闭包类型(Fn, FnMut, FnOne的区别)</title>
      <link href="2019/11/09/rust-closure-type/"/>
      <url>2019/11/09/rust-closure-type/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/rust/rust-language.jpg" alt="Rust Logo"></p><p>对于支持函数式编程的语言来说，支持闭包是一个非常必要的能力。但是我们在<code>Rust</code>中使用闭包的时候经常会出现一些莫名其妙、无法理解的错误。</p><p>你可能会这样的经历：你非常兴奋的使用闭包这个特性写了一段自认牛逼的代码，发现根本无法编译通，修改了好几次，终于在编译器的友（残）好（暴）提（敲）示（打）下，终于编译完成，执行成功了，但是下一次依然碰到同样的遭遇。</p><p>为了避免持续出现这样的情况，我们来系统的看一看<code>Rust</code>中的闭包。</p><a id="more"></a><h2 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h2><p>先来看看<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">维基百科</a>上的描述：</p><blockquote><p>在计算机科学中，闭包（英语：<code>Closure</code>），又称词法闭包（<code>Lexical Closure</code>）或函数闭包（<code>function closures</code>），是<strong>引用了自由变量的函数</strong>。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p></blockquote><p>闭包的概念出现于60年代，最早实现闭包的程序语言是<code>Scheme</code>。之后，闭包被广泛使用于函数式编程语言如<code>ML</code>语言和<code>LISP</code>。很多命令式程序语言也开始支持闭包。</p><p>可以看到，第一句就已经说明了什么是闭包：闭包是引用了自由变量的函数。所以，闭包是一种特殊的函数。</p><p>在<code>Rust</code>里，闭包被分为了三种类型，列举如下</p><ul><li><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html" target="_blank" rel="noopener">Fn(&amp;self)</a></li><li><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html" target="_blank" rel="noopener">FnMut(&amp;mut self)</a></li><li><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html" target="_blank" rel="noopener">FnOnce(self)</a></li></ul><p>在<code>rust</code>中，函数和闭包都是实现了<code>Fn</code>、<code>FnMut</code>或<code>FnOnce</code>特质（<code>trait</code>）的类型。任何实现了这三种特质其中一种的类型的对象，都是 可调用对象 ，都能像函数和闭包一样通过这样<code>name()</code>的形式调用，<code>()</code>在<code>rust</code>中是一个操作符，操作符在<code>rust</code>中是可以重载的。<code>rust</code>的操作符重载是通过实现相应的<code>trait</code>来实现，而<code>()</code>操作符的相应<code>trait</code>就是<code>Fn</code>、<code>FnMut</code>和<code>FnOnce</code>，所以，任何实现了这三个<code>trait</code>中的一种的类型，其实就是重载了<code>()</code>操作符。</p><h2 id="Rust中三种闭包的定义："><a href="#Rust中三种闭包的定义：" class="headerlink" title="Rust中三种闭包的定义："></a><code>Rust</code>中三种闭包的定义：</h2><p><img src="/images/blog/rust/rust-closure.jpg" alt="Rust的三种闭包类型"></p><blockquote><p>图片来源于<a href="https://zhuanlan.zhihu.com/p/64417628" target="_blank" rel="noopener">知乎-Rust编程专栏</a></p></blockquote><h3 id="FnOnce"><a href="#FnOnce" class="headerlink" title="FnOnce"></a><code>FnOnce</code></h3><h4 id="标准库定义"><a href="#标准库定义" class="headerlink" title="标准库定义"></a>标准库定义</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[lang = <span class="meta-string">"fn_once"</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">FnOnce</span></span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call_once</span></span>(<span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数类型是<code>self</code>，所以，这种类型的闭包会获取变量的所有权，生命周期只能是当前作用域，之后就会被释放了。</p><h4 id="FnOnce例子："><a href="#FnOnce例子：" class="headerlink" title="FnOnce例子："></a><code>FnOnce</code>例子：</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> E &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"destroyed struct E"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fn_once</span></span>&lt;F&gt;(func: F) <span class="keyword">where</span> F: <span class="built_in">FnOnce</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"fn_once begins"</span>);</span><br><span class="line">    func();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"fn_once ended"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> e = E &#123; a: <span class="string">"fn_once"</span>.to_string() &#125;;</span><br><span class="line">    <span class="comment">// 这样加个move，看看程序执行输出顺序有什么不同</span></span><br><span class="line">    <span class="comment">// let f = move || println!("fn once calls: &#123;:?&#125;", e);</span></span><br><span class="line">    <span class="keyword">let</span> f = || <span class="built_in">println!</span>(<span class="string">"fn once closure calls: &#123;:?&#125;"</span>, e);</span><br><span class="line">    fn_once(f);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"main ended"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">fn_once begins</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">once</span> <span class="title">closure</span> <span class="title">calls</span>: <span class="title">E</span> &#123; <span class="title">a</span>: "<span class="title">fn_once</span>" &#125;</span></span><br><span class="line"><span class="function"><span class="title">fn_once</span> <span class="title">ended</span></span></span><br><span class="line"><span class="function"><span class="title">main</span> <span class="title">ended</span></span></span><br><span class="line"><span class="function"><span class="title">destroyed</span> <span class="title">struct</span> <span class="title">E</span></span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23%5Bderive(Debug)%5D%0Astruct%20E%20%7B%0A%20%20%20%20a:%20String,%0A%7D%0A%0Aimpl%20Drop%20for%20E%20%7B%0A%20%20%20%20fn%20drop(&mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22destroyed%20struct%20E%22);%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20fn_once%3CF%3E(func:%20F)%20where%20F:%20FnOnce()%20%7B%0A%20%20%20%20println!(%22fn_once%20begins%22);%0A%20%20%20%20func();%0A%20%20%20%20println!(%22fn_once%20ended%22);%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20e%20=%20E%20%7B%20a:%20%22fn_once%22.to_string()%20%7D;%0A%20%20%20%20//%20%E8%BF%99%E6%A0%B7%E5%8A%A0%E4%B8%AAmove%EF%BC%8C%E7%9C%8B%E7%9C%8B%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A1%BA%E5%BA%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%0A%20%20%20%20//%20let%20f%20=%20move%20%7C%7C%20println!(%22fn%20once%20calls:%20%7B:?%7D%22,%20e);%0A%20%20%20%20let%20f%20=%20%7C%7C%20println!(%22fn%20once%20closure%20calls:%20%7B:?%7D%22,%20e);%0A%20%20%20%20fn_once(f);%0A%20%20%20%20println!(%22main%20ended%22);%0A%7D" target="_blank" rel="noopener">FnOnce类型闭包-Rust playground例子</a></p></blockquote><p>但是如果闭包运行两次，比如:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fn_once</span></span>&lt;F&gt;(func: F) <span class="keyword">where</span> F: <span class="built_in">FnOnce</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"fn_once begins"</span>);</span><br><span class="line">    func();</span><br><span class="line">    func();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"fn_once ended"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则编译器就报错了，类似这样：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">error[E0382]: <span class="keyword">use</span> of moved value: `func`</span><br><span class="line">  --&gt; src/main.rs:<span class="number">15</span>:<span class="number">5</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">12</span> | <span class="function"><span class="keyword">fn</span> <span class="title">fn_once</span></span>&lt;F&gt;(func: F) <span class="keyword">where</span> F: <span class="built_in">FnOnce</span>() &#123;</span><br><span class="line">   |            -  ---- move occurs because `func` has type `F`, which does not implement the `Copy` trait</span><br><span class="line">   |            |</span><br><span class="line">   |            consider adding a `<span class="built_in">Copy</span>` constraint to this <span class="class"><span class="keyword">type</span> <span class="title">argument</span></span></span><br><span class="line"><span class="number">13</span> |     <span class="built_in">println!</span>(<span class="string">"fn_once begins"</span>);</span><br><span class="line"><span class="number">14</span> |     func();</span><br><span class="line">   |     ---- value moved here</span><br><span class="line"><span class="number">15</span> |     func();</span><br><span class="line">   |     ^^^^ value used here after <span class="keyword">move</span></span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23%5Bderive(Debug)%5D%0Astruct%20E%20%7B%0A%20%20%20%20a:%20String,%0A%7D%0A%0Aimpl%20Drop%20for%20E%20%7B%0A%20%20%20%20fn%20drop(&mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22destroyed%20struct%20E%22);%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20fn_once%3CF%3E(func:%20F)%20where%20F:%20FnOnce()%20%7B%0A%20%20%20%20println!(%22fn_once%20begins%22);%0A%20%20%20%20func();%0A%20%20%20%20func();%0A%20%20%20%20println!(%22fn_once%20ended%22);%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20e%20=%20E%20%7B%20a:%20%22fn_once%22.to_string()%20%7D;%0A%20%20%20%20//%20%E8%BF%99%E6%A0%B7%E5%8A%A0%E4%B8%AAmove%EF%BC%8C%E7%9C%8B%E7%9C%8B%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A1%BA%E5%BA%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%0A%20%20%20%20//%20let%20f%20=%20move%20%7C%7C%20println!(%22fn%20once%20calls:%20%7B:?%7D%22,%20e);%0A%20%20%20%20let%20f%20=%20%7C%7C%20println!(%22fn%20once%20closure%20calls:%20%7B:?%7D%22,%20e);%0A%20%20%20%20fn_once(f);%0A%20%20%20%20println!(%22main%20ended%22);%0A%7D" target="_blank" rel="noopener">FnOnce类型闭包错误-Rust playgroound例子</a></p></blockquote><p>这是为什么呢？</p><p>还是回到<code>FnOnce</code>的定义，参数类型是<code>self</code>，所以在<code>func</code>第一次执行完之后，之前捕获的变量已经被释放了，所以已经无法在执行第二次了。所以，如果要运行多次，可以使用<code>FnMut\Fn</code>。</p><h3 id="FnMut"><a href="#FnMut" class="headerlink" title="FnMut"></a><code>FnMut</code></h3><h4 id="标准库定义-1"><a href="#标准库定义-1" class="headerlink" title="标准库定义"></a>标准库定义</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[lang = <span class="meta-string">"fn_mut"</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">FnMut</span></span>&lt;Args&gt;: <span class="built_in">FnOnce</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数类型是<code>&amp;mut self</code>，所以，这种类型的闭包是可变借用，会改变变量，但不会释放该变量。所以可以运行多次。</p><h4 id="FnMut例子"><a href="#FnMut例子" class="headerlink" title="FnMut例子"></a><code>FnMut</code>例子</h4><p>和上面的例子差不多，有两个地方要改下:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fn_mut</span></span>&lt;F&gt;(<span class="keyword">mut</span> func: F) <span class="keyword">where</span> F: <span class="built_in">FnMut</span>() &#123;</span><br><span class="line">    func();</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> e = E &#123; a: <span class="string">"fn_once"</span>.to_string() &#125;;</span><br><span class="line"><span class="keyword">let</span> f = || &#123; <span class="built_in">println!</span>(<span class="string">"FnMut closure calls: &#123;:?&#125;"</span>, e); e.a = <span class="string">"fn_mut"</span>.to_string(); &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">fn_mut begins</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">mut</span> <span class="title">closure</span> <span class="title">calls</span>: <span class="title">E</span> &#123; <span class="title">a</span>: "<span class="title">fn_mut</span>" &#125;</span></span><br><span class="line"><span class="function"><span class="title">fn</span> <span class="title">mut</span> <span class="title">closure</span> <span class="title">calls</span>: <span class="title">E</span> &#123; <span class="title">a</span>: "<span class="title">fn_mut</span>" &#125;</span></span><br><span class="line"><span class="function"><span class="title">fn_mut</span> <span class="title">ended</span></span></span><br><span class="line"><span class="function"><span class="title">main</span> <span class="title">ended</span></span></span><br><span class="line"><span class="function"><span class="title">destroyed</span> <span class="title">struct</span> <span class="title">E</span></span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23%5Bderive(Debug)%5D%0Astruct%20E%20%7B%0A%20%20%20%20a:%20String,%0A%7D%0A%0Aimpl%20Drop%20for%20E%20%7B%0A%20%20%20%20fn%20drop(&mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22destroyed%20struct%20E%22);%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20fn_mut%3CF%3E(mut%20func:%20F)%20where%20F:%20FnMut()%20%7B%0A%20%20%20%20println!(%22fn_mut%20begins%22);%0A%20%20%20%20func();%0A%20%20%20%20func();%0A%20%20%20%20println!(%22fn_mut%20ended%22);%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20e%20=%20E%20%7B%20a:%20%22fn_mut%22.to_string()%20%7D;%0A%20%20%20%20let%20f%20=%20%7C%7C%20println!(%22fn%20mut%20closure%20calls:%20%7B:?%7D%22,%20e);%0A%20%20%20%20fn_mut(f);%0A%20%20%20%20println!(%22main%20ended%22);%0A%7D" target="_blank" rel="noopener">FnMut类型闭包-Rust playground例子</a></p></blockquote><p>可以看出<code>FnMut</code>类型的闭包是可以运行多次的，且可以修改捕获变量的值。</p><h3 id="Fn"><a href="#Fn" class="headerlink" title="Fn"></a>Fn</h3><h4 id="标准库定义-2"><a href="#标准库定义-2" class="headerlink" title="标准库定义"></a>标准库定义</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[lang = <span class="meta-string">"fn"</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Fn</span></span>&lt;Args&gt;: <span class="built_in">FnMut</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数类型是<code>&amp;self</code>，所以，这种类型的闭包是不可变借用，不会改变变量，也不会释放该变量。所以可以运行多次。</p><h4 id="Fn例子"><a href="#Fn例子" class="headerlink" title="Fn例子"></a><code>Fn</code>例子</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fn_immut</span></span>&lt;F&gt;(func: F) <span class="keyword">where</span> F: <span class="built_in">Fn</span>() &#123;</span><br><span class="line">    func();</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> e = E &#123; a: <span class="string">"fn"</span>.to_string() &#125;;</span><br><span class="line"><span class="keyword">let</span> f = || &#123; <span class="built_in">println!</span>(<span class="string">"Fn closure calls: &#123;:?&#125;"</span>, e); &#125;;</span><br><span class="line">fn_immut(f);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">fn_imut begins</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">closure</span> <span class="title">calls</span>: <span class="title">E</span> &#123; <span class="title">a</span>: "<span class="title">fn</span>" &#125;</span></span><br><span class="line"><span class="function"><span class="title">fn</span> <span class="title">closure</span> <span class="title">calls</span>: <span class="title">E</span> &#123; <span class="title">a</span>: "<span class="title">fn</span>" &#125;</span></span><br><span class="line"><span class="function"><span class="title">fn_imut</span> <span class="title">ended</span></span></span><br><span class="line"><span class="function"><span class="title">main</span> <span class="title">ended</span></span></span><br><span class="line"><span class="function"><span class="title">destroyed</span> <span class="title">struct</span> <span class="title">E</span></span></span><br></pre></td></tr></table></figure><p>可以看出<code>Fn</code>类型的闭包是可以运行多次的，但不可以修改捕获变量的值。</p><blockquote><p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23%5Bderive(Debug)%5D%0Astruct%20E%20%7B%0A%20%20%20%20a:%20String,%0A%7D%0A%0Aimpl%20Drop%20for%20E%20%7B%0A%20%20%20%20fn%20drop(&mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22destroyed%20struct%20E%22);%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20fn_imut%3CF%3E(func:%20F)%20where%20F:%20Fn()%20%7B%0A%20%20%20%20println!(%22fn_imut%20begins%22);%0A%20%20%20%20func();%0A%20%20%20%20func();%0A%20%20%20%20println!(%22fn_imut%20ended%22);%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20e%20=%20E%20%7B%20a:%20%22fn%22.to_string()%20%7D;%0A%20%20%20%20let%20f%20=%20%7C%7C%20println!(%22Fn%20closure%20calls:%20%7B:?%7D%22,%20e);%0A%20%20%20%20fn_imut(f);%0A%20%20%20%20println!(%22main%20ended%22);%0A%7D" target="_blank" rel="noopener">Fn类型闭包-Rust playground例子</a></p></blockquote><h2 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h2><p>有时候在使用<code>Fn/FnMut</code>这里类型的闭包，编译器经常会给出这样的错误:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line">cannot <span class="keyword">move</span> out of captured variable <span class="keyword">in</span> an <span class="built_in">Fn</span>(<span class="built_in">FnMut</span>) closure</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>看下如何复现这种情形:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fn_immut</span></span>&lt;F&gt;(f: F) <span class="keyword">where</span> F: <span class="built_in">Fn</span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"calling Fn closure from fn, &#123;&#125;"</span>, f());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"Fn"</span>.to_string();</span><br><span class="line">    fn_immut(|| a); <span class="comment">// 闭包返回一个字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写就会出现上面的那种错误。但如何修复呢？</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">fn_immut(|| a.clone());</span><br></pre></td></tr></table></figure><p>但原因是什么呢？</p><p>只要稍稍改下上面的代码，运行一次，编译器给出的错误就很明显了:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fn_immut</span></span>&lt;F&gt;(f: F) <span class="keyword">where</span> F: <span class="built_in">Fn</span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"calling Fn closure from fn, &#123;&#125;"</span>, f());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"Fn"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> f = || a;</span><br><span class="line">    fn_immut(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器给出的错误如下:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> |     <span class="keyword">let</span> f = <span class="keyword">move</span> || a;</span><br><span class="line">  |             ^^^^^^^^-</span><br><span class="line">  |             |       |</span><br><span class="line">  |             |       closure is `<span class="built_in">FnOnce</span>` because it moves the variable `a` out of its environment</span><br><span class="line">  |             this closure implements `<span class="built_in">FnOnce</span>`, not `<span class="built_in">Fn</span>`</span><br><span class="line"><span class="number">8</span> |     fn_immut(f);</span><br><span class="line">  |     -------- the requirement to implement `<span class="built_in">Fn</span>` derives from here</span><br></pre></td></tr></table></figure><p>看到没，编译器推导出这个闭包是<code>FnOnce</code>类型的，因为闭包最后返回了<code>a</code>，交还了所有权，是不能再运行第二次了，因为闭包不再是<code>a</code>的所有者。</p><p>而<code>Fn/FnMut</code>是被认定可以多次运行的，如果交还了捕获变量的所有权，则下次就不能运行了，所以会报出前面那个错误。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>因为闭包和<code>rust</code>里的生命周期，所有权紧紧联系在一起了，有时候不怎么好理解，但多写写代码，多试几次，大概就能明白这三者之间的区别。</p><p>总之，闭包是<code>rust</code>里非常好用的功能，能让代码变得简洁优雅，是值得去学习和掌握的！</p>]]></content>
      
      
      <categories>
          
          <category> Rust入坑之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust入坑之旅 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> Rust </tag>
            
            <tag> Closure </tag>
            
            <tag> Fn </tag>
            
            <tag> FnOne </tag>
            
            <tag> FnMut </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust模块机制</title>
      <link href="2019/10/28/rust-mod/"/>
      <url>2019/10/28/rust-mod/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/rust/rust-language.jpg" alt="rust-language"></p><p>刚开始学习<code>Rust</code>时，我觉得它的模块机制难以理解。后来才明白是自己想多了，<code>Rust</code>模块其实就是命名空间，仅此而已。它的<code>crate</code>倒更像是其他语言的模块。</p><a id="more"></a><h2 id="从Rust编译来理解"><a href="#从Rust编译来理解" class="headerlink" title="从Rust编译来理解"></a>从Rust编译来理解</h2><p><code>Rust</code>编译器只接受一个<code>.rs</code>文件作为输入，并且只生成一个<code>crate</code>。这一点要牢记。</p><p>生成的<code>crate</code>分两种，源文件中有<code>main</code>函数会生成可执行文件，无<code>main</code>函数则生成库。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.rs</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"hello, rust"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>rustc hello.rs</code>会生成同名的可执行文件<code>hello</code></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"hello, rust"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>--crate-type=lib</code>参数编译成库，如果没有<code>pub</code>关键字，则会有如下提示。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ rustc hello.rs --crate-type=lib</span><br><span class="line">warning: function is never used: `hello`</span><br><span class="line"> --&gt; hello.rs:<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">1</span> | <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>()&#123;</span><br><span class="line">  | ^^^^^^^^^^</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="meta">#[warn(dead_code)]</span>` on by default</span><br></pre></td></tr></table></figure><p>运行<code>rustc hello.rs --crate-type=lib</code>会生成同名的库<code>libhello.rlib</code>。函数前面多了一个关键词<code>pub</code>，如果不加的话编译器会告警，说“你这个库啥<code>public</code>的东西都没有，让别人用毛啊”。恩，<code>Rust</code>编译器还是很贴心的。</p><h2 id="引入命名空间"><a href="#引入命名空间" class="headerlink" title="引入命名空间"></a>引入命名空间</h2><p><code>Rust</code>的模块就是命名空间，用关键词<code>mod</code>表示。它的作用是把一个<code>crate</code>的代码划分成可管理的部分。每一个<code>crate</code>都有一个顶层的匿名根命名空间, 根空间下面的命名空间可以任意嵌套，这样构成一个树形结构。</p><p>假设我们接到一个项目，制作一个包含各国语言日常用语的程序库。</p><ul><li>首先，这个库应该按语种名组织，中俄日美等都给他们划分出一个模块</li><li>日常用语有很多，如果我们想把代码组织得更清晰一点，还可以按照使用场景再划分一次，比如有用于问候的（“你好”、“吃了么”），有用于离别的（“再见”，“天下谁人不识君”）</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// phrases.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> english &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> greetings &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Hello!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">hey_guies</span></span>() &#123;</span><br><span class="line">           <span class="built_in">println!</span>(<span class="string">"Hey, guies!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> farewells &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">goodbye</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Goodbye!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">see_you</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"See you!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> chinese &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> greetings &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"你好!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">have_eaten</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"吃了么?"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> farewells &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">goodbye</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"再见!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">everyone_will_know_you</span></span>() &#123;</span><br><span class="line">            println(<span class="string">"天下谁人不识君!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>rustc phrases.rs --crate-type=lib</code>得到一个程序库，其模块树形图如下:</p><p><img src="/images/blog/rust/rust-mod-tree.png" alt="模块图像树"></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 朋友分别，请用下面两句</span></span><br><span class="line">phrases::chinese::farewells::goodbye()</span><br><span class="line">phrases::chinese::farewells::everyone_will_know_you()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不想敲这么多重复的命名空间，请用use</span></span><br><span class="line"><span class="keyword">use</span> phrases::chinese::farewells;</span><br><span class="line"></span><br><span class="line">farewells::goodbye();</span><br><span class="line">farewells::everyone_will_know_you();</span><br></pre></td></tr></table></figure><h2 id="打散命名空间"><a href="#打散命名空间" class="headerlink" title="打散命名空间"></a>打散命名空间</h2><p>好，我们已经学会使用命名空间了，但是所有的代码都在<code>phrases.rs</code>这个文件中，这在正式开发中是不能容忍的。还好<code>Rust</code>编译器给我提供了一个将单个文件拆成多个文件的机制。</p><p>我们把<code>phrases.rs</code>改成如下，编译器每次看到未定义的<code>mod</code>语句时会去找相应地文件，填充到这个位置。我们可以理解为，编译器把若干个文件合并成一个文件。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// phrases.rs</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// whole project file hierarchy as following</span></span><br><span class="line"><span class="comment">//  project-director/</span></span><br><span class="line"><span class="comment">//    |-- phrases.rs</span></span><br><span class="line"><span class="comment">//    |-- english/</span></span><br><span class="line"><span class="comment">//          |-- mod.rs</span></span><br><span class="line"><span class="comment">//          |-- greetings.rs</span></span><br><span class="line"><span class="comment">//          |-- farewells.rs</span></span><br><span class="line"><span class="comment">//    |-- chinese/</span></span><br><span class="line"><span class="comment">//          |-- mod.rs</span></span><br><span class="line"><span class="comment">//          |-- greetings.rs</span></span><br><span class="line"><span class="comment">//          |-- farewells.rs</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> english;    <span class="comment">// 查找当前目录下的english.rs或者english目录下的mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> chinese;    <span class="comment">// 查找当前目录下的chinese.rs或者chinese目录下的mod.rs</span></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// english/mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> greetings;  <span class="comment">// 查找当前目录下的greetings.rs或者greetings目录下的mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> farewells;  <span class="comment">// 查找当前目录下的farewells.rs或者farewells目录下的mod.rs</span></span><br><span class="line"><span class="comment">// english/greetings.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">hey_guies</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hey, guies!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// english/farewells.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">goodbye</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Goodbye!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">see_you</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"See you!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>chinese</code>模块我就不写了，类比<code>english</code>模块。</p></blockquote><h2 id="提升命名空间"><a href="#提升命名空间" class="headerlink" title="提升命名空间"></a>提升命名空间</h2><p>编译器的机制决定，除了<code>mod.rs</code>外，每一个文件和目录都是一个模块。有时候我们只是想分拆文件，但是不想添加新的模块。<strong>编译器像个暴君一样，说：“在我的国家，不允许干这样的事儿。”</strong></p><p>不过也不是没有变通的机制，<code>pub use</code>就是惯用手法。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// english/mod.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::greetings::hello;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::greetings::hey_guies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> greetings;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> farewells;</span><br></pre></td></tr></table></figure><p><code>english</code>模块添加了两个<code>pub use</code>语句后，两个问候函数就提升到<code>english</code>空间中去了，我们可以用<code>phrases::english::hello()</code>来代替<code>phrases::english::greetings::hello()</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>Rust Module</code>就是命名空间，没别的意思</li><li><code>Rust</code>编译器只接受一个源文件，输出一个<code>crate</code></li><li>每一个<code>crate</code>都有一个匿名的根命名空间，命名空间可以无限嵌套</li><li>“<code>mod mod-name { ... }</code>“ 将大括号中的代码置于命名空间<code>mod-name</code>之下</li><li>“<code>use mod-name1::mod-name2;&quot;</code> 可以打开命名空间，减少无休止的<code>::</code>操作符</li><li>“<code>mod mod-name;</code>“ 可以指导编译器将多个文件组装成一个文件</li><li>“<code>pub use mod-nam1::mod-name2::item-name;</code>“ 语句可以将<code>mod-name2</code>下的<code>item-name</code>提升到这条语句所在的空间，<code>item-name</code>通常是函数或者结构体。<code>Rust</code>社区通常用这个方法来缩短库<code>API</code>的命名空间深度</li><li>编译器规定<code>use</code>语句一定要在<code>mod</code>语句之前</li></ol>]]></content>
      
      
      <categories>
          
          <category> Rust入坑之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust入坑之旅 </tag>
            
            <tag> Rust </tag>
            
            <tag> Module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyenv介绍</title>
      <link href="2018/02/27/pyenv/"/>
      <url>2018/02/27/pyenv/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/python-2-vs-python-3.jpg" alt="python 2 vs python 3"></p><p>去年 11 月，<a href="http://www.numpy.org/" target="_blank" rel="noopener">Numpy</a>团队的一份声明引发了<code>Python</code>社区的关注：这一科学计算库即将放弃对于 <code>Python 2.7</code> 的支持，全面转向<code>Python 3</code>。</p><blockquote><p>声明原文<a href="https://github.com/numpy/numpy/blob/master/doc/neps/dropping-python2.7-proposal.rst" target="_blank" rel="noopener">Plan for dropping Python 2.7 support</a></p></blockquote><a id="more"></a><p>不过，还是有很多<code>Python</code>的项目依然还是使用<code>2.7</code>的版本来进行开发和维护。尤其是我这种喜欢折腾新东西的人来说，一门语言同时在一个系统中存在多个版本是一个非常正常的事情。也经常有同学来问我<code>Python</code>不同版本之间兼容和切换的问题。</p><p>今天给大家推荐一下<code>Python</code>环境管理的工具，简单整理一下<code>pyenv</code>相关的介绍和使用。</p><p><code>pyenv</code>是一个非常好用的<code>Python</code>环境管理工具。</p><p>有这些主要特性：</p><ol><li>方便的安装、管理不同版本的<code>Python</code>，而且不需要<code>sudo</code>权限，不会污染系统的<code>Python</code>版本</li><li>可以修改当前用户使用的默认<code>Python</code>版本</li><li>集成<code>virtualenv</code>，自动安装、激活</li><li>命令行自动补全</li></ol><p>详细内容见 <a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">Github - pyenv/pyenv</a>.</p><h1 id="安装pyenv"><a href="#安装pyenv" class="headerlink" title="安装pyenv"></a>安装pyenv</h1><p>使用<a href="https://github.com/pyenv/pyenv-installer" target="_blank" rel="noopener">pyenv-installer</a></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">curl -L https://raw.githubusercontent.com/pyenv/pyenv-installer/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure><p>然后在<code>~/.bashrc</code>或<code>~/.zshrc</code>中添加如下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">"~/.pyenv/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv init -)</span>"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv virtualenv-init -)</span>"</span></span><br></pre></td></tr></table></figure><p><code>macOS</code>用户可以直接使用<code>brew</code>这个包管理系统直接安装<code>pyenv</code>，直接完成上述两步操作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>完整的命令行列表可以参考<a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md" target="_blank" rel="noopener">pyenv/COMMANDS.md</a>.</p><h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装<code>Python</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv install 3.6.1</span><br></pre></td></tr></table></figure><p>这个命令会为当前用户下载和安装<code>Python 3.6.1</code>。</p><h2 id="新建虚拟环境"><a href="#新建虚拟环境" class="headerlink" title="新建虚拟环境"></a>新建虚拟环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 3.6.1 py36</span><br></pre></td></tr></table></figure><p>设置当前路径使用的 Python 环境</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> py36</span><br></pre></td></tr></table></figure><p>这个命令会在当前路径创建一个<code>.python-version</code>文件，文件内容就是 <code>py36</code>，即环境名称。所以一般需要把<code>.python-version</code>添加到 <code>.gitignore</code>.</p><p>下次进入该目录时，会自动激活虚拟环境，离开后自动退出。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ol><li><a href="https://www.jiqizhixin.com/articles/2018-01-29-3" target="_blank" rel="noopener">在Python 2.7即将停止支持时，我们为你准备了一份3.x迁移指南</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pyenv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理想的创业团队原型和创建产品原则</title>
      <link href="2018/02/13/the-two-laws-of-building-products/"/>
      <url>2018/02/13/the-two-laws-of-building-products/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文谈了创建产品的原则和理想的创业团队应具备的各种技能</p></blockquote><ol><li>如果你不能销售它，不要建立它</li><li>如果你不能建立它，不要销售它</li></ol><p><a href="http://disciplinedentrepreneurship.com/" target="_blank" rel="noopener">麻省理工学院的Bill Aulet说</a> ，企业的唯一必要和充分条件是付费客户。 但这并不是一个好的业务的充分条件;相反，我们需要使用<code>IDEO</code>的<code>Tim Brown</code>提出的“<a href="https://www.ideou.com/pages/design-thinking" target="_blank" rel="noopener">设计思维</a>”方法作为指南，找到客户需求的最佳选择，在技术上可行，在商业上可行。 然后我们需要卖掉它，继续卖它，再卖一些（重要的话说三遍）。</p><p><img src="/images/blog/two-laws-of-building-products/design-thinking.png" alt="design-thinking"></p><a id="more"></a><blockquote><p>免责声明 : economic viability should be measured in your preferred currency. The value of your investments can go up as well as down. Bitcoin for illustration only.</p></blockquote><p>发现这个神奇的地方（上图中重合的🚀区域）需要太多的韧性和运气或者纪律和严谨性。许多成功的企业都是通过不断的尝试和失败而进入他们的产品/市场的，这也是为什么初创公司和小型企业的失败率如此之高的原因之一。</p><p>新企业和新产品需要从高不确定性迅速发展到尽可能快的程度(以及最小的投资)。为了加快寻找理想、可行和可行的解决方案的过程，你需要一个团队。</p><p>原文： <a href="https://medium.com/swlh/the-two-laws-of-building-products-74880772c678" target="_blank" rel="noopener">The two laws of building products</a></p><h2 id="三是神奇的数字。-四和五也很好。"><a href="#三是神奇的数字。-四和五也很好。" class="headerlink" title="三是神奇的数字。 四和五也很好。"></a>三是神奇的数字。 四和五也很好。</h2><p>遇到一个能有效挑战你的解决方案的三个方面的人的机会是微乎其微的，而且很少能找到一个能做到这一点的创业团队。当你找到这些团队的时候，这是商业成功的火箭燃料。</p><p>以我的经验来看，创业团队往往是由机遇而非精心设计的。联合创始人已经在社会上或以前的工作中相互了解，或者在他们感兴趣的事情上相识。这些偶然的会议和共同的兴趣倾向于喜欢相似的个性和技能集——产品的拥有者在产品事件中相遇，Ruby开发者在Ruby聚会上见面。因此，我们经常发现缺少必要的多样性的创业团队通过产品的三个视角来工作。相反，这是一种痛苦的经历，是一种烧钱的方式，让他们知道他们需要了解自己缺失的学科。</p><h2 id="启动原型"><a href="#启动原型" class="headerlink" title="启动原型"></a>启动原型</h2><p>几年前，在我与初创公司合作之前，我曾经历过很多次黑客日。多年来，我们尝试了不同的方法来提出想法和组建团队。我们发现了同样的自我强化困境;技术人员会寻找其他技术人员，建立技术原型，市场营销人员会寻找其他的市场营销人员，并建立令人惊叹的产品推介。这些都是令人惊奇但不平衡的作品进入了黑客日的评判。</p><p>因此，为了迫使不同的团队，我们要求人们按照原型来安排自己，并要求不同的团队使用不同的技能。</p><p><img src="/images/blog/two-laws-of-building-products/startup-archetypes.png" alt="the startup archetypes"></p><p>每个参加黑客日的人都得到了对原型的描述，并要求自己选择一个主要的和次要的类别。 然后，当团队成立时，我们问他们避免拥有多个相同的原型。</p><p>最终结果？ 我们有史以来最成功的黑客日，创造了两家新企业，它们都进入了我们的内部孵化器。</p><h2 id="原型如何映射到三个视角"><a href="#原型如何映射到三个视角" class="headerlink" title="原型如何映射到三个视角?"></a>原型如何映射到三个视角?</h2><p>任何在一段时间内从事商业活动的人都会遇到这类的销售主管，他们会为了达成协议而高兴地销售不存在的功能，而开发人员为了解决他们销售不存在的功能而苦逼的编码。</p><p>创建我们的原型的原因是为了在团队中创造一种平衡以及挑战和妥协的健康张力——我们希望开发团队挑战销售人员考虑他们所承诺的可行性,销售高管鼓励技术人员对速度完美市场交易。</p><p>我们最初使用的原型来自于对成功的创始人团队的即兴研究。我从我认识的团队中吸取了经验，并从其他创始人那里得到了一个长时间的交流，他们提出了他们的理想团队的原型。</p><p>这是一种尝试、错误和猜测，但我们发现了一个重要的实现——跨职能团队超越了亲密朋友的团队，尽管他们是在当下创建的。这个项目的挑战创造了团队合作，但这些技能却让人成功。</p><p>这些技能的重要性在于，它们会在团队成员之间制造紧张关系，从而帮助团队解决三个视角的问题。通过拉动不同的方向，代表不同的学科，团队更能想出更真实、更可爱的解决方案。</p><h2 id="新原型"><a href="#新原型" class="headerlink" title="新原型"></a>新原型</h2><p>在第一次黑客日之后的几年中，我回顾并修改了我推荐的原型。在某种程度上，这直接来自于需要解决这三个方面的问题，同时也认识到新业务的另外两个关键因素。该产品不仅需要是令人满意的、可行的和可持续发展的，而且我们还需要能够长期的销售产品或服务。</p><p><img src="/images/blog/two-laws-of-building-products/new-archetypes.png" alt="the new archetypes"></p><h3 id="梦想家"><a href="#梦想家" class="headerlink" title="梦想家"></a>梦想家</h3><p>伟大的企业是由梦想家开创的。 梦想家为企业树立了未来的愿景，并说服创始人和投资者走上旅程。 梦想家通常是首席客户传道者，他带来了最初的想法，鼓舞了员工和投资者。 梦想家是积极的，有时是不现实的; 他们面临的挑战是，他们往往不接地气，也不行动 - 他们可以把现实炸弹留在身后，而其他人可能需要捡起这些炸弹。</p><p>技能：公开演讲，投资者关系，大局思维，以客户为中心，鼓舞人心。 梦想家让团队，客户和投资者在情感上参与产品和业务。</p><h3 id="黑客"><a href="#黑客" class="headerlink" title="黑客"></a>黑客</h3><p>如果你不能建立它，不要销售它。 黑客的工作是解决现实的问题。 如果梦想家的工作是梦想不可能的事，那么黑客的工作就是让不可能的事情成为可能。</p><p>虽然梦想家可能会一直向前推进，但黑客的任务是踩下梦想家的现实炸弹，找到解决难题的真正方法。 如果你的产品是软件，黑客可能是一个程序员。 如果它是有形的，他们可能是一名工程师。 如果您提供服务，黑客是一位流程设计师。 黑客是商业的手。 然而，黑客有时可能拥有<code>Eeyore</code>一样的品质，看到每一个新想法带来的痛苦，并常常为可能的未来过度设计解决方案。</p><blockquote><p><code>Eeyore</code>是《小熊维尼和蜂蜜树》的角色，一个旧的灰色小毛驴，它悲观、过于冷静、自卑、消沉。</p></blockquote><p>技能：程序员，建筑师，工程师，科学家，木匠。 硬技能会有所不同，但黑客需要知道（或快速学习）构建解决方案所需的一切。</p><h3 id="设计师"><a href="#设计师" class="headerlink" title="设计师"></a>设计师</h3><p>设计师不仅仅是业务的艺术方面，尽管这在某种程度上属于这个角色。设计师提出了一种设计思维的方法和对产品和过程的敏感性，以达到目的和可爱。设计师通常是部分用户体验设计师，部分插画师，但所有的设计思维教练为团队的其他成员。</p><p>技能:设计思考者，海报艺术家，插画师，线框绘制者。设计师擅长于制作您的第一本小册子和您的第一个原型。</p><h3 id="骗子"><a href="#骗子" class="headerlink" title="骗子"></a>骗子</h3><p>没有骗子，你的生意不会成功。 你可能有其他角色的内向者，但是骗子是纯粹的外向型。有了骗子不用再担心接电话和给陌生人打电话，骗子会做好这些事情。虽然在没有产品的情况下有一个销售主管似乎是不必要的，但是Hustler会帮助你决定如何将你的产品推向市场，甚至是如何销售。 在活动和会议上，骗子与梦想家在舞台上争先恐后，但其中只有一个会抓取名片。</p><p>技能：推销，销路拓展，上门推销，销售流程和销售管理。 骗子把你的产品变成金钱，并且会知道销售周期的来龙去脉。</p><h3 id="分析师"><a href="#分析师" class="headerlink" title="分析师"></a>分析师</h3><p>或者，正如我亲切地称他们为“钱”。 分析师喜欢数据。给他们一个市场规模，他们就会运行这些数字。销售预测，现金消耗率，单位经济。分析师将研究你的获取客户成本、生命周期价值和你的财务状况。分析师关心的是如何把数字加起来，并保证没有赤字。</p><p>技能:不一定是会计或经济学家，分析师有可靠的数字头脑。可能来自财务或者是一个量化的角色，比如商业分析或咨询。</p><h2 id="为什么你不能在真空中做出决定。"><a href="#为什么你不能在真空中做出决定。" class="headerlink" title="为什么你不能在真空中做出决定。"></a>为什么你不能在真空中做出决定。</h2><p>团队需要做的比让顾客满意更好。 他们需要考虑在构建产品后的运营成本。 商业模式需要考虑到国际客户的销售成本，或通过搜索驱动的B2C服务中获取客户的渠道，或者运行24小时支持热线的成本。</p><p>大多数市场不再容忍成本加成的模式。 现在，市场设定了价格，您需要交付产品并获得利润。 您的成本不可能仅仅是物料清单，人工和运输。</p><p>所有这些复杂性都会在您的团队中推动创造性的对话。 随着黑客构建着梦想家向客户要求的产品，最好的解决方案是妥协。 跨职能团队允许创始人彼此学习并发展互补技能。</p><h2 id="团队是虚拟的"><a href="#团队是虚拟的" class="headerlink" title="团队是虚拟的"></a>团队是虚拟的</h2><p>尽管表面上看，我并不认为每个产品都需要一个人来代表每一个原型。相反，你需要的是一种技能的平衡，它涵盖了三个方面，每个产品和业务都有不同的需求。</p><p>尽管出现，我不相信每个产品都需要一个人代表每个原型。 相反，您正在寻找涵盖三个视角的技能平衡，并且每个产品和业务都会有不同的需求。</p><p>你的产品是否可取？ 它在技术上可行吗？ 它在商业上可行吗？ 你的团队应该能够回答所有这些问题，而不仅仅是一两个问题。团队的规模不如拥有可用的技能那么重要。</p><p>有可能你会有一个梦想家，他有外向的一面。或许你拥有一个拥有<code>MBA</code>学位的计算机专业毕业生，提供的是与黑客和分析师的能力。也许你的骗子有一个隐藏的艺术方面。重点不是要勾出原型，而是要确保你有能力正确地分析你的业务。</p><p>初创公司和小团队的美妙之处在于人们的角色定位不明确，因此需要在必要时进行投票。 原型只是你的指导，确保你可以考虑所有的角度。请记住，</p><ol><li>如果你不能销售它，不要建立它</li><li>如果你不能建立它，不要销售它</li></ol><blockquote><p>原文 ：<a href="https://medium.com/swlh/the-two-laws-of-building-products-74880772c678" target="_blank" rel="noopener">The two laws of building products</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 创业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创业 </tag>
            
            <tag> 产品 </tag>
            
            <tag> 团队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDN之NETCONF Call Home</title>
      <link href="2017/11/28/netconf-call-home/"/>
      <url>2017/11/28/netconf-call-home/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/netconf-callhome/rfc8071-datatracker-status.jpg" alt="rfc8071 datatracker status"></p><p>本文主要内容都来自于今年二月发布的<a href="https://tools.ietf.org/html/rfc8071" target="_blank" rel="noopener">RFC8071 - NETCONF Call Home and RESTCONF Call Home</a>，该RFC从2015年4月提出到最终发布一共修改了17个版本，其间修改内容可以<a href="https://datatracker.ietf.org/doc/rfc8071/" target="_blank" rel="noopener">点击查看详细内容</a>。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>NETCONF Call Home</code>支持两种安全传输网络配置协议分别是<code>Secure Shell(SSH)</code>和传输层安全<code>(TLS)</code>。  </p><blockquote><p><code>NETCONF</code>协议​​的绑定到<code>SSH</code>在<a href="https://tools.ietf.org/html/rfc6242" target="_blank" rel="noopener">RFC6242</a>中定义。<br><code>NETCONF</code>协议​​的绑定到<code>TLS</code>在<a href="https://tools.ietf.org/html/rfc7589" target="_blank" rel="noopener">RFC7589</a>中定义。<br><code>SSH</code>协议在<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253</a>中定义，<code>TLS</code>协议是在<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC5246</a>中定义。<code>SSH</code>和<code>TLS</code>协议都是<code>TCP</code>协议之上的协议。</p></blockquote><a id="more"></a><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p><code>call home</code>对于网络设备的初始化部署和持续管理都是非常有帮助的。那网络设备为什么使用<code>call home</code>这种方式？</p><ul><li><p>网络设备在第一次启动后可以主动<code>call home</code>，以便在其管理系统上注册。</p></li><li><p>网络设备可以以一种动态分配<code>IP</code>地址的方式访问网络，但是不会将其分配的IP地址注册到映射服务(例如，动态<code>DNS</code>)。</p></li><li><p>网络设备可以部署在实现所有内部网络IP地址的网络地址转换（NAT）的防火墙后面。</p></li><li><p>网络设备元件可以部署在不允许任何管理访问内部网络的防火墙之后。</p></li><li><p>网络设备可以配置为“隐身模式”，因此没有任何的端口可以提供给管理系统打开连接。</p></li><li><p>运营商可能倾向于让网络设备发起管理连接，认为在数据中心中保护一个开放端口比在网络中的每个网络设备上具有开放端口更容易。</p></li></ul><h3 id="解决方案概述"><a href="#解决方案概述" class="headerlink" title="解决方案概述"></a>解决方案概述</h3><p>下图说明了协议分层的<code>call home</code></p><p><img src="/images/blog/netconf-callhome/netconf-call-home-sequence.png" alt="NETCONF Call Home Sequence"></p><blockquote><p>消息层流程PlantUML请查看<a href="https://raw.githubusercontent.com/tonydeng/sdn-handbook/master/puml/netconf-call-home.puml" target="_blank" rel="noopener">netconf-messages-layer-flow.puml</a></p></blockquote><p>这张图有以下几点：</p><ol><li><code>NETCONF</code>服务器首先启动一个<code>TCP</code>连接到<code>NETCONF</code>客户端。</li><li>使用这个<code>TCP</code>连接，<code>NETCONF</code>客户端启动到<code>NETCONF</code>服务器的<code>SSH/TLS</code>会话。</li><li>使用此<code>SSH/TLS</code>会话，<code>NETCONF</code>客户端启动一个到<code>NETCONF</code>服务器的<code>NETCONF</code>会话。</li></ol><h2 id="NETCONF客户端"><a href="#NETCONF客户端" class="headerlink" title="NETCONF客户端"></a>NETCONF客户端</h2><p>术语“客户端”在<a href="https://tools.ietf.org/html/rfc6241#section-1.1" target="_blank" rel="noopener">RFC6241第1.1节</a>中定义。 在网络管理的情况下，<code>NETCONF</code>客户端可能是一个网络管理系统。</p><h3 id="客户端协议操作事项"><a href="#客户端协议操作事项" class="headerlink" title="客户端协议操作事项"></a>客户端协议操作事项</h3><ul><li>C1 <code>NETCONF</code>客户端侦听来自<code>NETCONF</code>服务器的<code>TCP</code>连接请求。 客户端必须支持在<a href="https://tools.ietf.org/html/rfc8071#section-6" target="_blank" rel="noopener">第6节</a>中定义的<code>IANA</code>分配的端口上接受<code>TCP</code>连接，但可以配置为侦听不同的端口。</li><li>C2 <code>NETCONF</code>客户端接受传入的<code>TCP</code>连接请求，并建立<code>TCP</code>连接。</li><li>C3 使用此<code>TCP</code>连接，<code>NETCONF</code>客户端启动<code>SSH</code>客户端<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253</a>或<code>TLS</code>客户端<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246</a>协议。 例如，假定使用<code>IANA分</code>配的端口，则在端口<code>4334</code>接受连接时启动<code>SSH</code>客户端协议，并且在端口<code>4335</code>或端口<code>4336</code>上接受连接时启动<code>TLS</code>客户端协议。</li><li>C4 当使用<code>TLS</code>时，<code>NETCONF</code>客户端必须告知<code>&quot;peer_allowed_to_send&quot;</code>，如<a href="https://tools.ietf.org/html/rfc6520" target="_blank" rel="noopener">RFC6520</a>所定义。 这是必需的，以便<code>NETCONF</code>服务器知道在<code>call home</code>连接时需要发送心跳包，保持长连接。</li><li>C5 作为建立<code>SSH</code>或<code>TLS</code>连接的一部分，<code>NETCONF</code>客户端必须验证服务器提供的主机密钥或证书。 该验证可以通过证书路径验证或通过将主机密钥或证书与先前信任的或“固定的”值进行比较来完成。 如果证书被提交并且包含撤销检查信息，<code>NETCONF</code>客户端应该检查证书的撤销状态。 如果确定证书已被吊销，客户端必须马上关闭连接。</li><li>C6 如果使用证书路径验证，则<code>NETCONF</code>客户端必须确保提供的证书具有对预先配置的颁发者证书的有效信任链，并且所呈现的证书对客户端之前知道的“标识符”<a href="https://tools.ietf.org/html/rfc6125" target="_blank" rel="noopener">RFC6125</a>进行编码 连接尝试。 如何在证书中编码标识符可以由与证书颁发者相关的策略来确定。 例如，可以知道给定的颁发者只在<code>X.509</code>证书的<code>“CommonName”</code>字段中签署具有唯一标识符（例如，序列号）的<code>IDevID</code>证书<a href="https://tools.ietf.org/html/rfc8071#ref-Std-802.1AR-2009" target="_blank" rel="noopener">Std-802.1AR-2009</a>。</li><li>C7 服务器的主机密钥或证书经过验证后，客户端将以<code>SSH</code>或<code>TLS</code>协议进行建立<code>SSH</code>或<code>TLS</code>连接。 在使用<code>NETCONF</code> 服务器执行客户端认证时，<code>NETCONF</code>客户端必须仅使用先前为<code>NETCONF</code>服务器提供的主机密钥或服务器证书关联的凭证。</li><li>C8 一旦<code>SSH</code>或<code>TLS</code>连接建立，<code>NETCONF</code>客户端启动<code>NETCONF</code>客户端<a href="https://tools.ietf.org/html/rfc6241" target="_blank" rel="noopener">RFC6241</a>或<code>RESTCONF</code>客户端<a href="https://tools.ietf.org/html/rfc8040" target="_blank" rel="noopener">RFC8040</a>协议。 假设使用<code>IANA</code>分配的端口，当在端口<code>4334</code>或端口<code>4335</code>上接受连接时启动<code>NETCONF</code>客户端协议，并且当在端口<code>4336</code>上接受连接时启动<code>RESTCONF</code>客户端协议。</li></ul><h3 id="客户端配置数据模型"><a href="#客户端配置数据模型" class="headerlink" title="客户端配置数据模型"></a>客户端配置数据模型</h3><p>如何配置<code>NETCONF</code>或<code>RESTCONF</code>客户端超出了本文的范围。</p><p>例如，可以使用什么样的配置来启用对<code>call home</code>的监听，配置可信证书颁发者，或者为预期的连接配置标识符。 也就是说，在<a href="https://tools.ietf.org/html/rfc8071#ref-NETCONF-MODELS" target="_blank" rel="noopener">NETCONF-MODELS</a>和<a href="https://tools.ietf.org/html/rfc8071#ref-RESTCONF-MODELS" target="_blank" rel="noopener">RESTCONF-MODELS</a>中提供了用于配置<code>NETCONF</code>和<code>RESTCONF</code>客户端的<code>YANG</code> <a href="https://tools.ietf.org/html/rfc7950" target="_blank" rel="noopener">RFC7950</a>数据模块，包括<code>call home</code>。</p><h2 id="NETCONF服务器"><a href="#NETCONF服务器" class="headerlink" title="NETCONF服务器"></a>NETCONF服务器</h2><p>术语“服务器”在<a href="https://tools.ietf.org/html/rfc6241#section-1.1" target="_blank" rel="noopener">RFC6241第1.1节</a>中定义。 在网络管理的情况下，<code>NETCONF</code>服务器可能是网络元件或设备。</p><h3 id="服务器协议操作"><a href="#服务器协议操作" class="headerlink" title="服务器协议操作"></a>服务器协议操作</h3><ul><li>S1 <code>NETCONF</code>服务器向<code>NETCONF</code>客户端发起<code>TCP</code>连接请求。 源端口可以根据本地策略或由操作系统随机分配。 服务器必须支持连接到<a href="https://tools.ietf.org/html/rfc8071#section-6" target="_blank" rel="noopener">第6节</a>中定义的一个<code>IANA</code>分配的端口，但可以配置为连接到不同的端口。 使用<code>IANA</code>分配的端口，服务器通过<code>SSH</code>连接到<code>NETCONF</code>的端口<code>4334</code>，通过<code>TLS</code>连接到<code>NETCONF</code>的端口<code>4335</code>和通过<code>TLS</code>的<code>RESTCONF</code>的端口<code>4336</code>。</li><li>S2 <code>TCP</code>连接请求被接受，<code>TCP</code>连接被建立。</li><li>S3 使用此<code>TCP</code>连接，<code>NETCONF</code>服务器将启动<code>SSH</code>服务器<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253</a>或<code>TLS</code>服务器<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246</a>协议，具体取决于它如何配置。 例如，假定使用<code>IANA</code>分配的端口，则在连接到远程端口<code>4334</code>之后使用<code>SSH</code>服务器协议，并且在连接到远程端口<code>4335</code>或远程端口<code>4336</code>之后使用<code>TLS</code>服务器协议。</li><li>S4 作为建立<code>SSH</code>或<code>TLS</code>连接的一部分，<code>NETCONF</code>服务器会将其主机密钥或证书发送给客户端。 如果发送了一个证书，服务器还必须发送所有中间证书到一个知名和可信赖的发行者。 如何发送证书列表在<a href="https://tools.ietf.org/html/rfc6187#section-2.1" target="_blank" rel="noopener">RFC6187第2.1节</a>中为<code>SSH</code>定义，在<a href="https://tools.ietf.org/html/rfc5246#section-7.4.2" target="_blank" rel="noopener">RFC5246第7.4.2节</a>中为<code>TLS</code>定义。</li><li>S5 建立<code>SSH</code>或<code>TLS</code>会话需要在所有情况下对客户端证书进行服务器身份验证，但<code>RESTCONF</code>除外，其中一些客户端身份验证方案在<code>安全传输连接（TLS）</code>建立后发生。 如果需要传输级（<code>SSH</code>或<code>TLS</code>）客户端身份验证，并且客户端无法在本地策略定义的时间内成功向服务器进行身份验证，则服务器必须关闭连接。</li><li>S6 一旦建立了<code>SSH</code>或<code>TLS</code>连接，<code>NETCONF</code>/<code>RESTCONF</code>服务器将启动<code>NETCONF</code>服务器<a href="https://tools.ietf.org/html/rfc6241" target="_blank" rel="noopener">RFC6241</a>或<code>RESTCONF</code>服务器<a href="https://tools.ietf.org/html/rfc8040" target="_blank" rel="noopener">RFC8040</a>协议，具体取决于如何配置。 假设使用<code>IANA</code>分配的端口，则在连接到远程端口<code>4334</code>或远程端口<code>4335</code>之后使用<code>NETCONF</code>服务器协议，并且在连接到远程端口<code>4336</code>之后使用<code>RESTCONF</code>服务器协议。</li><li>S7 如果需要长连接，作为连接发起者的<code>NETCONF</code>/<code>RESTCONF</code>服务器应该使用<code>keep-alive</code>机制主动测试连接的活跃性。 对于基于<code>TLS</code>的连接，<code>NETCONF</code>/<code>RESTCONF</code>服务器应该发送<a href="https://tools.ietf.org/html/rfc6520" target="_blank" rel="noopener">RFC6520</a>定义的<code>HeartbeatRequest</code>消息。 对于基于<code>SSH</code>的连接，根据<a href="https://tools.ietf.org/html/rfc4254#section-4" target="_blank" rel="noopener">RFC4254的第4节</a>，服务器应该发送一个<code>SSH_MSG_GLOBAL_REQUEST</code>消息，其中包含一个特别不存在的<code>&quot;request name&quot;</code>值（例如<a href="mailto:&#107;&#x65;&#x65;&#112;&#97;&#x6c;&#105;&#118;&#101;&#x40;&#105;&#101;&#x74;&#102;&#x2e;&#x6f;&#x72;&#103;">&#107;&#x65;&#x65;&#112;&#97;&#x6c;&#105;&#118;&#101;&#x40;&#105;&#101;&#x74;&#102;&#x2e;&#x6f;&#x72;&#103;</a>）和<code>&quot;want reply&quot;</code>值设置为<code>&quot;1&quot;</code>。</li></ul><h3 id="服务器配置数据模型"><a href="#服务器配置数据模型" class="headerlink" title="服务器配置数据模型"></a>服务器配置数据模型</h3><p>如何配置<code>NETCONF</code>或<code>RESTCONF</code>服务器超出了本文的范围。</p><p>这包括可能用于指定主机名，<code>IP</code>地址，端口，算法或其他相关参数的配置。 也就是说，<a href="https://tools.ietf.org/html/rfc8071#ref-NETCONF-MODELS" target="_blank" rel="noopener">NETCONF-MODELS</a>和<a href="https://tools.ietf.org/html/rfc8071#ref-RESTCONF-MODELS" target="_blank" rel="noopener">RESTCONF-MODELS</a>中提供了用于配置NETCONF和RESTCONF服务器的YANG <a href="https://tools.ietf.org/html/rfc7950" target="_blank" rel="noopener">RFC7950</a>数据模块，包括<code>call home</code>。</p><h2 id="安全考虑"><a href="#安全考虑" class="headerlink" title="安全考虑"></a>安全考虑</h2><p><a href="https://tools.ietf.org/html/rfc6242" target="_blank" rel="noopener">RFC6242</a>和<a href="https://tools.ietf.org/html/rfc7589" target="_blank" rel="noopener">RFC7589</a>以及扩展<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253</a>，<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246 </a>和<a href="https://tools.ietf.org/html/rfc8040" target="_blank" rel="noopener">RFC8040</a>中描述的安全考虑也适用于此处。</p><p>这个<code>RFC</code>与<code>SSH</code>/<code>TLS</code>服务器启动底层TCP连接的方式背离了标准的<code>SSH</code>和<code>TLS</code>的使用。 这种逆转与<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253</a>中的“客户端启动连接”和<a href="https://tools.ietf.org/html/rfc6125" target="_blank" rel="noopener">RFC6125</a>不一致，它们表示<strong>“客户端必须构建可接受的引用标识符列表，并且必须独立于服务提供的标识符“</strong> 。</p><p>与这些差异有关的风险主要集中在服务器认证上，客户无法将独立构建的引用标识符与服务器提供的引用标识符进行比较。为了减轻这些风险，要求<code>NETCONF</code>/<code>RESTCONF</code>客户端验证服务器的<code>SSH</code>主机密钥或证书，通过对预先配置的发行者证书进行证书路径验证，或者通过将主机密钥或证书与先前信任或“固定”值。此外，当使用证书时，要求客户端能够将在提供的证书中编码的标识符与客户端预先配置的标识符（例如，序列号）相匹配。</p><p>对于<code>NETCONF</code>/<code>RESTCONF</code>服务器提供<code>X.509</code>证书的情况，<code>NETCONF</code>/<code>RESTCONF</code>客户端应确保用于证书路径验证的<code>&quot;\&quot;</code>预配置颁发者证书对于服务器的制造商是唯一的。也就是说，证书不应该属于可能为多个制造商颁发证书的第三方认证机构。当使用将共享秘密（例如，密码）传递给服务器的客户机认证机制时，这是特别重要的。否则可能会导致客户端将共享密钥发送到恰好与客户端配置期望的服务器具有相同身份（例如，序列号）的另一个服务器的情况。</p><p>接下来会考虑与服务器身份验证无关的问题。</p><p>运行<code>NETCONF Call Home</code>或<code>RESTCONF Call Home</code>的面向<code>Internet</code>的主机将通过诸如”<a href="https://tools.ietf.org/html/rfc8071#ref-zmap" target="_blank" rel="noopener">zmap</a>“之类的扫描工具进行指纹识别。 <code>SSH</code>和<code>TLS</code>都提供了许多方法可以在主机上进行指纹识别。 <code>SSH</code>和<code>TLS</code>服务器相当成熟，能够抵御攻击，但是<code>SSH</code>和<code>TLS</code>客户端可能不够强大。实施者和部署需要确保提供软件更新机制，以便及时修复漏洞。</p><p>攻击者可以在推断出攻击者没有拥有有效密钥之前，对<code>NETCONF</code>/<code>RESTCONF</code>客户端进行拒绝服务（<code>DoS</code>）攻击，执行计算量大的操作。 例如，在<a href="">TLS1.3</a>中，<code>ClientHello</code>消息包含成本很高的非对称密钥操作的密钥共享值。 推荐使用常见的减轻<code>DoS</code>攻击的预防措施，例如在一系列不成功的登录尝试后暂时将源地址列入黑名单。</p><p>当使用带有<code>RESTCONF</code>协议的<code>call home</code>时，在使用一些<code>HTTP</code>认证方案时，特别要注意传送共享密钥（例如密码）的<code>Basic</code> <a href="https://tools.ietf.org/html/rfc7617" target="_blank" rel="noopener">RFC7617</a>和<code>Digest</code> <a href="https://tools.ietf.org/html/rfc7616" target="_blank" rel="noopener">RFC7616</a>方案。 对于使用的任何<code>HTTP</code>客户机认证方案，实施者和部署都应确保查看<code>RFC</code>中的“安全注意事项”部分。</p><h2 id="IANA考虑事项"><a href="#IANA考虑事项" class="headerlink" title="IANA考虑事项"></a>IANA考虑事项</h2><p>IANA已经在“用户端口”范围内为服务名称“<code>netconf-ch-ssh</code>”，“<code>netconf-ch-tls</code>”和“<code>restconf-ch-tls</code>”分配了三个<code>TCP</code>端口号。 这些端口将是<code>NETCONF Call Home</code>和<code>RESTCONF Call Home</code>协议的默认端口。 以下是遵循<a href="https://tools.ietf.org/html/rfc6335" target="_blank" rel="noopener">RFC6335</a>中的规则的注册模板。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Service Name:           netconf-ch-ssh</span><br><span class="line">Port Number:            4334</span><br><span class="line">Transport Protocol(s):  TCP</span><br><span class="line">Description:            NETCONF Call Home (SSH)</span><br><span class="line">Assignee:               IESG &lt;iesg@ietf.org&gt;</span><br><span class="line">Contact:                IETF Chair &lt;chair@ietf.org&gt;</span><br><span class="line">Reference:              RFC 8071</span><br><span class="line"></span><br><span class="line">Service Name:           netconf-ch-tls</span><br><span class="line">Port Number:            4335</span><br><span class="line">Transport Protocol(s):  TCP</span><br><span class="line">Description:            NETCONF Call Home (TLS)</span><br><span class="line">Assignee:               IESG &lt;iesg@ietf.org&gt;</span><br><span class="line">Contact:                IETF Chair &lt;chair@ietf.org&gt;</span><br><span class="line">Reference:              RFC 8071</span><br><span class="line"></span><br><span class="line">Service Name:           restconf-ch-tls</span><br><span class="line">Port Number:            4336</span><br><span class="line">Transport Protocol(s):  TCP</span><br><span class="line">Description:            RESTCONF Call Home (TLS)</span><br><span class="line">Assignee:               IESG &lt;iesg@ietf.org&gt;</span><br><span class="line">Contact:                IETF Chair &lt;chair@ietf.org&gt;</span><br><span class="line">Reference:              RFC 8071</span><br></pre></td></tr></table></figure><h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><p>关于<code>NETCONF Call Home</code>的实现，可以参考<code>Juniper</code>在<a href="https://github.com/Juniper" target="_blank" rel="noopener">github</a>上开源的<a href="https://github.com/Juniper/netconf-call-home" target="_blank" rel="noopener">netconf-call-home</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tools.ietf.org/html/rfc8071" target="_blank" rel="noopener">RFC 8071 - NETCONF Call Home and RESTCONF Call Home</a></li><li><a href="https://tools.ietf.org/html/rfc6242" target="_blank" rel="noopener">RFC6242 - Using the NETCONF Protocol over Secure Shell (SSH)</a></li><li><a href="https://tools.ietf.org/html/rfc7589" target="_blank" rel="noopener">RFC7589 - Using the NETCONF Protocol over Transport Layer Security (TLS) with Mutual X.509 Authentication</a></li><li><a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253 -  The Secure Shell (SSH) Transport Layer Protocol</a></li><li><a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246 -  The Transport Layer Security (TLS) Protocol Version 1.2</a></li><li><a href="https://tools.ietf.org/html/rfc8040" target="_blank" rel="noopener">RFC8040 - RESTCONF Protocol</a></li><li><a href="https://github.com/Juniper/netconf-call-home" target="_blank" rel="noopener">Juniper netconf-call-home</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> SDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NETCONF </tag>
            
            <tag> RFC </tag>
            
            <tag> RFC8071 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUnit5教程-注解</title>
      <link href="2017/10/10/junit-5-annotations/"/>
      <url>2017/10/10/junit-5-annotations/</url>
      
        <content type="html"><![CDATA[<p><img src="http://junit.org/junit4/images/junit5-banner.png" alt="junit5 logo"></p><h2 id="JUnit5提供的注解"><a href="#JUnit5提供的注解" class="headerlink" title="JUnit5提供的注解"></a>JUnit5提供的注解</h2><table><thead><tr><th>Annotations</th><th>描述</th></tr></thead><tbody><tr><td><code>@BeforeEach</code></td><td>在方法上注解，在每个测试方法运行之前执行。</td></tr><tr><td><code>@AfterEach</code></td><td>在方法上注解，在每个测试方法运行之后执行</td></tr><tr><td><code>@BeforeAll</code></td><td>该注解方法会在所有测试方法之前运行，该方法必须是静态的。</td></tr><tr><td><code>@AfterAll</code></td><td>该注解方法会在所有测试方法之后运行，该方法必须是静态的。</td></tr><tr><td><code>@Test</code></td><td>用于将方法标记为测试方法</td></tr><tr><td><code>@DisplayName</code></td><td>用于为测试类或测试方法提供任何自定义显示名称</td></tr><tr><td><code>@Disable</code></td><td>用于禁用或忽略测试类或方法</td></tr><tr><td><code>@Nested</code></td><td>用于创建嵌套测试类</td></tr><tr><td><code>@Tag</code></td><td>用于测试发现或过滤的标签来标记测试方法或类</td></tr><tr><td><code>@TestFactory</code></td><td>标记一种方法是动态测试的测试工场</td></tr></tbody></table><a id="more"></a><h2 id="JUnit5-VS-JUnit4"><a href="#JUnit5-VS-JUnit4" class="headerlink" title="JUnit5 VS JUnit4"></a>JUnit5 VS JUnit4</h2><p><img src="https://image.slidesharecdn.com/junit5vsjunit4-170324194457/95/junit-5-vs-junit-4-9-638.jpg" alt="junit5 vs junit4"></p><blockquote><p>本图来自<a href="https://www.slideshare.net/rkmael" target="_blank" rel="noopener">Ismael</a>在Slideshare分享的<a href="https://www.slideshare.net/rkmael/junit-5-vs-junit-4" target="_blank" rel="noopener">JUnit 5 vs JUnit 4</a></p></blockquote><p>接下来来我们来一个个注解详细介绍。</p><h2 id="BeforeAll"><a href="#BeforeAll" class="headerlink" title="@BeforeAll"></a>@BeforeAll</h2><p>如[JUnit5 VS JUnit4](#JUnit5 VS JUnit4)图中所示，<code>@BeforeAll</code>是替换JUnit4的<code>@BeforeClass</code>。它用于表示在当前测试类中的所有测试之前应该执行注解的方法。</p><h3 id="BeforeAll使用"><a href="#BeforeAll使用" class="headerlink" title="@BeforeAll使用"></a>@BeforeAll使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BeforeAll</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Before All init() method called"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@BeforeAll</code>注解方法必须是静态方法，否则会抛出运行时错误。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.junit.platform.commons.JUnitException: <span class="meta">@BeforeAll</span> method <span class="string">'public void com.github.tonydeng.junit5.examples.JUnit5AnnotationsExample.init()'</span> must be <span class="keyword">static</span>.</span><br><span class="line">at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.assertStatic(LifecycleMethodUtils.java:<span class="number">66</span>)</span><br><span class="line">at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.lambda$findBeforeAllMethods$<span class="number">0</span>(LifecycleMethodUtils.java:<span class="number">42</span>)</span><br><span class="line">at java.util.ArrayList.forEach(ArrayList.java:<span class="number">1249</span>)</span><br><span class="line">at java.util.Collections$UnmodifiableCollection.forEach(Collections.java:<span class="number">1080</span>)</span><br><span class="line">at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findBeforeAllMethods(LifecycleMethodUtils.java:<span class="number">42</span>)</span><br></pre></td></tr></table></figure><h3 id="BeforeAll示例"><a href="#BeforeAll示例" class="headerlink" title="@BeforeAll示例"></a>@BeforeAll示例</h3><p>我们来举个例子。我使用了一个<code>Calculator</code>类并添加了一个<code>add</code>方法。我将使用<code>@RepeatedTest</code>注解测试它5次。此注解将导致<code>add</code>测试运行5次。但<code>@BeforeAll</code>注解方法只能调用一次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.RepeatedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.TestInfo;</span><br><span class="line"><span class="keyword">import</span> org.junit.platform.runner.JUnitPlatform;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before All init() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算器类是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在执行测试，您将在控制台输出下方看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Before All init() method called</span><br></pre></td></tr></table></figure><p>显然，@BeforeAll注解init()方法只调用一次。</p><h2 id="BeforeEach"><a href="#BeforeEach" class="headerlink" title="@BeforeEach"></a>@BeforeEach</h2><p>如[JUnit5 VS JUnit4](#JUnit5 VS JUnit4)图中所示，<code>@BeforeEach</code>注解是替换JUnit4中的<code>@Before</code>注解。它用于表示<code>@Test</code>在当前类中的每个方法之前应该执行注解方法。</p><h3 id="BeforeEach用法"><a href="#BeforeEach用法" class="headerlink" title="@BeforeEach用法"></a>@BeforeEach用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Before Each initEach() method called"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@BeforeEach 注解方法不能是静态方法，否则会抛出运行时错误。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.junit.platform.commons.JUnitException: <span class="meta">@BeforeEach</span> method <span class="string">'public static void com.github.tonydeng.junit5.examples.JUnit5AnnotationsExample.initEach()'</span> must not be <span class="keyword">static</span>.</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.assertNonStatic(LifecycleMethodUtils.java:<span class="number">73</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.lambda$findBeforeEachMethods$<span class="number">2</span>(LifecycleMethodUtils.java:<span class="number">54</span>)</span><br><span class="line">    at java.util.ArrayList.forEach(ArrayList.java:<span class="number">1249</span>)</span><br><span class="line">    at java.util.Collections$UnmodifiableCollection.forEach(Collections.java:<span class="number">1080</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findBeforeEachMethods(LifecycleMethodUtils.java:<span class="number">54</span>)</span><br></pre></td></tr></table></figure><h3 id="BeforeEach示例"><a href="#BeforeEach示例" class="headerlink" title="@BeforeEach示例"></a>@BeforeEach示例</h3><p>我还是使用之前<code>Calculator</code>类的add方法。我将使用<code>@RepeatedTest</code>注解测试它5次。此注解将导致<code>add</code>测试运行5次。对于每次运行的测试方法，<code>@BeforeEach</code>注解方法也应该每次运行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.RepeatedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.TestInfo;</span><br><span class="line"><span class="keyword">import</span> org.junit.platform.runner.JUnitPlatform;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before All init() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before Each initEach() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在执行测试，您将在控制台输出下方看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Before All init() method called</span><br><span class="line">Before Each initEach() method called</span><br><span class="line">Before Each initEach() method called</span><br><span class="line">Before Each initEach() method called</span><br><span class="line">Before Each initEach() method called</span><br><span class="line">Before Each initEach() method called</span><br><span class="line">Before Each initEach() method called</span><br></pre></td></tr></table></figure><p>显然，每个测试方法调用调用一次<code>@BeforeEach</code>注解<code>initEach()</code>方法。</p><h2 id="AfterEach"><a href="#AfterEach" class="headerlink" title="@AfterEach"></a>@AfterEach</h2><p>如[JUnit5 VS JUnit4](#JUnit5 VS JUnit4)图中所示，<code>@AfterJUnit</code>注解是替换JUnit4中的<code>@Before</code>注解。它用于表示<code>@Test</code>在当前类中的每个方法之前应该执行注解方法。</p><h3 id="AfterEach注解用法"><a href="#AfterEach注解用法" class="headerlink" title="@AfterEach注解用法"></a>@AfterEach注解用法</h3><p>注解方法@AfterEach如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"After Each cleanUpEach() method called"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@AfterEach 注解方法不能是静态方法，否则会抛出运行时错误。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.junit.platform.commons.JUnitException: <span class="meta">@AfterEach</span> method <span class="string">'public static void com.github.tonydeng.junit5.examples.JUnit5AnnotationsExample.cleanUpEach()'</span> must not be <span class="keyword">static</span>.</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.assertNonStatic(LifecycleMethodUtils.java:<span class="number">73</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.lambda$findAfterEachMethods$<span class="number">3</span>(LifecycleMethodUtils.java:<span class="number">60</span>)</span><br><span class="line">    at java.util.ArrayList.forEach(ArrayList.java:<span class="number">1249</span>)</span><br><span class="line">    at java.util.Collections$UnmodifiableCollection.forEach(Collections.java:<span class="number">1080</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findAfterEachMethods(LifecycleMethodUtils.java:<span class="number">60</span>)</span><br></pre></td></tr></table></figure><h3 id="AfterEach注解示例"><a href="#AfterEach注解示例" class="headerlink" title="@AfterEach注解示例"></a>@AfterEach注解示例</h3><p>我还是使用之前<code>Calculator</code>类的add方法。我将使用<code>@RepeatedTest</code>注解测试它5次。此注解将导致<code>add</code>测试运行5次。对于每次运行的测试方法，<code>@AfterEach</code>注解方法也应该每次运行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.RepeatedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.TestInfo;</span><br><span class="line"><span class="keyword">import</span> org.junit.platform.runner.JUnitPlatform;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After All cleanUp() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After Each cleanUpEach() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在执行测试，您将在控制台输出下方看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After All cleanUp() method called</span><br></pre></td></tr></table></figure><p>显然，每个测试方法调用调用一次<code>@AfterEach</code>注解<code>cleanUpEach()</code>方法。</p><h2 id="AfterAll"><a href="#AfterAll" class="headerlink" title="@AfterAll"></a>@AfterAll</h2><p>如[JUnit5 VS JUnit4](#JUnit5 VS JUnit4)图中所示，<code>@AfterAll</code>注解是替换JUnit4中的<code>@AfterClass</code>注解。它用于表示在当前测试类中的所有测试后应执行注解方法。</p><h3 id="AfterAll注解使用"><a href="#AfterAll注解使用" class="headerlink" title="@AfterAll注解使用"></a>@AfterAll注解使用</h3><p>注解方法@AfterAll如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterAll</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"After All cleanUp() method called"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@AfterAll 注解方法必须是静态方法，否则会抛出运行时错误。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.junit.platform.commons.JUnitException: <span class="meta">@AfterAll</span> method <span class="string">'public void com.github.tonydeng.junit5.examples.JUnit5AnnotationsExample.cleanUp()'</span> must be <span class="keyword">static</span>.</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.assertStatic(LifecycleMethodUtils.java:<span class="number">66</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.lambda$findAfterAllMethods$<span class="number">1</span>(LifecycleMethodUtils.java:<span class="number">48</span>)</span><br><span class="line">    at java.util.ArrayList.forEach(ArrayList.java:<span class="number">1249</span>)</span><br><span class="line">    at java.util.Collections$UnmodifiableCollection.forEach(Collections.java:<span class="number">1080</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findAfterAllMethods(LifecycleMethodUtils.java:<span class="number">48</span>)</span><br></pre></td></tr></table></figure><h3 id="AfterAll注解示例"><a href="#AfterAll注解示例" class="headerlink" title="@AfterAll注解示例"></a>@AfterAll注解示例</h3><p>我还是使用之前<code>Calculator</code>类的add方法。我将使用<code>@RepeatedTest</code>注解测试它5次。此注解将导致<code>add</code>测试运行5次。但<code>@AfterAll</code>注解方法只能调用一次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.RepeatedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.TestInfo;</span><br><span class="line"><span class="keyword">import</span> org.junit.platform.runner.JUnitPlatform;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After All cleanUp() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After Each cleanUpEach() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在执行测试，您将在控制台输出下方看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After All cleanUp() method called</span><br></pre></td></tr></table></figure><p>显然，<code>@AfterAll</code>注解<code>cleanUp()</code>方法只调用一次。</p><h2 id="RepeatedTest"><a href="#RepeatedTest" class="headerlink" title="@RepeatedTest"></a>@RepeatedTest</h2><p>JUnit5 <code>@RepeatedTest</code>注解能够编写可重复的测试模板，可以多次运行。频率可以配置为<code>@RepeatedTest</code>注解的参数。</p><h3 id="RepeatedTest注解用法"><a href="#RepeatedTest注解用法" class="headerlink" title="@RepeatedTest注解用法"></a>@RepeatedTest注解用法</h3><p>要创建可重复的测试模板方法，请使用注解方法@RepeatedTest。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line"><span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>addNumber()</code>测试将重复5次。请注意，重复测试的每次调用的行为就像一个常规<code>@Test</code>方法的执行，并且完全支持相同的生命周期回调和扩展。这意味着，<code>@BeforeEach</code>和<code>@AfterEach</code>注解的方法将被调用，他们适合在测试生命周期，为每个单独的调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.RepeatedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.TestInfo;</span><br><span class="line"><span class="keyword">import</span> org.junit.platform.runner.JUnitPlatform;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before All init() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before Each initEach() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"===addNumber testcase executed==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After Each cleanUpEach() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After All cleanUp() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Before All init() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">After All cleanUp() method called</span><br></pre></td></tr></table></figure><h3 id="使用-RepeatedTest注解定制显示名称"><a href="#使用-RepeatedTest注解定制显示名称" class="headerlink" title="使用@RepeatedTest注解定制显示名称"></a>使用@RepeatedTest注解定制显示名称</h3><p>除了指定重复次数之外，您还可以为每次重复提供自定义显示名称。此自定义显示名称可以是静态文本+动态占位符的组合。目前支持3名占有者：</p><ul><li><code>{displayName}</code>：显示<code>@RepeatedTest</code>方法名称。</li><li><code>{currentRepetition}</code>：当前重复计数。</li><li><code>{totalRepetitions}</code>：重复的总数。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JUnit5AnnotationsExample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(value = <span class="number">5</span>, name = <span class="string">"&#123;displayName&#125; - repetition &#123;currentRepetition&#125; of &#123;totalRepetitions&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDE中运行该测试，将会产生类似下图的运行记录：</p><p><img src="https://s1.ax1x.com/2017/10/10/8iA7q.png" alt="RepeatedTest Run results"></p><p>您可以使用两个预定义的格式之一，即<code>RepeatedTest.LONG_DISPLAY_NAME</code>和<code>RepeatedTest.SHORT_DISPLAY_NAME</code>。<code>SHORT_DISPLAY_NAME</code>是未指定的默认格式。</p><ul><li><code>RepeatedTest.LONG_DISPLAY_NAME</code> - {displayName} :: repet {currentRepetition} {totalRepetitions}</li><li><code>RepeatedTest.SHORT_DISPLAY_NAME</code> - repetition {currentRepetition} {totalRepetitions}</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line"><span class="meta">@RepeatedTest</span>(value = <span class="number">5</span>, name = RepeatedTest.LONG_DISPLAY_NAME)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用RepetitionInfo接口"><a href="#使用RepetitionInfo接口" class="headerlink" title="使用RepetitionInfo接口"></a>使用RepetitionInfo接口</h3><p><a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/RepetitionInfo.html" target="_blank" rel="noopener">RepetitionInfo</a>用于将关于当前重复的重复测试的信息注入到<code>@RepeatedTest</code>和<code>@BeforeEach</code>，和<code>@AfterEach</code>方法中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initEach</span><span class="params">(RepetitionInfo info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentRepetition = info.getCurrentRepetition();</span><br><span class="line">        <span class="keyword">int</span> totalRepetitions = info.getTotalRepetitions();</span><br><span class="line">        <span class="comment">//Use information as needed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(value = <span class="number">5</span>, name=<span class="string">"&#123;displayName&#125; :: repetition &#123;currentRepetition&#125; of &#123;totalRepetitions&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpEach</span><span class="params">(RepetitionInfo info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentRepetition = info.getCurrentRepetition();</span><br><span class="line">        <span class="keyword">int</span> totalRepetitions = info.getTotalRepetitions();</span><br><span class="line">        <span class="comment">//Use information as needed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到目前为止，整个<code>@RepeatedTest</code>功能处于<code>Experimental</code>状态。将来可以更新甚至删除。</p></blockquote><h2 id="Disabled"><a href="#Disabled" class="headerlink" title="@Disabled"></a>@Disabled</h2><p><a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Disabled.html" target="_blank" rel="noopener">@Disabled</a>注解可用于禁用测试套件的测试方法。此注解可以应用于测试类以及单独的测试方法。</p><p>它只接受一个可选参数，指示该测试被禁用的原因。</p><h3 id="Disabled测试类"><a href="#Disabled测试类" class="headerlink" title="@Disabled测试类"></a>@Disabled测试类</h3><p>当@Disabled通过测试类应用时，该类中的所有测试方法也将自动禁用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assumptions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Disabled;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnDev</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"DEV"</span>);</span><br><span class="line">        Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnProd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"PROD"</span>);</span><br><span class="line">        Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意运行次数：2/2（2跳过）。</p></blockquote><h3 id="Disabled测试方法"><a href="#Disabled测试方法" class="headerlink" title="@Disabled测试方法"></a>@Disabled测试方法</h3><p>@Disabled用于表示注解的测试方法当前已禁用，不应执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assumptions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Disabled;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Disabled</span>(<span class="string">"Do not run in lower environment"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnDev</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"DEV"</span>);</span><br><span class="line">        Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnProd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"PROD"</span>);</span><br><span class="line">        Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意运行次数：2/2（1跳过）。</p></blockquote><h2 id="Tag"><a href="#Tag" class="headerlink" title="@Tag"></a>@Tag</h2><p> <a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Tag.html" target="_blank" rel="noopener">@Tag</a>可用于从测试计划中过滤测试用例。它可以帮助为不同环境，不同用例或任何特定要求创建多个不同的测试计划。您可以通过在测试计划OR中仅包括那些标记的测试来排除测试计划中的其他测试来执行一组测试。</p><h3 id="Tag注解用法"><a href="#Tag注解用法" class="headerlink" title="@Tag注解用法"></a>@Tag注解用法</h3><p>您可以<code>@Tag</code>在测试类或测试方法或两者上应用注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Tag</span>(<span class="string">"development"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassATest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"userManagement"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCaseA</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">您也可以在单个测试用例上应用多个标签，以便将其包含在多个测试计划中。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassATest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"production"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCaseA</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-IncludeTags和-ExcludeTags创建测试计划"><a href="#使用-IncludeTags和-ExcludeTags创建测试计划" class="headerlink" title="使用@IncludeTags和@ExcludeTags创建测试计划"></a>使用@IncludeTags和@ExcludeTags创建测试计划</h3><p>可以在测试计划中使用<code>@IncludeTags</code>或<code>@ExcludeTags</code>注解来过滤测试或包含测试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@IncludeTags example</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@SelectPackages("com.github.tonydeng.junit5.examples")</span><br><span class="line"><span class="meta">@IncludeTags</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@ExcludeTags example</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@SelectPackages("com.github.tonydeng.junit5.examples")</span><br><span class="line"><span class="meta">@ExcludeTags</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要添加多个标签，请将所需标注的字符串数组传递给所需的注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@SelectPackages("com.github.tonydeng.junit5.examples")</span><br><span class="line"><span class="meta">@IncludeTags</span>(&#123;<span class="string">"production"</span>,<span class="string">"development"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不能在单个测试计划中同时包含<code>@IncludeTags</code>和<code>@ExcludeTags</code>注解。</p></blockquote><h3 id="Tag示例"><a href="#Tag示例" class="headerlink" title="@Tag示例"></a>@Tag示例</h3><p>假设我们有3个测试，我们想在开发环境中运行所有3个测试; 但是想在生产中只运行一个。所以我们将标记测试如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassATest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"production"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCaseA</span><span class="params">(TestInfo testInfo)</span> </span>&#123; <span class="comment">//run in all environments</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassBTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCaseB</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCaseC</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们为这两种环境创建测试计划。</p><h4 id="测试在生产环境中运行"><a href="#测试在生产环境中运行" class="headerlink" title="测试在生产环境中运行"></a>测试在生产环境中运行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@SelectPackages("com.github.tonydeng.junit5.examples")</span><br><span class="line"><span class="meta">@IncludeTags</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionTests</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试在开发环境中运行"><a href="#测试在开发环境中运行" class="headerlink" title="测试在开发环境中运行"></a>测试在开发环境中运行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@SelectPackages("com.github.tonydeng.junit5.examples")</span><br><span class="line"><span class="meta">@IncludeTags</span>(<span class="string">"development"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevelopmentTests</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUnit5 Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> junit5 </tag>
            
            <tag> junit </tag>
            
            <tag> tutorial </tag>
            
            <tag> unit testing </tag>
            
            <tag> annotations </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUnit5教程-测试生命周期</title>
      <link href="2017/10/09/junit-5-test-lifecycle/"/>
      <url>2017/10/09/junit-5-test-lifecycle/</url>
      
        <content type="html"><![CDATA[<p><img src="http://junit.org/junit4/images/junit5-banner.png" alt="junit5 logo"></p><p>在JUnit5中，测试生命周期由4个主要注解驱动，即<code>@BeforeAll</code>、<code>@BeforeEach</code>、<code>@AfterEach</code>和<code>@AfterAll</code>。与此同时，每个测试方法都必须标注<code>@Test</code>注解。</p><a id="more"></a><h2 id="生命周期结构"><a href="#生命周期结构" class="headerlink" title="生命周期结构"></a>生命周期结构</h2><p><img src="http://junit.org/junit5/docs/current/user-guide/images/extensions_lifecycle.png" alt="junit 5 test lifecycle"></p><h2 id="Before-amp-After"><a href="#Before-amp-After" class="headerlink" title="Before &amp; After"></a>Before &amp; After</h2><p>在junit测试生命周期中，我们需要一些方法来设置和清除测试运行的环境或测试数据。</p><p>在JUnit中，对于每个测试 - 创建了一个新的测试实例。<code>@BeforeAll</code>和@<code>AfterAll</code>注释 - 以其名称清除 - 在整个测试执行周期中只应调用一次。所以他们必须被宣布</p><p>在JUnit中，对于每个测试 ，都会创建了一个新的测试实例。<code>@BeforeAll</code>和<code>@AfterAll</code>注解，在整个测试执行周期中只应调用一次。所以他们必须被声明为<code>static</code>。</p><p>如果他们是用相同注释注释的多个方法（例如两个方法<code>@BeforeAll</code>），那么它们的执行顺序是不确定的。</p><p><code>@BeforeEach</code>和<code>@AfterEach</code>为每个测试实例调用，所以他们不需要<code>static</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@BeforeAll executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setupThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@BeforeEach executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCalcOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======TEST ONE EXECUTED======="</span>);</span><br><span class="line">        Assertions.assertEquals( <span class="number">4</span> , Calculator.add(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCalcTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======TEST TWO EXECUTED======="</span>);</span><br><span class="line">        Assertions.assertEquals( <span class="number">6</span> , Calculator.add(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@AfterEach executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@AfterAll executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@BeforeAll executed</span><br><span class="line"></span><br><span class="line">@BeforeEach executed</span><br><span class="line">======TEST ONE EXECUTED=======</span><br><span class="line">@AfterEach executed</span><br><span class="line"></span><br><span class="line">@BeforeEach executed</span><br><span class="line">======TEST TWO EXECUTED=======</span><br><span class="line">@AfterEach executed</span><br><span class="line"></span><br><span class="line">@AfterAll executed</span><br></pre></td></tr></table></figure><h2 id="禁用测试"><a href="#禁用测试" class="headerlink" title="禁用测试"></a>禁用测试</h2><p>要在JUnit 5中禁用测试，您将需要使用<code>@Disabled</code>注释。它相当于JUnit 4的<code>@Ignored</code>注释。</p><p><code>@Disabled</code> 注释可以应用于测试类（禁用该类中的所有测试方法）或单独的测试方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCalcTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"======TEST TWO EXECUTED======="</span>);</span><br><span class="line">    Assertions.assertEquals( <span class="number">6</span> , Calculator.add(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在任何测试方法中，ou将需要确定它是否通过失败。你可以使用断言来做。资产有助于通过测试用例的实际输出验证预期输出。为了保持简单，所有JUnit Jupiter断言是<a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assertions.html" target="_blank" rel="noopener">org.junit.jupiter.Assertions</a>类中的静态方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Test will pass</span></span><br><span class="line">    Assertions.assertEquals(<span class="number">4</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test will fail</span></span><br><span class="line">    Assertions.assertEquals(<span class="number">3</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>), <span class="string">"Calculator.add(2, 2) test failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test will fail</span></span><br><span class="line">    Supplier&lt;String&gt; messageSupplier  = ()-&gt; <span class="string">"Calculator.add(2, 2) test failed"</span>;</span><br><span class="line">    Assertions.assertEquals(<span class="number">3</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>), messageSupplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要测试失败，只需使用<code>Assertions.fail()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assertions.fail(<span class="string">"not found good reason to pass"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p><a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assumptions.html" target="_blank" rel="noopener">Assumptions</a>提供了基于假设支持条件测试执行的静态方法。失败的假设导致测试被中止。无论何时继续执行给定的测试方法没有意义，通常使用假设。在测试报告中，这些测试将被标记为已通过。</p><p>假设类有两个方法：<code>assumeFalse()</code>，<code>assumeTrue()</code>。第三种方法<code>assumeThat()</code>处于实验状态，可能会在将来的版本中得到证实。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnDev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.setProperty(<span class="string">"ENV"</span>, <span class="string">"DEV"</span>);</span><br><span class="line">    Assumptions.assumeTrue(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    <span class="comment">//remainder of test will proceed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnProd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.setProperty(<span class="string">"ENV"</span>, <span class="string">"PROD"</span>);</span><br><span class="line">    Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    <span class="comment">//remainder of test will be aborted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更改默认测试实例生命周期"><a href="#更改默认测试实例生命周期" class="headerlink" title="更改默认测试实例生命周期"></a>更改默认测试实例生命周期</h2><p>如果没有注释测试类或测试接口<code>@TestInstance</code>，则JUnit Jupiter将使用默认生命周期模式。</p><blockquote><p>在jupiter api的TestInstance中定义的Lifecycle枚举</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.jupiter.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> org.apiguardian.api.API;</span><br><span class="line"><span class="keyword">import</span> org.apiguardian.api.API.Status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@API</span>(</span><br><span class="line">    status = Status.STABLE,</span><br><span class="line">    since = <span class="string">"5.0"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestInstance &#123;</span><br><span class="line">    TestInstance.<span class="function">Lifecycle <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Lifecycle &#123;</span><br><span class="line">        PER_CLASS,</span><br><span class="line">        PER_METHOD;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Lifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准默认模式是<code>PER_METHOD</code>，但是，可以更改执行整个测试计划的默认值。</p><p>要更改默认的测试实例生命周期模式，只需将<code>junit.jupiter.testinstance.lifecycle.default</code> 配置参数设置为 <code>TestInstance.Lifecycle</code>忽略大小写中定义的枚举常量的名称。</p><p>这可以被提供作为一个JVM系统属性，作为配置参数在 LauncherDiscoveryRequest被传递到Launcher，或通过JUnit的平台配置文件。</p><p>例如，要设置成默认的测试生命周期模式<code>Lifecycle.PER_CLASS</code>,可以使用以下系统属性启动JVM。</p><blockquote><p>-Djunit.jupiter.testinstance.lifecycle.default=per_class</p></blockquote><p>但是请注意，通过JUnit平台配置文件设置默认测试实例生命周期模式是一个更强大的解决方案，因为配置文件可以与项目一起检入版本控制系统，因此可以在IDE和您的构建软件中使用。</p><p>要<code>Lifecycle.PER_CLASS</code>通过JUnit平台配置文件设置默认测试实例生命周期模式，请创建一个以<code>junit-platform.properties</code>类路径根目录命名的文件（例如，<code>src/test/resources</code>），具有以下内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">junit.jupiter.testinstance.lifecycle.<span class="keyword">default</span> = per_class</span><br></pre></td></tr></table></figure><blockquote><p>更改默认的测试实例生命周期模式可能导致不可预测的结果和脆弱的构建。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JUnit5 Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> junit5 </tag>
            
            <tag> junit </tag>
            
            <tag> tutorial </tag>
            
            <tag> unit testing </tag>
            
            <tag> test lifecycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUnit5教程-简介</title>
      <link href="2017/10/09/junit-5-tutorial-introduction/"/>
      <url>2017/10/09/junit-5-tutorial-introduction/</url>
      
        <content type="html"><![CDATA[<p><img src="http://junit.org/junit4/images/junit5-banner.png" alt="junit5 logo"></p><p>这个<a href="/categories/JUnit5-Tutorial/">JUnit5教程</a>将讲述如何使用Java8风格的编码以及其他功能，同时也了解<a href="http://junit.org/junit5/" target="_blank" rel="noopener">JUnit5</a>与之前的版本的区别。</p><h2 id="Junit5简介"><a href="#Junit5简介" class="headerlink" title="Junit5简介"></a>Junit5简介</h2><p>JUnit是Java中使用最广泛的测试框架，之前Java8发布了最引人注目的lambda表达式，整个Java的编码风格发生巨大的变化，JUnit5主要在希望能够适应Java8风格的编码以及相关工，这就是为什么建议在Java8之后的项目中使用JUnit5来创建和执行测试。</p><p>JUnit官方说明：</p><blockquote><p>JUnit 5 is the next generation of JUnit. The goal is to create an up-to-date foundation for developer-side testing on the JVM. This includes focusing on Java 8 and above, as well as enabling many different styles of testing.</p></blockquote><p>JUnit5的第一个可用性版本是在2017年9月10日发布的。</p><a id="more"></a><h2 id="JUnit5架构"><a href="#JUnit5架构" class="headerlink" title="JUnit5架构"></a>JUnit5架构</h2><p>相比JUnit4，JUnit5由三个不同的子项目及不同的模块组成。</p><blockquote><p>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</p></blockquote><p>下图是JUnit的架构图</p><p><img src="https://www.ibm.com/developerworks/library/j-introducing-junit5-part1-jupiter-api/Figure-1.png" alt="junit 5 architecture "></p><h3 id="1-JUnit-Platform"><a href="#1-JUnit-Platform" class="headerlink" title="1. JUnit Platform"></a>1. JUnit Platform</h3><p>启动Junit测试、IDE、构建工具或插件都需要包含和扩展Platform API，它定义了<code>TestEngine</code>在平台运行的新测试框架的API。</p><p>它还提供了一个控制台启动器，可以从命令行启动Platform，为Gradle和Maven插件提供支持。</p><h3 id="2-JUnit-Jupiter"><a href="#2-JUnit-Jupiter" class="headerlink" title="2. JUnit Jupiter"></a>2. JUnit Jupiter</h3><p>它用于编写测试代码的新的编程和扩展模型。它具有所有新的Junit注释和<code>TestEngine</code>实现来运行这些注释编写的测试。</p><h3 id="3-JUnit-Vintage"><a href="#3-JUnit-Vintage" class="headerlink" title="3. JUnit Vintage"></a>3. JUnit Vintage</h3><p>它主要的目的是支持在JUnit5的测试代码中运行JUnit3和4方式写的测试，它能够向前兼容之前的测试代码。</p><p>下图是JUnit5的依赖关系图</p><p><img src="http://junit.org/junit5/docs/current/user-guide/images/component-diagram.svg" alt="junit 5 dependence"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>你可以在Maven或Gradle项目中使用JUnit5，包含最小的两个依赖关系，即<code>junit-jupiter-engince</code>和<code>junit-platform-runner</code>。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.jupiter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-platform-runner<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.platform.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">testRuntime(<span class="string">"org.junit.jupiter:junit-jupiter-engine:5.0.0-M4"</span>)</span><br><span class="line">testRuntime(<span class="string">"org.junit.platform:junit-platform-runner:1.0.0-M4"</span>)</span><br></pre></td></tr></table></figure><p>如果你想了解更多的话，可以查看官方的<a href="https://github.com/junit-team/junit5-samples/blob/master/junit5-gradle-consumer/build.gradle" target="_blank" rel="noopener">build.gradle</a>和<a href="https://github.com/junit-team/junit5-samples/blob/master/junit5-maven-consumer/pom.xml" target="_blank" rel="noopener">pom.xml</a>。</p><h2 id="JUnit5-Annotations"><a href="#JUnit5-Annotations" class="headerlink" title="JUnit5 Annotations"></a>JUnit5 Annotations</h2><p>JUnit5提供了以下的注解来编写测试代码。</p><table><thead><tr><th>Annotations</th><th>描述</th></tr></thead><tbody><tr><td><code>@BeforeEach</code></td><td>在方法上注解，在每个测试方法运行之前执行。</td></tr><tr><td><code>@AfterEach</code></td><td>在方法上注解，在每个测试方法运行之后执行</td></tr><tr><td><code>@BeforeAll</code></td><td>该注解方法会在所有测试方法之前运行，该方法必须是静态的。</td></tr><tr><td><code>@AfterAll</code></td><td>该注解方法会在所有测试方法之后运行，该方法必须是静态的。</td></tr><tr><td><code>@Test</code></td><td>用于将方法标记为测试方法</td></tr><tr><td><code>@DisplayName</code></td><td>用于为测试类或测试方法提供任何自定义显示名称</td></tr><tr><td><code>@Disable</code></td><td>用于禁用或忽略测试类或方法</td></tr><tr><td><code>@Nested</code></td><td>用于创建嵌套测试类</td></tr><tr><td><code>@Tag</code></td><td>用于测试发现或过滤的标签来标记测试方法或类</td></tr><tr><td><code>@TestFactory</code></td><td>标记一种方法是动态测试的测试工场</td></tr></tbody></table><blockquote><p>可以查看详细的<a href="/2017/10/10/junit-5-annotations/">JUnit5注解</a>说明</p></blockquote><h2 id="使用JUnit5编写测试"><a href="#使用JUnit5编写测试" class="headerlink" title="使用JUnit5编写测试"></a>使用JUnit5编写测试</h2><p>JUnit4和JUnit5在测试编码风格上没有太大变化。这是其<a href="/2017/10/09/junit-5-test-lifecycle/">生命周期</a>方法的样本测试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Disabled;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Tag;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.tonydeng.junit5.examples.Calculator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@BeforeAll executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setupThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@BeforeEach executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"DEV"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCalcOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======TEST ONE EXECUTED======="</span>);</span><br><span class="line">        Assertions.assertEquals( <span class="number">4</span> , Calculator.add(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"PROD"</span>)</span><br><span class="line">    <span class="meta">@Disabled</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCalcTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======TEST TWO EXECUTED======="</span>);</span><br><span class="line">        Assertions.assertEquals( <span class="number">6</span> , Calculator.add(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@AfterEach executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@AfterAll executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试套件"><a href="#测试套件" class="headerlink" title="测试套件"></a>测试套件</h2><p>使用JUnit5的测试套件，可以将测试扩展到多个测试类和不同的软件包。JUnit5提供了两个注解： <a href="http://junit.org/junit5/docs/current/api/index.html?org/junit/platform/runner/SelectPackages.html" target="_blank" rel="noopener">@SelectPackages</a> 和 <a href="http://junit.org/junit5/docs/current/api/index.html?org/junit/platform/runner/SelectClasses.html" target="_blank" rel="noopener">@SelectClasses</a> 来创建测试套件。</p><p>要执行测试套件，可以是使用 <code>@RunWith(JUnitPlatform.class)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@SelectPackages("com.github.tonydeng.junit5.examples")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5TestSuiteExample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，你也可以使用以下注解来过滤测试包、类甚至测试方法。</p><ol><li><code>@IncludePackages</code>和<code>@ExcludePackages</code>来过滤包</li><li><code>@IncludeClassNamePatterns</code>和<code>@ExcludeClassNamePatterns</code>过滤测试类</li><li><code>@IncludeTags</code>和<code>@ExcludeTags</code>过滤测试方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@SelectPackages("com.github.tonydeng.junit5.examples")</span><br><span class="line"><span class="meta">@IncludePackages</span>(<span class="string">"com.github.tonydeng.junit5.examples.packageC"</span>)</span><br><span class="line"><span class="meta">@ExcludeTags</span>(<span class="string">"PROD"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5TestSuiteExample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言有助于使用测试用例的实际输出验证预期输出。为了保持简单，所有JUnit Jupiter断言是<a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assertions.html" target="_blank" rel="noopener">org.junit.jupiter.Assertions</a>类中的静态方法，例如<code>assertEquals()</code>，<code>assertNotEquals()</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Test will pass</span></span><br><span class="line">    Assertions.assertNotEquals(<span class="number">3</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test will fail</span></span><br><span class="line">    Assertions.assertNotEquals(<span class="number">4</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>), <span class="string">"Calculator.add(2, 2) test failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test will fail</span></span><br><span class="line">    Supplier&lt;String&gt; messageSupplier  = ()-&gt; <span class="string">"Calculator.add(2, 2) test failed"</span>;</span><br><span class="line">    Assertions.assertNotEquals(<span class="number">4</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>), messageSupplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p><a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assumptions.html" target="_blank" rel="noopener">Assumptions</a>类提供了静态方法来支持基于假设的条件测试执行。失败的假设导致测试被中止。无论何时继续执行给定的测试方法没有意义，通常使用假设。在测试报告中，这些测试将被标记为已通过。</p><p>JUnit的Jupiter假设类有两个这样的方法：<code>assumeFalse()</code>，<code>assumeTrue()</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnDev</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"DEV"</span>);</span><br><span class="line">        Assumptions.assumeTrue(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)), AppTest::message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnProd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"PROD"</span>);</span><br><span class="line">        Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">message</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TEST Execution Failed :: "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUnit3或4的兼容性"><a href="#JUnit3或4的兼容性" class="headerlink" title="JUnit3或4的兼容性"></a>JUnit3或4的兼容性</h2><p>JUnit4已经存在了很长时间，并且有许多以JUnit4编写的测试.JUnit Jupiter还需要支持这些测试。为此，开发了JUnit Vintage子项目。</p><p>JUnit Vintage提供了TestEngine在JUnit 5平台上运行基于JUnit 3和JUnit 4的测试的实现。</p>]]></content>
      
      
      <categories>
          
          <category> JUnit5 Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> junit5 </tag>
            
            <tag> junit </tag>
            
            <tag> tutorial </tag>
            
            <tag> unit testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RUN vs CMD vs ENTRYPOINT in Dockerfile</title>
      <link href="2017/09/26/RUN-vs-CMD-vs-ENTRYPOINT-in-Dockerfile/"/>
      <url>2017/09/26/RUN-vs-CMD-vs-ENTRYPOINT-in-Dockerfile/</url>
      
        <content type="html"><![CDATA[<p><img src="http://logo-logos.com/wp-content/uploads/2016/10/Docker_logo_horizontal.png" alt="docker logo"></p><p><code>RUN</code>、<code>CMD</code> 和 <code>ENTIRYPOINT</code>这三个<code>Dockerfile</code>指令看起来都很类似，很容易搞混。我们来通过一些实践来详细讨论一下它们之间的差别。</p><p>简单的说：</p><ol><li><code>RUN</code>执行命令并创建新的镜像层，<code>RUN</code>经常用来安装Docker image中需要的软件。</li><li><code>CMD</code>设置容器启动后默认执行的命令及其参数，但<code>CMD</code>能够被<code>docker run</code>后面跟着的命令行参数代替。</li><li><code>ENTIRYPOINT</code>配置容器启动时运行的命令。</li></ol><a id="more"></a><h2 id="Shell和Exec格式"><a href="#Shell和Exec格式" class="headerlink" title="Shell和Exec格式"></a>Shell和Exec格式</h2><p>我们可以用Shell和Exec两种方式指定<code>RUN</code>、<code>CMD</code>和<code>ENTIRYPOINT</code>要运行的命令，这两者在使用中有细微的区别。</p><h3 id="Shell格式"><a href="#Shell格式" class="headerlink" title="Shell格式"></a>Shell格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;instruction&gt; &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install python3</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello World"</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello World"</span></span></span><br></pre></td></tr></table></figure><p>当指令执行是，shell格式底层会调用<code>/bin/sh -c &lt;command&gt;</code>。</p><p>例如下面的Dockerfile片段：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> name Tony Deng</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello, <span class="variable">$name</span>"</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意环境变量<code>name</code>已经被值<code>Tony Deng</code>替换了</p></blockquote><h3 id="Exec格式"><a href="#Exec格式" class="headerlink" title="Exec格式"></a>Exec格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;instruction&gt; [<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>,...]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"apt-get"</span>,<span class="string">"install"</span>,<span class="string">"python3"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/echo"</span>,<span class="string">"Hello World"</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/echo"</span>,<span class="string">"Hello World"</span>]</span></span><br></pre></td></tr></table></figure><p>当指令执行是，会直接调用<code>&lt;command&gt;</code>，不会被<code>shell</code>解析。</p><p>例如下面的Dockerfile片段：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> name Tony Deng</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/echo"</span>,<span class="string">"Hello, <span class="variable">$name</span>"</span>]</span></span><br></pre></td></tr></table></figure><p>运行容器将输出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello, <span class="variable">$name</span></span><br></pre></td></tr></table></figure><blockquote><p>注意环境变量<code>name</code>没有被替换</p></blockquote><p>如果希望使用环境变量，可以这样来修改</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> name Tony Deng</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"echo Hello, <span class="variable">$name</span>"</span>]</span></span><br></pre></td></tr></table></figure><p>这样，容器将会输出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello, Tony Deng</span><br></pre></td></tr></table></figure><p><code>CMD</code>和<code>ENTRYPOINT</code>推荐使用<code>Exec</code>格式，因为指令可读性更强，更容易理解，<code>RUN</code>则两种格式都可以。</p><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p><code>RUN</code>指令通常用于安装应用和软件包。</p><p> <code>RUN</code>在当前镜像的顶部执行命令，并创建新的镜像层。<code>Dockerfile</code>中常常包含多个<code>RUN</code>指令。</p><p>安装多个包的例子：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    bzr \</span></span><br><span class="line"><span class="bash">    cvs \</span></span><br><span class="line"><span class="bash">    git \</span></span><br><span class="line"><span class="bash">    mercuial \</span></span><br><span class="line"><span class="bash">    subversion</span></span><br></pre></td></tr></table></figure><blockquote><p>注意： <code>apt-get update</code> 和 <code>apt-get install</code>最好放在一个<code>RUN</code>指令中执行，这样能够保证每次安装都是最新的包。如果<code>apt-get install</code>在单独的<code>RUN</code>执行，则会使用<code>apt-get update</code>创建新的镜像层，而这一层可能是很久以前缓存的。</p></blockquote><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD指令允许用户指定容器的默认执行的命令。</p><p>此命令会在容器启动且docker run没有指定其他命令时执行。</p><ol><li>如果docker run指定了其他命令，CMD指定的默认命令将被忽略。</li><li>如果Dockerfile中有多个CMD指令，只有最后一个CMD生效。</li></ol><p>CMD有三种格式：</p><ol><li><code>Exec</code>格式： <code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;,...]</code>这是<code>CMD</code>推荐的格式。</li><li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>为<code>ENTRYPOINT</code>提供额外的参数，此时<code>ENTRYPOINT</code>必须使用<code>Exec</code>格式。</li><li><code>Shell</code>格式： <code>CMD command param1 param2</code></li></ol><p><code>Exec</code> 和 <code>Shell</code> 格式前面已经介绍过了。<br>第二种格式<code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>要与<code>Exec</code>格式的<code>ENTRYPOINT</code>指令配合使用，其用途是为<code>ENTRYPOINT</code>设置默认的参数。我们将在后面讨论<code>ENTRYPOINT</code>时举例说明。</p><p>下面看看 CMD 是如何工作的。Dockerfile 片段如下：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello world"</span></span></span><br></pre></td></tr></table></figure><p>运行容器 <code>docker run -it [image]</code> 将输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>但当后面加上一个命令，比如 <code>docker run -it [image] /bin/bash</code>，<code>CMD</code> 会被忽略掉，命令 <code>bash</code> 将被执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@10a32dc7d3d3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p><code>ENTRYPOINT</code>指令可让容器以应用程序或者服务的形式运行。</p><p><code>ENTRYPOINT</code>看上去与<code>CMD</code>很像，它们都可以指定要执行的命令及其参数。不同的地方在于 <code>ENTRYPOINT</code>不会被忽略，一定会被执行，即使运行<code>docker run</code>时指定了其他命令。</p><p><code>ENTRYPOINT</code>有两种格式：</p><ol><li><code>Exec</code> 格式：<code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 这是 <code>ENTRYPOINT</code> 的推荐格式。</li><li><code>Shell</code> 格式：<code>ENTRYPOINT command param1 param2</code></li></ol><p>在为 <code>ENTRYPOINT</code> 选择格式时必须小心，因为这两种格式的效果差别很大。</p><h3 id="Exec-格式"><a href="#Exec-格式" class="headerlink" title="Exec 格式"></a>Exec 格式</h3><p><code>ENTRYPOINT</code> 的 <code>Exec</code> 格式用于设置要执行的命令及其参数，同时可通过 <code>CMD</code> 提供额外的参数。</p><p><code>ENTRYPOINT</code> 中的参数始终会被使用，而 <code>CMD</code> 的额外参数可以在容器启动时动态替换掉。</p><p>比如下面的 <code>Dockerfile</code> 片段：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/echo"</span>, <span class="string">"Hello"</span>]  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"world"</span>]</span></span><br></pre></td></tr></table></figure><p>当容器通过 <code>docker run -it [image]</code> 启动时，输出为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>而如果通过 <code>docker run -it [image] TonyDeng</code> 启动，则输出为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello TonyDengq</span><br></pre></td></tr></table></figure><h3 id="Shell-格式"><a href="#Shell-格式" class="headerlink" title="Shell 格式"></a>Shell 格式</h3><p><code>ENTRYPOINT</code> 的 <code>Shell</code> 格式会忽略任何 <code>CMD</code> 或 <code>docker run</code> 提供的参数。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>使用 <code>RUN</code> 指令安装应用和软件包，构建镜像。</p><p>如果 <code>Docker</code> 镜像的用途是运行应用程序或服务，比如运行一个 <code>MySQL</code>，应该优先使用 <code>Exec</code> 格式的 <code>ENTRYPOINT</code> 指令。<code>CMD</code> 可为 <code>ENTRYPOINT</code> 提供额外的默认参数，同时可利用 <code>docker run</code> 命令行替换默认参数。</p><p>如果想为容器设置默认的启动命令，可使用 <code>CMD</code> 指令。用户可在 <code>docker run</code> 命令行中替换此默认命令。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/" target="_blank" rel="noopener">Dockerfile: ENTRYPOINT vs CMD</a><br><a href="https://www.slideshare.net/abhishtomar/docker-43811773" target="_blank" rel="noopener">Abhishek Tomar在Slideshare关于Docker的分享</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> Dockerfile </tag>
            
            <tag> run </tag>
            
            <tag> cmd </tag>
            
            <tag> entrypoint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常见分支管理实践</title>
      <link href="2017/08/31/git-common-branch-management-practices/"/>
      <url>2017/08/31/git-common-branch-management-practices/</url>
      
        <content type="html"><![CDATA[<p><img src="https://wac-cdn.atlassian.com/dam/jcr:389059a7-214c-46a3-bc52-7781b4730301/hero.svg?cdnVersion=if" alt="git branches"></p><p>Git是目前最流行的代码版本管理系统，像<a href="https://github.io/" target="_blank" rel="noopener">Github</a>也被称为全球最大的同性交友网站 ;-) 可见Git在工程师人群中的流行程度。不过在使用Git时，经常会碰到一个问题，就是采用什么样用的分支模型进行管理，Git官方也提供了很多分支模型推荐（<a href="https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener">分布式工作流程</a>这篇文章有相应的记载）。</p><p>我们这次主要介绍三种常见的Git分支模型。</p><a id="more"></a><h2 id="单主干"><a href="#单主干" class="headerlink" title="单主干"></a>单主干</h2><p>单主干的分支实践（<code>Trunk-based development</code>,<code>TBD</code>）在<code>SVN</code>中比较流行。<a href="http://paulhammant.com/2013/05/06/googles-scaled-trunk-based-development/" target="_blank" rel="noopener">Google</a>和<a href="http://paulhammant.com/2013/03/13/facebook-tbd-take-2/" target="_blank" rel="noopener">Facebook</a>都使用这种方式。<code>trunk</code>是SVN中主干分支的名称，对应Git中则是<code>master</code>分支。</p><p>TBD的特点是所有团队成员都在单个主干分支上进行开发。当需要发布时，先考虑使用标签（<code>tag</code>）,即<code>tag</code>某个<code>commit</code>来作为发布的版本。</p><p>如果仅仅依靠<code>tag</code>不能满足要求，则从主干分支创建发布分支。</p><p><code>bug</code>修复在主干分支进行，再<code>cherry-pick</code>到发布分支。</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-git-mange/img001.png" alt="TBD中分支流程"></p><p>由于所有开发人员都在同一个分支工作，团队需要合理的分工和充分沟通来保证不同开发人员的代码尽可能少的发生冲突。因此持续集成和自动化是必要的，用来及时发现主干分支中的<code>bug</code>。因为主干分支是所有开发人员公用的，一个开发人员引入的bug可能对所有人造成影响。</p><p>不过好处是由于分支所带来的额外开销非常小。开发人员不用频繁在不同的分支之间切换。</p><h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><p><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">Git Flow</a>应该是目前流传最广的Git分支管理实践。</p><p><img src="http://nvie.com/img/git-model@2x.png" alt="git flow"></p><p><code>Git Flow</code>围绕的核心概念是版本发布（<code>release</code>）。因此<code>Git Flow</code>适用于各种版本发布周期的项目。</p><p><code>Git Flow</code>流程中包含5类分支，分别是<code>master</code>、<code>develop</code>、<code>feature</code>（新功能分支）、<code>release</code>（发布分支）和 <code>hotfix</code>（热修复分支）。这些分支的作用和生命周期各不相同。</p><h3 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h3><p><img src="http://nvie.com/img/main-branches@2x.png" alt="the main branches"><br>主分支是<code>git flow</code>整个分支模型的核心，它们有无限的生命周期。主分支分别是<code>master</code>和<code>develop</code>分支。</p><p><code>origin/master</code>分支应该对每个<code>Git</code>用户都很熟悉。与<code>master</code>分支并行，另一个分支称为<code>develop</code>。</p><p>我们认为<code>origin/master</code>是<code>HEAD</code>源代码生产就绪状态的主要分支。</p><p><code>origin/develop</code>是<code>HEAD</code>源代码反映下一版本的最新发展变化的状态的主要分支。也有人会称之为“整合分支”，可以基于<code>develop</code>分支定时执行每日构建的工作。</p><p>当<code>develop</code>分支中的源代码达到一个稳定点并准备被<code>release</code>时，所有的改变应该以某种方式合并回<code>master</code>，然后用一个版本号来标记。</p><p>因此，每次将更改合并回主数据库时，这都是定义的新产品发布。在这方面往往非常严格，所以可以使用一个<code>Git Hook</code>脚本来自动构建和发布软件到生产服务器。</p><h3 id="支持分支"><a href="#支持分支" class="headerlink" title="支持分支"></a>支持分支</h3><p>除了主分支以外，<code>git flow</code>还定义了三类支持分支，分别用于不同场景。这些分支都是有限的生命周期，最终都是会被删除的。</p><p>这些分支分别是：</p><ul><li>Feature分支</li><li>Release分支</li><li>Hotfix分支</li></ul><p>每个分支都有特定的目的，对于哪些分支是用于开发工作，哪些分支是其他分支的合并目标，都有严格的规定。</p><p>分支类型只是按照我们使用它们来进行的分类。从技术的角度来看，这些分支并不“特殊”的，它们也仅仅只是普通的Git分支。</p><h4 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h4><p><img src="http://nvie.com/img/fb@2x.png" alt="feature branchs"></p><p>从上面的图就能够很清楚的知道，<code>feature</code>分支可能来源于<code>develop</code>，并且只能合并回<code>develop</code>。</p><p><code>feature</code>分支（或有时称为<code>topic</code>分支）用于为即将到来的版本开发新功能。</p><p>当开始一个特征的开发时，这个特征将被合并到的目标版本可能在那个时候是未知的。 feature分支的本质是，只要功能处于开发阶段，它就会存在，但最终会被合并回<code>develop</code>（为了明确地添加新功能到即将发布的版本）或丢弃（如果是令人失望的实验）。</p><h4 id="Release分支"><a href="#Release分支" class="headerlink" title="Release分支"></a>Release分支</h4><p><img src="/images/blog/git-flow-release-branches.png" alt="release branches"></p><p><code>release</code>分支可能来源于<code>develop</code>，并且只能合并回<code>develop</code>和<code>master</code>。</p><p><code>release</code>分支主要用来产品发布的准备。<code>release</code>分支允许有一些小的bug修复和准备发表的一些配置或元数据(版本号，生成日期等)的修改和提交，在发布版本之前，在<code>release</code>分支上完成这些所有的工作。此时，<code>develop</code>可以继续接受下一个大版本的feature分支的合并。</p><p>在<code>release</code>分支建立之后，即将发行的版本才被分配了一个版本号。在创建<code>release</code>分支之前，<code>develop</code>分支只是反映了“下一个版本”将要有的变化，但是不知道这个“下一个版本”是否最终会变成<code>0.3</code>或<code>1.0</code>，直到<code>release</code>分支开始创建才能确定。正常来说，这个版本号确定的决定是在<code>release</code>分支开始的时候做出的，并且需要遵循项目的版本号规则。</p><h4 id="Hotfix分支"><a href="#Hotfix分支" class="headerlink" title="Hotfix分支"></a>Hotfix分支</h4><p><img src="http://nvie.com/img/hotfix-branches@2x.png" alt="hotfix beanches"></p><p><code>hotfix</code>分支可能来源于<code>master</code>，并且只能合并回<code>develop</code>和<code>master</code>。</p><p><code>hotfix</code>分支非常类似于<code>release</code>分支，因为它也意味着准备新的产品发布，尽管是无计划的。</p><p> <code>hotfix</code>分支是由于需要立即修复生产版本的<code>bug</code>而产生的。 当生产版本中的关键错误必须立即解决时，将会基于<code>master</code>来创建一个新的<code>hotfix</code>分支出来。</p><p>这时团队成员（开发部门）的工作可以在<code>develop</code>、<code>feature</code>、<code>release</code>分支中继续，而另一个人则在<code>hotfix</code>分支中解决生产环境的bug，紧急修复并上线发布。</p><h2 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h2><p><a href="http://scottchacon.com/2011/08/31/github-flow.html" target="_blank" rel="noopener">Github Flow</a>是<a href="https://github.com/" target="_blank" rel="noopener">Github</a>所使用的一种流程，它主要是依托于<code>git-flow</code>，并依托Github的<code>pull request</code>功能创建的分支模型和流程。</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-git-mange/img002.png" alt="Github Flow的分支流程"></p><p><code>GitHub flow</code>的好处在于非常简单实用。开发人员需要注意的事项非常少，很容易形成习惯。当需要进行任何修改时，总是从<code>master</code>分支创建新分支。完成之后通过<code>pull request</code>和相关的代码审查来合并回<code>master</code>分支。<code>GitHub flow </code>要求项目有完善的自动化测试、持续集成和部署等相关的基础设施。每个新分支都需要测试和部署，如果这些不能自动化进行，会增加开发人员的工作量，导致无法有效地实施该流程。这种分支实践也要求团队有代码审查的相应流程。</p><p>在<code>Github Flow</code>中，<code>master</code>分支中也是代表着稳定的代码。该分支已经或即将被部署在生产环境。</p><p><img src="/images/blog/github-pull-requests.png" alt="pull requests"></p><p><code>master</code>分支的作用是提供一个稳定可靠的代码基础。任何开发人员都不允许把未测试或未审核的代码直接提交到<code>master</code>分支。</p><p>对于代码的任何修改，包括<code>bug</code>修复，<code>hotfix</code>、新功能开发都在单独的分支中进行。不管是一行代码的小改动，还是需要几个星期开发的新功能，都采用同样的方式来管理。当需要进行修改时，从<code>master</code>创建一个新的分支。新分支的名称应该简单清晰的描述该分支的作用。所有相关的代码修改都在新分支中进行。开发人员可以自由的提交代码和<code>push</code>到远程仓库。</p><p>当新分支中的代码全部完成之后，通过<code>Github</code>提交一个新的<code>pull request</code>。团队中的其他人会对代码进行审核，提出相关修改意见。由持续集成服务器（如<code>Jenkins</code>）对新分支进行自动化测试。当代码通过自动化测试和代码审核之后，该分支的代码被合并到<code>master</code>分支。然后从<code>master</code>分支部署到生产环境。</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> branch </tag>
            
            <tag> scm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈传统企业转型互联网</title>
      <link href="2017/08/17/traditional-enterprises-transform-the-internet-pain/"/>
      <url>2017/08/17/traditional-enterprises-transform-the-internet-pain/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/traditional-enterprises-transform-the-internet-pain/change.png"><br>最近几年的确有很多原来传统行业的企业都在做一件事情，就是<strong>拥抱互联网</strong>。这些企业都希望能够进入这个在中国发展只有20年（1996年-2017年），但是却制造了太多奇迹和富豪的行业。尤其是国家全面提出了“互联网+”这个概念，所有的人都蜂拥而至，貌似如果再不和这个奇妙的“Internet”建立联系，就会被整个时代所抛弃。</p><p>我这几年也一直在一家传统医疗器械出身的互联网医疗公司负责产品和技术相关的工作，最近也和一些在类似从传统企业转型到互联网的老板们、管理者及员工聊在互联网转型过程中的一些事情，其中发现了很多共同的困境和痛苦。</p><p>下面就简单聊聊，我在这方面的一些思考。</p><a id="more"></a><p>传统企业进行互联网转型很多时候是这样的，我用一个故事来描述一下。</p><h2 id="卖袜子小贩的互联网造梦记"><a href="#卖袜子小贩的互联网造梦记" class="headerlink" title="卖袜子小贩的互联网造梦记"></a>卖袜子小贩的互联网造梦记</h2><blockquote><p>一个卖袜子的小贩，之前生意做的也不错，但是同一个市场上的卖内衣裤的小贩将他们的商品放在电子商务网站上面卖的非常好，一个月的利润翻了几番，大家都在报道卖内衣裤的小贩，说他引领传统行业转型互联网的潮流。<br>卖袜子的小贩很眼红卖内衣裤的小贩所获得的利润和名声，心想：“不就是将做一个买东西的网站，并且将商品放上去销售吗？多么easy的事情，我也能干，还能比那个卖内衣裤的小子做的更好，我不仅仅只是要将袜子放在网站上卖，而且还要自己做一个卖袜子的网站，让所有卖袜子的其他小贩也使用我的网站，创造一个伟大的袜子电商公司。”</p><p>小贩于是雇了一个写代码的做了一个卖袜子的网站。几个月之后，卖袜子的网站上线了，小贩的袜子也把他的袜子放在自己的网站上进行销售。<br>小贩认为有了网站，袜子就自然可以卖出去了，就可以是伟大的电子商务了，就可以收获到比卖内衣裤的小贩更大的利润和名声，。<br>写代码的也天天翻着Nginx、Java、MySQL、Redis等等一系列技术文档，朝着一个伟大的电子商务网站的方向努力。</p></blockquote><blockquote><p>网站上线之后，小贩天天等着人来网站上买袜子，然而并没有人来这个网站上买袜子。<br>然而，这个伟大的电子商务网站，并没有给小贩带来想象中的收益，更别提名声了。</p><p>小贩就觉得应该是网站上的功能并不够吸引人，于是让写代码的加着或者抄着其他网站各种奇怪的功能。写代码的也一味听着迎合小贩的想法，并且痛苦的实现着小贩的各种功能。</p></blockquote><blockquote><p>过了几个月之后，小贩发现他这个卖袜子的网站依然没有给带来想象中的收益，反而是由于他将之前的积蓄和大部分的精力投入到网站建设中，他原来在市场上的销售下降了，马上就面临资金链断掉的问题。<br>小贩思考良久，将所有的问题都推到写代码的身上，因为别人也是在网上卖内衣裤，卖的就非常好。但是他的卖袜子网站就没有人光顾，肯定是写代码的做的网站不够好，不够吸引人。<br>于是他愤愤炒掉了那个写代码的，心痛的关掉了网站，感叹着“都是这个写代码的没有做好，害的我赔了夫人又折兵。互联网是一个吸血狂魔，以后一定要离它远远的。”</p></blockquote><h2 id="卖袜子小贩故事后面的思考"><a href="#卖袜子小贩故事后面的思考" class="headerlink" title="卖袜子小贩故事后面的思考"></a>卖袜子小贩故事后面的思考</h2><p>上面这个卖袜子小贩的故事，大家发现了一些什么问题吗？</p><p>小贩是业务的主导，在他的眼中，写代码的是小贩用来生产网站的工具。小贩可能很懂得如何在他之前市场中如何销售袜子，知道来市场上买袜子的人要什么，他以为将袜子简单的放在网站上就可以轻松的将袜子卖给更多人，但是这些买袜子的人怎么来？这些人在哪儿？原来的市场和网站之间的关系和差异是什么？这些都问题他都不了解。结果可想而知，这件事情肯定是以失败而告终。</p><p>小贩和写代码的失败的原因就是业务和工具没有结合。小贩只是看到了卖内衣裤的成功案例，并不了解网站是一个什么样的工具？现在是否有一些什么样的工具可以把他的袜子展示更生动，更加吸引顾客来购买？不清楚如何通过什么样的推广方式，让更多人了解到可以在他的网站上可以购买到适合的袜子？</p><p>硅谷最近这几年更愿意投资公司的合伙人模式基本上都是“企业家+教授”模式，因为世界上任何一个成功的公司，尤其是互联网公司，背后一定是<strong>一群既懂得运营，又明白如何利用技术的业务和一群懂得驱动业务的技术大神们的故事</strong>。上述的组合其实指的是业务（商业）和工具（技术）要很好的结合，才能产生颠覆行业现状的新产品。</p><p>传统行业与互联网结合本质上来说是对原来行业的其他公司进行一个<strong>升维攻击</strong>，把原来这个行业大家血腥厮杀的战场从传统战场转到互联网战场，但是不同的战场就好比不同的世界，参与者必须要了解这个世界的运行规则，要不然还没有开始战斗就会在这个新世界中“水土不服”。</p><h2 id="互联网本质"><a href="#互联网本质" class="headerlink" title="互联网本质"></a>互联网本质</h2><h3 id="互联网不是什么"><a href="#互联网不是什么" class="headerlink" title="互联网不是什么"></a>互联网不是什么</h3><p>既然要和互联网结合，那互联网本质是什么？<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E6%9C%AC%E8%B4%A8" target="_blank" rel="noopener">百度百科</a>上也有很多大佬们给出相应的解释。</p><p>但我想，互联网不只是搜索、下载、游戏、电子商务、社交网络、移动终端、可穿戴设备、智能家居……这些只是互联网产品。</p><p>也不是只有自由、分享、开放、免费、痛点、体验、参与、去中心化、颠覆传统、持续创新……这只是互联网精神。</p><p>甚至也不是生态系统、个性定制、快速迭代、云计算、大数据、人工智能……这些知识互联网技术。</p><p>互联网，起于信息，基于计算机网络技术，创造了互联网产业，深刻的改变了社会的方方面面，但这背后，应当有某种更本质的东西造就了这一切。</p><h3 id="回顾过去"><a href="#回顾过去" class="headerlink" title="回顾过去"></a>回顾过去</h3><p>游牧时代 -&gt; 农业时代 -&gt; 工业时代 -&gt; 信息时代，这种划分标准是产业形态，产业是人类社会的根本。</p><p>农业时代以动植物养殖技术获得比游牧时代更稳定的食物来源。<br> %&gt;%<br>工业时代利用了机器和化石能源，创造出大工业，制造出农业社会所不能想象的无数产品。工业一直在改造农业，如果有一天工业生产用人工合成物取代了动植物产品，则农业将会消亡。</p><p>信息时代（互联网时代） 目前看来是以信息为生产对象，算是第三产业服务业的一部分。这本不该是什么巨变，自古人类社会就有信息的流通网络。然而计算机信息居然极大改变了世界，影响了工业和农业以及大量的服务业，独自成为这个时代的标志。</p><p>而且，如同农业吞并牧业，工业改造农业，互联网也对工业进行改造，虽然刚刚开始。</p><h3 id="互联网本质是人脑的延伸"><a href="#互联网本质是人脑的延伸" class="headerlink" title="互联网本质是人脑的延伸"></a>互联网本质是人脑的延伸</h3><p>我想，互联网的本质应当来源于人的本质。</p><p>意识和物质世界的二元对立，是人类眼中的世界最大的对立。</p><p><strong>人的本质就是大脑中意识</strong>。思想，灵魂，精神，自由意志，自我意识，也可以认为是一种程序软件。有些科学家认为，人类的意识就是人脑中的程序，换一个类似人脑的电脑载体，把程序拷进去，人依然还是人。</p><p>人的本质就在于灵魂，灵魂就是算法和信息。</p><p>人脑的意识通过感官获取信息，通过信息进行思想，意识也是一种信息。而互联网最基本的功能就是传递信息进入大脑，因此，信息互联网就是人脑的延伸，正如机器是身体的延伸。</p><p>而且，同样为信息而生，互联网和人类的大脑非常像，人脑内部的神经网络就仿佛一个互联网，神经元的联网形成了人的自我意识，人和人的联网形成了社会，电脑和电脑联网形成了现在的信息互联网。科学家已经在模拟人脑了。见 <a href="http://www.guokr.com/article/403444/" target="_blank" rel="noopener">Spaun：最逼真的人工大脑IBM:用超级计算机模拟人脑</a></p><p><strong>互联网的本质就是对人脑的延伸，从内容到形式都是。</strong></p><p>从整个社会发展的过程来看，<strong>社会发展的趋势是追求生产力的高效和强大</strong>。 追求生产力的高效和强大必然会要求产业和社会的协调统一，互联网就实现人类社会协调统一的重要工具。</p><h2 id="互相抱怨的农夫和铁匠"><a href="#互相抱怨的农夫和铁匠" class="headerlink" title="互相抱怨的农夫和铁匠"></a>互相抱怨的农夫和铁匠</h2><p>我们再来看另外一个农夫和铁匠的故事</p><blockquote><p>农夫拿着铁匠打造的镰刀年复一年的收割庄稼，农夫不停的对铁匠提出关于镰刀的需求，“不够锋利”，“再做大一点”，“做长一点”等等。铁匠也在每天不停抱怨需求不合理，“你根本不懂镰刀是怎么打出来的，还没有磨快，就叫我打大一点，你到底想怎么样？”。</p><p>但是，铁匠还是每天在敲打这他的铁锤打着那把镰刀，抱怨多于思考。铁匠更多时候想的是换一个农夫，去给另一个农夫打镰刀，可能会不被挨骂。</p><p>而农夫依然在用者他的那把镰刀不停的收割庄稼，心里想的永远是要把铁匠换掉。因为他觉得是他收割的粮食养活着这个铁匠，但是铁匠却不能给他提供更好的镰刀，让他在收割庄稼时能够省点力气，费力、费时又费钱，挺不靠谱的。</p><p>这样日复一日，年复一年，农夫和铁匠一直这样互相抱怨、互相“折磨”的收割庄稼、打造镰刀。镰刀是越来越大，需要收割农田也越来越多，两人都累的要死。</p></blockquote><blockquote><p>终于有一天有人开来一台收割机，此时农夫和铁匠只能在旁边看着这台收割机一天之内，把他们需要一个月收割的农田都收割完了。他们目惊口呆，互相望了一眼，异口同声的说，我们之前怎么没有想到这个东西？当他们现在想到了这样的工具和收割方式，但是农田已经和他们没有关系了。</p></blockquote><p>这个故事虽然比较简短，相信大家也在这个故事中看到了一些东西。</p><h2 id="农夫和铁匠故事的思考"><a href="#农夫和铁匠故事的思考" class="headerlink" title="农夫和铁匠故事的思考"></a>农夫和铁匠故事的思考</h2><p>从故事上看，是收割机淘汰了这名农夫和铁匠。那我们来分析一下，收割机是怎么出现的？农夫每天的工作方式有没有可能提出一个要收割机的需求？正常分析来说不可能，因为他每天最核心的工作是在和庄稼的较量，更懂得是庄稼如何生长的，但并不会像镰刀怎么造出来的，也不会去弄明白使用镰刀是不是最合理的收割方式（当然，如果这个农夫见过收割机就另当别论，但是可能只是逼着铁匠打出一个很像收割机的镰刀而已）。</p><p>每天打造镰刀的铁匠可不可能做出一个收割机呢？也不可能。因为他每天的核心工作永远是锤子和铁，并没有关心锄头被怎么使用，也不知道庄稼是如何被收割的。</p><p>但是如果他们是互相渗透合作，倒是有可能做出收割机。可是实际上，从农夫的角度认为铁匠只是给他造工具的人，他自己才是一切。从铁匠的角度，农夫只是一个每天折磨他的魔鬼，让他不停的敲打这把锄头，而且他本身也忘记了做这个锄头的目的是什么？只是一味的迎合云顶的要求，没有更多的思索。此时铁匠只是农夫的一个工具，这就好比<strong>农夫是业务，铁匠好比技术</strong>。此时两者都是失败者，因为生产力的革命是不会停下来的，总有一天会有另一帮人带着更先进的方式来接替他们的工作。</p><p>当然，有人可能会说，农夫为什么不给铁匠更多时间去思考，提出更合理的需求，更平等的地位，但是这真是问题的全部吗？仔细想想其实不然。农夫只是一味的想着用<strong>已知的方式</strong>收割庄稼（就是那把镰刀），并不懂镰刀是怎么做出来的，更不懂如何换一种方式去收割庄稼。</p><p>那这样看<strong>农夫不是一个好业务</strong>。他没有合理的重组和整合资源。</p><p>我们在来看看铁匠，是不是这个铁匠只是遇到了一个不懂事的农夫，而没有造出那个收割机？我觉得也不仅仅是这样，因为他也从来没有想过农夫是怎么来收割庄稼，镰刀是不是收割庄稼最好的工具。</p><p><strong>铁匠也不是一个好技术</strong>，因为他没有真正的运用好、制造好工具。</p><blockquote><p>其实最可怜的是那个镰刀，它只是一个原始的工具，永远没有进化的机会。</p></blockquote><h2 id="传统企业如何和互联网结合？"><a href="#传统企业如何和互联网结合？" class="headerlink" title="传统企业如何和互联网结合？"></a>传统企业如何和互联网结合？</h2><p>对于传统企业来说，互联网本质上就是一个工具。</p><p>通过农夫和铁匠的故事分析，可以大概明白了，业务、技术、工具三者之间的关系：<strong>业务与技术充分合作，制造出了工具，并在过程中不停升级进化工具，这样最终提升的是生产力，并在生产力的推动下，不停革着旧生产力的命</strong>。</p><p>这样生产力的革命电费原有行业的例子还有很多，比如之前通过电话来叫出租车，这样的平台也很多，也活的很好。业务每天经营着他的电话，技术支撑着这个电话系统，其乐融融。但是在各大打车应用大行其道的今天，这些电话叫车的平台又在哪里？</p><p>还有几年前有很多饭店也在做自己的订餐网站，自己送的并不快的外餐。一样在各大外卖平台的今天，这些小订餐网站去哪儿了？</p><p>无不证明了一件事情，一个行业通过与技术的结合，产生的具体生产力正在颠覆着这个行业。</p><p>而传统企业希望和互联网结合的目的也是为了通过互联网这样的一个新的技术和工具来颠覆原来行业，那就要考虑好传统业务如何和互联网技术整合，那必须要有一群懂的传统业务，同时也懂得互联网如何来运营、如何来工作的人，一起紧密结合来共同创造一个新的生态体系。</p><p>比如我们来看看淘宝，淘宝真正的业务是淘宝的产品团队做的平台系统规划和实现。各个淘宝的店主正在这样的技术和业务之上做着他们的业务。微店等大量的平台级的应用也是如此。</p><p>真正的技术和业务并不是小贩和他的程序员们，而是构建这个平台后面的技术和业务们。试想一下，如果这样的大平台是用这样的小贩和他的程序员们的方式可以做出来的吗？这不正是技术加业务提升了生产力之后对原生产力的革命吗（农夫铁匠的故事也是一样）？</p><p>所以，在我看来，传统企业和互联网结合其实是一个已经成型的企业如何拥抱新的技术，新的工具的过程，是这个企业持续迭代的过程。<strong>任何一个产生生产力革命的行业一定是由业务和技术结合而产生的，但是革命之后也许有可能又回到新的“农夫和铁匠”的故事中</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转型 </tag>
            
            <tag> 互联网 </tag>
            
            <tag> 创业 </tag>
            
            <tag> 产品 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理者的六项关键能力</title>
      <link href="2017/05/07/six-key-ability-of-managers/"/>
      <url>2017/05/07/six-key-ability-of-managers/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/six-key-ability-of-managers.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在国内的程序员圈子里面流传着一句经典名言：“程序员干不过30岁”（可能现在已经将这个年龄推迟到35岁）。这句名言行内的人大部分人都听过，字面上的意思大家应该都明白，说的是在软件开发领域里面，如果到一定年龄之后，如果你还是在做单纯的编码工作的话，发展空间就不大了。所以行业内的很多年轻人，在入行的时候，就有一个目标，“我要在做几年程序员之后，一定要做管理者或者转到其他职位”。在网上相关问题也是一搜一大把。</p><p>这句话，我其实还想引申到其他行业和职位上，貌似大家都会觉得当年龄增长之后，只有当上管理者之后，才算是一个顺利的或者说是安全的职业发展。</p><p>今天在这里，我先不谈所谓的国人的“官本位”思想，也不撒鸡汤来鼓吹“有技者，事竟成”，只是和大家聊聊我对管理的理解，以及对管理者需要具备的关键能力的理解。</p><p>希望大家能够在本文中看到管理应该是怎么样的，以及管理者应该是怎么样的，并且和自身对照，看看自己是否真的适合走这条道路。</p><a id="more"></a><h2 id="管理者的六项关键能力"><a href="#管理者的六项关键能力" class="headerlink" title="管理者的六项关键能力"></a>管理者的六项关键能力</h2><p>多数人都面临过做管理还是做业务的选择。很多人都想在管理上有所尝试，有的人进入了管理通道，但发展并不顺利。企业为了扩张发展而绞尽脑汁、不惜代价地培养管理者，可他们面临的最大困惑是，到底更适合带来一个团队前进?</p><p>作为一个进入职场15年的互联网人，伴随着整个互联网行业的发展，我也从一线工程师一步步到现在负责公司整个产品、研发、测试、运维多个部门的CTO，见过非常多的管理者和想晋升管理岗位却不知该如何来走的员工，其中不乏优秀杰出的管理者，也有表现一般的管理者，还有一些不合格的管理者。我一直在观察和总结，如何判断一个人是否具有管理的能力和潜力?</p><p>下面是我总结出来的管理者需要具备的关键能力，大家可以看看这些能力是否你已经具备。</p><h3 id="一、抓重点，思路清晰"><a href="#一、抓重点，思路清晰" class="headerlink" title="一、抓重点，思路清晰"></a>一、抓重点，思路清晰</h3><blockquote><p>抓重点是指能快速地将纷繁复杂的各种表面现象归纳总结为结构清晰的事物特征，抓住事物的根本、问题的关键，并确定工作重心的能力。</p></blockquote><p>管理工作涉及到的环境和对象很复杂，范围越广规模越大，复杂度就成几何级数上升。所以“抓重点”是管理者必须具有的第一项能力。</p><p>抓重点能力弱的管理人员，在工作上表现上往往是没有主见和工作思路，左右摇摆，拿不定主意，力气使不到点上。</p><p>他可能很努力、很辛苦，团队成员跟着他不停地东奔西跑，但基本上是瞎忙活，因为没有结果和成绩。</p><p>古人说“将帅无能，累死三军”就是指这种情况。</p><p>时间一长，团队成员就会失去对管理者的信心，这时候必须更换管理者了。</p><p><strong>那如何来判断一个人抓重点的能力呢？</strong></p><p>首先看他的思维是否具有结构性，能否对较为繁杂的事物进行归纳和分类，其次判断他的分类标准和原则是否正确，与解决问题的方向是否相符。</p><p>前者比较容易判断，但往往被人们忽略，第二个方面则需要具有一定的行业或管理经验才能判断他的分类原则是否准确可行。</p><p>我在很多面试或晋升管理者的场合，一般都会给应聘者3-5分钟时间作自我介绍和对目标岗位的理解，有的候选人时间过半了还在报流水帐式地介绍自己的工作经历，</p><p>如果是这样的介绍，我对这样的人基本上会做出否定判断，因为他抓重点的能力很差，对管理者来说，抓重点这个能力可以实行一票否决。</p><p>如果你想成为一个优秀的管理者，需要训练自己结构化的思考能力，简单地说就是归纳、概括和总结的能力。</p><p>普通人关注的是思维的逻辑性，讲的是前后的连续性和流畅性。而管理者需要具有较强的结构化思考能力。</p><h3 id="二、强烈的目标导向意识"><a href="#二、强烈的目标导向意识" class="headerlink" title="二、强烈的目标导向意识"></a>二、强烈的目标导向意识</h3><blockquote><p>结果导向也就是目标导向，是杰出管理者最突出的思维特征。</p><p>管理是为了达成目标，而且是团队或组织的目标，不能达成预期目标的管理者一定不是好的管理者，优秀管理者一定是目标感很强的人。</p></blockquote><p>目标导向意识就是以终为始，高度关注和聚焦目标和结果，将团队或组织的核心资源、策略都指向目标的达成，所有行动都必须是对目标达成有高度贡献的。</p><p>这种管理者给外部的印象就是目标清晰、执行力很强。</p><p>之所以目标导向特别重要，是因为有很多人出发的时候有目标，在路途往往忘了或偏离了目标，或者被一些新鲜的、好奇的事物所吸引，或者是因为碰到了困难、挫折、受了苦或委曲，放弃了既定的目标。</p><p>优秀管理者设定目标的时候很慎重，一旦确立了目标，就会坚定不移、不受任何干扰的向着目标前行，直到达成为止。</p><p><strong>专业技术人才向管理者转型的时遇到的最大障碍就是结果导向思维模式的建立。</strong></p><p>因为长期的技术工作训练了专业技术人才的技术思维方式。导致专业技术人员的思维和管理人员的思维方式有根本的不同。</p><p>专业技术人员的思维是直线式思维，由始到终，就是从已知条件推导出结果，一旦已知条件项缺少时，就无法推出结果，他们就会很焦虑。把这种思维带到管理中，最典型表现的是他们会跟上级要求很多条件，因为在他的思维中是只有当条件足够时，才能得到结果，而当结果没有达成时，他们给出的理由都是上级给的条件不充分或者环境改变、对手太快，责任不在他本人。</p><p>而管理者是结果导向的思维，以终为始，从目标开始考虑需要什么条件，然后主动想办法去创造条件从而达成问题的解决，技术思维者往往是被动的等待条件成熟。</p><h3 id="三、发现规律，预测结果"><a href="#三、发现规律，预测结果" class="headerlink" title="三、发现规律，预测结果"></a>三、发现规律，预测结果</h3><p>在当今快速变化的时代，管理者所面对的环境瞬息万变，要求管理者能够快速做出判断，也就通常说的要具有快速反应、灵活应变的能力。</p><p>快速灵活应变只是一种行为表现，其背后的能力是什么呢?</p><p>实际上是管理者善于并快速发现事物的运行规律并能够对事情的发展结果进行准确预测。如果不能把握事物的运行规律并做出准确预测结果，就容易做出错误的判断，影响管理目标的达成。</p><p>在同一家企业，为什么有的团队的运转节奏快、效率高，有的团队的运转节奏慢、效率低，其背后十有八九的原因是这两个团队的Leader他们在发现规律和预测结果的能力上有差异。</p><p>此项能力弱的管理者，他为了做出正确的判断，就需要做大量的调查、研究、查资料、开会、讨论，团队Leader决策效率的下降带来整个团队的工作节奏下降，工作效率降低。</p><p>有的人将这种能力称为直觉，即不需要思考就能判断的能力，并认为是天生的能力。</p><p>从表面观察看，直觉思维很强的人在紧急情况下快速判断，似乎是没有经过思考，当我们对他的决策过程进行深入分析时，就会发现他们的大脑中实际上存储了有关事物运行的基本原理、原则等相关概念，他们提取的速度很快，使我们感觉不到他的思考过程。</p><p>这种能力强的人有一个共同的特点，就是他们知识面比较广，而且这些知识是经过整理以后以他自己的方式存储的，所以提取和加工起来很快。</p><p>要练就这种能力，必须要加强学习，不是简单的死记硬背一些知识，而是以自己便于记忆和提取的方式进行学习。这种能力也是可以培养的，是靠知识和经验的有效积累。</p><p><strong>优秀的管理者他们的思维具有很强的辩证思维的特征。</strong></p><h3 id="四、格局与大局观"><a href="#四、格局与大局观" class="headerlink" title="四、格局与大局观"></a>四、格局与大局观</h3><p>有些人工作后很快就走上基层主管岗位，他们雄心勃勃，非常努力，表现很好，执行力很强，任务完成也不错。但当他到了中层岗位后，尽管做得很努力很辛苦，业绩反而会往下走，要么苦苦支撑，要么被撒换掉。</p><p>我分析了很多这样的人，发现他们有一定共同的问题，就是大局观不够。</p><blockquote><p>大局观指能够全面地、系统地、前瞻性地看问题、思考问题，能够从整体上把握事物发展的趋势和规律。</p></blockquote><p>具有大局观的人，一般都会站位比较高，能够从高处俯瞰事物，视野开阔，能够看到事物的全部，在思考时遗漏就很少，决策的错误就会减少。</p><p>缺乏大局观的人往往会只抓住眼前或局部一点猛攻，但常常顾此失彼，对于公司和上级的战略意图，他们难于理解，要么简单执行，要么曲解打折扣地执行。</p><p>具有大局观的人具有很强的历史观，他们往往能够从历史的角度来分析事物的发展演变规律，具有历史观的人看问题具有穿透力，够看到未来，从而具有前瞻性。</p><p>自我中心主义、私心、小九九是制约一个人大局观的重要因素，要培养大局观，就要把个人的小我和私心放下，把个人的利益放到一边，视野才会变得开阔，全局观就会提高。</p><p><strong>大局观决定一个人层次，而决定一个人大局观的是他的志向。</strong></p><h3 id="五、突破常规"><a href="#五、突破常规" class="headerlink" title="五、突破常规"></a>五、突破常规</h3><p>多数人都能想到的方案、通用做法都属于常规办法。</p><p>当然，一种思路或办法能够成为常规，说明这个思路和办法对解决问题是有一定效果的，至少在过去是有效的，否则它不会成为常规。</p><p>但是，当新问题出现或问题中新元素越来越多的时候，常规思路和方法就会开始失效，而且效果就会越来越差，必须另辟蹊径才能有效解决问题。</p><blockquote><p>突破常规是指管理者在面对复杂棘手的问题时，常常以不寻常的思维方式提出一些意想不到的观点、策略和措施，而且这种思路和办法是有效的、能够切实解决问题。</p></blockquote><p>判断是否突破了常规，有两个基本标志。</p><ol><li><p>新颖性，别人没有做过的，或者说在已知的圈子里没有人这么想或这么做过，这是基本点。</p></li><li><p>有效性，就是用这种方法比其它已知的方法都有效得多。</p></li></ol><p>真正高水平的突破常规往往能够做到奇效，即指构思精巧，抓住了关键环节和杠杆点，具有四两拨千斤之力，投入少，产出大，一题解则百难消，令人赞叹和称奇。</p><blockquote><p>突破常规并不是别出心裁、为求新而求异。</p></blockquote><p>我们不能忘了管理的根本任务是面对事实、解决问题，达成目标，所以有效性是第一原则。</p><p>突破常规也是有底线的，就是法律和道德伦理的底线。那些踩红线、打擦边球的做法并不是突破常规的思维，而是侥幸心理。</p><p><strong>突破常规就是不走寻常路，从思维特征上看具有逆向思维、发散思维的特点。</strong></p><p><strong>那些爱思考、善于总结、不盲从的人突破常规的能力较强。突破常规是建立在对事物规律和人性本质的深刻洞察之上，它与投机取巧、耍小聪明是有根本差别的。</strong></p><p><strong>突破常规需要开放的心态，一个封闭的，自我保护很严的人，是不可能提升这项能力的。</strong></p><h3 id="六、创设沟通平台"><a href="#六、创设沟通平台" class="headerlink" title="六、创设沟通平台"></a>六、创设沟通平台</h3><p>沟通能力对处于现代开放社会在成员来说十分重要，每个人都在不断提升自己的沟通能力，管理者也不例外，只能是要求更高。</p><p>但是人们通常所说的沟通能力主要是指人际沟通能力，市面上绝大多数的沟通培训课程也都是为了提高管理者的人际沟通能力而设计的。</p><p>对一个组织来说，管理者的最大价值是能够做出正确的决策，指明前行和胜利的方向。</p><p>因此，必须使管理者的意图、思想、决定得到准确的理解和彻底的执行，否则，管理者所具有的思维优势、判断决策优势就没有意义了。</p><p>所以，对于<strong>管理者来说，仅有人际沟通技能是不够的，因为人际沟通的效率和范围是有限的，在组织规模扩大后，他必须具备很好的管理沟通能力才能管理好组织，我们把这种能力称为创设沟通平台的能力。</strong></p><p>组织规模越大，管理层级越高，对这个能力要求也越高，即使在组织扁平化、团队小型化成为流行趋势的今天，这种能力要求也是越来越高，因为你的沟通不仅限于你的团队内部，团队外部沟通会越来越多，当你的决策涉及到很多部门、很多地区、很多管理层级、很多人员时，仅有人际沟通能力显然是不够的。</p><blockquote><p>所谓沟通平台，简单地说就是建立沟通的机制、渠道和制度。</p></blockquote><p>在一个正式组织内部，都有一定的沟通渠道和机制、制度，但当你做出一个新的决定时，可能原有的渠道和机制不起作用了，或者，它的效率和效果达不到你想要的要求，这时候，你就要创设新的沟通平台来畅通信息的渠道。</p><p>创设沟通平台时，首先必须明白你的决定需要告知的对象，这些对象的链条有多长，现有渠道的弱点是什么，用什么方式可以打通，而且让这种沟通成为一种机制。</p><p>比如，周会制度，晨会制度，联席会议制度等，这些都是比较好的管理沟通平台，遗憾的是很多管理者对此认识并不深刻，没有认识到会议的沟通价值，当然，必须是有效的会议。</p><p>要使会议有效则需要会议管理的技能。沟通平台绝不仅仅限于常规的会议方式。</p><p>管理者还要熟悉各种管理沟通工具，包括现代移动互联通信工具如微信等等。</p><h2 id="组建管理团队的建议"><a href="#组建管理团队的建议" class="headerlink" title="组建管理团队的建议"></a>组建管理团队的建议</h2><p>当然，在现实中，六个方面都很强的人很少，多数人可能是在某一或某几个方面具有较强的优势，所以在一个公司里面管理者团队搭建的时候最好能够完成以上六种能力的组合。</p><p>这样，你会发现和这样的团队一起工作是已经非常幸福的事情。</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> management </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Plantuml介绍以及在Hexo中的相关插件</title>
      <link href="2017/04/14/hexo-plantuml-diagram-plugin/"/>
      <url>2017/04/14/hexo-plantuml-diagram-plugin/</url>
      
        <content type="html"><![CDATA[<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAa4AAAB1CAMAAAAhpfXwAAACkVBMVEX////m5ubp6enZ2dns7Oz39/cAdL2GESz7+/vh4eHKytScnJyxsbnc3NzBwcPk5OTx8fHU1NSzs7PqvQDGxsa6urrNzdHFxcu+vsXn7O5HFGP6vYzKysqsrKyUlJQ8h+QAb742fd33snry7Ofty7MxdtgogeQtcdX/ewCLi4vxgwAWV8XruJ6AABcgXccoatDzwwDk29ZTec3nwKveWwDAmgDlxrZiAFAuAFLe5+zj083sv6Twso35pUZGCmTo2tJ7AAD5oj7/egDzvpb4q1zbdET85+fwpncAS4f5sm7csQDxgQCIACR+ABDx03br0sTZfVT34Mz57Mh2dnbzmJjk0dUAU4b3mlz74eH0pqZRWmMoXaXeqZUAICEuaLgADCkAAAA9QxJ1pbjbhmXcl30APXOqeWY2IQA3UXtvlbdRWnvhbSCAbRA7MQ3bbC/hVQD8nlETPVzniE92UguofzvnbQpdQhmSbTOHf4jxqHw4Y57viEA1SVwAOWVlBiAyDEEaI4MJJ2FaLFG7I5fdALLuZLJnBjtNMjlkVFdtOCdZLTDzkxOmGonvALuyz7dKR1dRR5MXH0gsSUu7GE6QLSB/JjAzQTDBLI6+2KJ0Zr47a46JADpiBBmkLn24lYKLeDOdebEqGjR0Xy55PUY+LVX446O7jZVWRWfYZJAARsG+ORW9f1ZwIAgmBB/ckVFwMQCPSACZSBhhP3c5LTvzzle1U2CUUG+DXH9falOSYFP23I3BTQC8cB/EoIDqMjPwgIDrQ0T3wcHnAACiklxXICtgTE9blGsRPiWCy5e1qjWihhhYUQp3CWBPG0VDVDS0Vpqvv1/dY3Wvd4DNmi3Jpquqm7QPZjhWL2/FbBxZJj/Ss3OvCR/gAAAWtklEQVR4nO2dj5/b5H3H9cNOLC6yJJ8N6CJfkovD/UD5IXxR7mxziu9yMYmvKNwlc0g81u0OujbsLiRL12sobNAFiunCfoR1BUr52bF2pCOBUChQKG02NlgHdKz7a/Y8jyRbsn5YtnWO93r5wwvHvtM9+uj7fh49P/SVjGE9/f9WxE3X2lhP9YqEaE6Iu4gjesS6SREmHicJ1k2JGNPj1T1ihXg4whJuCiW4GNXj1S1io1SEwN1FJLger65RRKDCHrA0XJ3itb8TO2lZ3eCOiUc8aQFcZMd4vd+BfbSuLnAXibOhRrhorlO8Dq/9LtpQF7hjow0aF8RFdojX0S4IiLv2v3etHWAYLnj0XIyEcFEd4hV+F8O2ru0u2lDk3S7ovSiO9WhYSzzExdAd4RX+YP/RO9dyB20p8i5wd83HxzTt0XXxJxEunOoIrw/2v9/FJ8N3j77fBSdD0hNXnoK4CKYTvA4fxt5ds8Lb1p3vdYU7T1yZPOq7QngneL139Ogv1qrs9nX4/f3djovP7QMnQzzBhogqsBizVk5Av/XB0bUqvG1Bd10w7yJJV1xEZmwG9V2cABSPR6MJoFh4rawcxg53Qe/gpsPYnb+41h68cBH42VvRG4pEopFC0dCaeTm6v4uHGtjRcBdUJldcBLWcV3nbj8NriAvr3nMh1NFrPox3x8VnTuTRqZDHpY7h6qmRXHDx8pn8xkkAK7NUZiiT2ATRNVkBrukK19wZ1Jq4c8bFLxXzM5MELy8fAoOLpEmJ0RgYc0DFBTroUUcTBxIJUeZ0hahZcQFfC2DNlBnGLckUVntk63FzxMUvVvIpnpdm3/4Bh7NhJHtSAJkUguUVW4j63DKCo3QFF2PheIwOnldiIeF3U5ZLcIybO5ZIRtlWTTjh4mfzYJTBy2//GMfAnMstKYATEoHy6hvtGx30tWVYiLMRFl0Cd3QW5WJk0LySwN2ory0jeIKOhEOu9qhEvGVeDrhA26qoPCG//Q7msfyLE4LABclrdLAPaMHHgYTjZMTrIh1KVwiY16Dmzs84i0qEveKGkwku2iovkqs/cEIdg2NC5sQ7mFcKB8IVIK++JIwHeG24ZYTjvK/RaekKgfKK9WnufLSvUMKzLiFcXDTRGi87Lj6Xr4BDTv+8wV4RruB4Jb+5AKtvonEHQSQwT2NGukKQvGLrkLtYY3eReMizbQFcUbJlXqTtehe/sQKXCt+RvTNuAC6ODJBXcvO6Y7EFDos12jAi4A3ioV//DpJXDLkTGrvDQg0vzyNcLfKyty48BXEx72xtlMMhcHSAvACudfeDrqFhQMIJP+kKAfMCuNbdR/lwh5F0g8qEk3EUt3grvOytC+dPjuE4nfQKimTgCo4XxPV7mI+AhOKo2bumserpCsHyivl1F4mznj0+wkWRrfJywIUrY2WejHng4nMIF0kFyMs3LlyAjqnr3UTq6QqB8vKPK9qgD0G46FZ5OeHisyMMmfDYLT8jExAXEyAv37gY5Jjc4KYbCD1dIUhevnE1PlXjpMC0zMsJFxhtnKK9cWV5gIvGqeB4NYmL4txEVtMVAuQFcd3mx50vXNW4Nc3LERfOr5Y9cZ1MIVwgKk3yqs6qbBOYJnF5qZqu0CyvZNVd/d8Ei4uAvFoab9D1B0/wsKvkyzF3XESmosC+izIlBfjjtXBhAf0befPgQt2vAsVlSVfwvX5ouMMWDr5Z96tAcXHInVbR49GmzktWXDyvlMsyKtMDF38KTswIIY5yAvSkgCTecF+RX62fWw8jwj+/q7+/ykvzGyguzuLMZwV+VHcXfr6/v7/KS3MXJC46YXHH+XOnyYyLl5ZOLKqodXnh4pcqKW2/JuEk2WhXocfm1q9fP7eATT4LaFV5LZxH4QwQF86YnYWExhUJiH3E6k7nNXopZLgLCpclbhQRb6ZzNeHiyyvFEmhgSO5DDUBraNL2U5ZuVEvID2E8YER+ieKh8QqfHxi4xGLB4rIo7AsXZbh71Owu8ihwF8ICxmUWwUZbxIWrQ5WRlfHxWaDlt+9x3i3BL1b2wTfgvGn+eagRrvjTWjyAntcDcnAUo1+cGtB49V1TXMIDNneAF3MJunsu1E24TGtN/CSuqKlUKptKyUnH1sVLy/l96N+lJUsORyNcyafXV/VUldfCj2A8EC//uITgccVqdanmrt9w9xzRCi7S7dZ87f78AHBBDhkGngsJ576LV89AWry0eKIuS6oBrtHtRjQuzJl56QEZuBT2fzJEuGjSh/ziGnRxd15391yo+aEGFQttDZmucFvFxqggcPGLJ7S+yxEXnz6TH+IJfunMRr5uZay+71Isn5IvGLV37vNPQWye0rrz+ZcOvmjwGnXFZS1Kw0Vc77qqUdONjri22gaKiZq7l1/eXuVV784Zl2KNdg1Xkh2+8sYLL7xw7ArQwpv3/Oxnr79+i67hcDIQXMzIyPihpaVyufwDOy6+jBJumOWxlG2sUY+rIps/bbj/gh6P9XuPoBqMeF2evx1GZAoG5Z/XuQVk46uWj1rrIl3XDE3ScMWtuO6o1M90EmZ3r1fb1+X5t3y4m7G6CxtDNCoZfuXc9r0/uXhuz549//H4d37603/5p3+8Wdcr4SSt4wq1dTLEZ0rFkenp6TM/tnWZhFxEyWzLlZQ9XZQlrbhuLZp5JTffj+Kx/QiIyX546gG85g/2vzR/+eCDU9e9hsYbbq1rplgwf9T7LtcVecvivBOu4tk6XjGTu+3757T+a/5y/0svwdp0o+HOGVe2aOFlxjVwYe/FiwjXM49/9NHPP1v+9Ikdml6JBIULnAhxRVEy9qEGfyJ/Kw/H8Qfs43gHXGZeoGO6T+sbjuyde+NzxOve+XkQjvlduye+YCcGBqZARFzqb9HCq+mhRj2usXpeCcPdeuDu9SNabYLuLs/3H3xwgJ3ycpcqWniZcZ27+JOLF0//DjSuZx765KPdnw1d+K/gcWUYWDHtfReRqaBmVXRqXDquSMrQrcUxEy907RGdbj79fO/eI1+Cb8/dO395fr6/H/C6ct3E1JXXBs5/3xwQ1ShqaGzMzKtFXHcYxc1UxsbyFl6JmrsjwB0adzxlckdNTL12ZeCSq7sxEy8zrr2nv376NML1+JNXP9l1+X//572dGq6bW8Yl1I0Ml1bSGYrgaftQQ6nApULwOuOKKzy0EWjowL5bbwVHUUyZca27BE8zX/r880/3I1xzv9s933876CN2/XLit7+9Qnwx9cWXzQHZWC0KxHdsqF1cWVTegX37UHEWXhCXxgu4e2Or5u4Nw92z0F3oi6kBi7sZi7saLzOuD09fPf31q89BXI8/+d+/eeujz97bESguAudz09PjYK7sME3m8xAXU8kXHYJSh2sfxDU2ZvBCuNZdQhF5+YjWrX/Yd/AyisdHgwMTJGhfUz9ibLhQRGBAarxaxJWqFpcvQl6m8WHC4g4NO+Ye6Nt9+S3krm9g4joSuHuRtuGquXvViLkZ1xP/fumxq1cfQrge/vW//vrfLr+8YydSALgInpfkDM4rq2enR0am7UMNfmYsDXierFSW3IYaGq6NB4yjMAZhGi4tInPbNVr05O5+VHsnOTD8mhiY0tYOHXDlYVFFYzzfPi5Uk7L1uCzuHuBYzd29k9QEHBxOaWuHDrgQ/aLqgOvmTz7ec/XjPRquH/7nwm/eumVnULj4zNJyWYUrFWCwoahOqxr8ybNgqJEayxdlWz6CBZdR6SpGFqWOa90jxnR07rEQRqOAPM9iAhx6TT2qbeoUEBjeakfYLi6t4c+YYqDj0nhpdYnBeOhu1/M8Rk5Ad+cjXu5qp30zrh13fbwH0Xrm8Ycffvi7g9/76o72cWmRJxZXSnA1Qz9G51UNaSwNeA1VKmdtzUvHdWAICp7S8yZaVVwGr7lfgWYHcaELSxDXlHE9pda6qkWB+JqGLRouim4syowrWyuuMlbMmWOQqHf3CGjnCNebIJQQ19Qxb3dVWmZckR3DTwBYA3/9N+cBrm9/96827BjWtaNNXIQ8PTI9C1oXb6zIO65qKGco1IeNueDCtupi9wFctQzlKq51j6F4oJZE7951EF1UFqamJqpXl6sBqRY1k6+YJwVNr2pouMJGeal83kqrhkvjpbnjgTtUhUC/NVG9NmdztxW6S9fKsuIa/s6ecw88+Od/8RDA9ZepW4aruDADV6hJXHGdhJornZ1eWVkZPzF76NChxcV7HNcMlVOgeWXHDrjhqmpfvkLUPsWOr6vympub046ePrhbywUQpiaStU1tFkFAzFNurXVxN/iQGVdVd+QrVlpYvObuEXTJC4rfrdUlgGuilgjuMO/KV0y0LLh2Dg9//9xTTz29/sMnn/n2nUM/rNIa3hlpExccafA8o6jZbG4Vqn4RSksKIDJpgk8VtWsnBMHwBjeWq8dFmD8ubK7xuqAfPfXsBu2N8KLpRiEHXNYFrbZXNSozWJ1GTbwu6DfB8IY78kWTJQdcFlpWXNu2bTv+d6cv/O2HT/79927/h+FtVQFcVIu4GBMTJl2WMxJck5+0nAwByHQ5jZJBGZwvaavxhLy0uLLIOON6te7hTseqvG4zWhJlQBIE04YOuCy02l/VqGtbULXadNy4ZSlkpMNz5pvOHNxZaNlwbdvy+39475987Y++unPbNkdcRBu4AA25vLS4eGh21nQyJIjy7HIa14chhKrwBBqVgFeleIJwxGXzcL8RkeNC/a8ssgekrqh2cTlGp1qbNsfbc2fGNbwF6viX/+CubVu2bTFruGVcUcp6dARRP9QgMuMjYxm+KoLKAKaHRMiZ3ziiDerrcdkP677NFlxh1mYzzDoGpE7t4nLW/QauhLu7iK/rXfW4vvm1uzZt2rJljXDpMg/kmZmTY+Mr48swKWB8fHxl5cyp1TSDToj8zEiW94ULY7+l49Lqb2LUlouTHA2Zcv3c1Cwu1heu8H0WXPFR2+HERnEf7sy4UIu66/SffuOmLYHhStANccGJs6Roi5qqqmzlaxM0/uyIlgPQGBdG3W0+3UQH7bgGrx0ubOu3zLiEQTuuwaZxbdq06aZjX/+zb9y0qaot6P9t7eAi9BxKs4S6VQ0e106H+keDVnlaX+/1gQvj7g4EV3xNcGHS3UHjQpT++CtfWbepXjeFW8dFx2F6YtSqWJ8FFyGvKLXei5dkPdfXoOULF5a4LThcjA81hQuLI3da79QGLtaKa5MdlgUX3hyuWHLDdQ660YqLL4yMzy6irIClxVnQkZ1Qwazr0CnFbd7lrL7jVVxG38VSDKU/dc9n3xVvblXDNy4sdlsVl9F3mdz57btquLbd5KbhVnFRoy7HOlh3MkwNnYVJAUAjxZOrWYUA0y6ptrjhDxeckOqnGxbXVuuF0cHBUe1tCD69xGfruv5GH2oSFzZ43MBluOOgO7YJdyZcHs9NiWCx1nCFtBvubQIhrOsD0KIHEGP0YYR5JconLjAh3Wy9HduEC8nvydD3qkYTuKA761Ad4TI9ncE/LiaedFMUdD0C0xIuLOx8pGSs/s4UKcPrASB4h+tdPnFhx4573z0f/FAj6h8Xduwu75mVf1y45VFahph6d83ichGbsAaFUFcWteUpXJLLZbweWMgvLuyY95OEri0u7FhguPxpTXCBZqWMTI/DrAD4//T0SrnuAqV/XCw4v3io4ZMr1hZX2Nudj1WNJnExQeMCfZYsg5mWWBqZHgGaLpZmlLoJGB4SmrpPqQ0x8QZPkGgLV7tqGhcVEC4jKYApLy/KelIAo6iqgptmyxmV6Hpcic7ias4dQQeKi0+vTIdqSQF47Q1cCpZOVXHFuxVXqLtxkQHh0jjwoKMaX5IzBG8Vk5HLi8tg5sVn0HZUtGO4oo2eM2IVFessrubc4VxAuIzysoWTIyswK2D5kKbZWbgqf2JRhKuI8qy2xEt3EFdz8SA73Lqac0cFjUtbJFRTWTGXy62ugpdsSkWr8lJ6ceUQo9UmsnMnQ4jL/yIU02FcMcY2t/ISHRQu814JtSyrkp4mhUsZOQ3OhCvjh0RGH3QwZLzhreQBiUHOfC9CUWSCaFxoYArH7FNhL5FcU7eSu4lNWHZLEJk0zAqYRVpcXBLTqmmEiNNklApgr37EJCjNkb81KJJu8UmPralJXDQZzIiajdF1u60bbBDmLpUCQenU8+V1XL7jQSfW7GtAHBS2xc1LDEkHU83tuNxFUBxJdiwojMv1b0dn8EKr0MnHygNc/msTwwXV9n3jAq2MA7Q6NtLwj4sgGAHGo5MjDYCL9ImLIEiBDKjrArhIRksKaHB3PRdNAFpkrGMdBFNNV2hgTEhEkb+OfmcDxAX7icZxiycEcKaOBTMOArgowSEpwKY4gMWRsU4NNBAux3QFm2DdJblYZ7+zBeLi/MctygVTmdhYbMONTlkBjgr+KfvuYmLJDTf4NXZDR5c0MDhNTjQRtw1BPSc83OdjHmqoQ18xr4kY9G8smSA6/PU1kVgTgUu28W0odbuNOicF2JRMJshOTmxAu/ftLE51cgyviXPJprDbS3D2VOGWFXb98hOrQgHuM1BnITZ8Lb4YKsL6jVvnq1JPPfXUU0899dRTTz311DWK+MwO8TtxiISbUuPZUqAFBu6uyRLbnRzigs9LAIKv7z8Ic0KDxek6CZx3PQi0wMDdRXCBa6pATmhroSwsECEeTrsJ/cW8iBCC6YUh/achwc/3enIkC/8Eiof/wRf43vihXaRnRMIcFzKK015sxWs/430UWCusqpqvWmn+3UVCcaK+QKsZm4h4qA1eLIerM7yiqpKES6rEMOCNQlHgRVEYFWdKq6osSYzKMDjXGFeE5ahULi1KCq5IOSXLZ0v8WUnGcVHM8SojqbwiSeDfLCgcflAkRqI8A8JyxuVJUVWYVJZXc1kR/WlWBcWvSiUmC9PtZJE3nsZNudarWmGGlFVRKy0tg9JySkHKWjdwLwwqjAtGQQo8LoXhtWNWVBxnFDGlKDwMKDhOVdKfxN/Wt3KD+Mq5SVUVC1k1nS1NSqVMTpRVMafmpEJBpXKiKpdK2VWKovzhotO5bFYuKas5URInRbFQkGSGESflbGE1p4qlkiiLOTFbKOTAv1IuK9GNcOk334iSXFDTjAr+WC1lCjkxA4rPrhYocZLJZeC7tLYl7Wq0WlhVmdWZrFpQC7msCkvLFYBnywbuhUGFcU7bbBL4gcelToJicoWcCuo3OMBsqqSmV3OZbEkFh6/dVMS1hQs+rCyTSRcKdJEqlWgym8vlMrmCSK+CwEi0mJblQjpTyNC0j6X4CEvSIj0JGKlpUQQNIStmxUxOpnLpgpqTwefVNDye1TQ4FkpclTMFyrtclia1B6qpWVkEligZRGQV/LWYTovpnJjOkgWZEmnQfMWM/uw11wKrhVWVkYEbcDpIp7OoNHCkaesWnu7CuFagJAFcNChJpVaz4MjBoYNjzoLKWlLFVXGyVJIzoqgX2BYuBt6mLSoUvBkbvkg4Q+ESg95J+k3aFPwpzvjBZb4ZDZzpGHi3LziZUgooDzQQ/a41eA5ESsvgJ564TMXBP9T/XiteqRavfTY2dcXldM+cVnDNrFL3a29cxlY5+CIXJKp6zFq5FJPL1RXYzlgjQsC+kmXd+8ZqH+lnKB+Gj6lqRnzIe4oQJpos0MtooIWh6LFM9Thqr7ZDtMhHrffaY9incX9XuiI+L5zV1KBcv1eUTONZj5u6gyxMi17TBV6T63I99dRTTz311FNPPfXUU0899dRTTz311FNPPfXUU0899dRTT076Py+r3xYiltaGAAAAAElFTkSuQmCC" alt="plantuml logo"></p><h2 id="PlantUML-简介"><a href="#PlantUML-简介" class="headerlink" title="PlantUML 简介"></a>PlantUML 简介</h2><p><a href="http://plantuml.com/" target="_blank" rel="noopener">PlantUML</a>是一个画图脚本语言，官方介绍如下：</p><blockquote><p>Generate UML diagram from textual description</p></blockquote><a id="more"></a><p>用它可以快速地画出：</p><ol><li><a href="http://plantuml.com/sequence-diagram" target="_blank" rel="noopener">Sequence diagram</a></li><li><a href="http://plantuml.com/use-case-diagram" target="_blank" rel="noopener">Use case diagram</a></li><li><a href="http://plantuml.com/class-diagram" target="_blank" rel="noopener">Class diagram</a></li><li><a href="http://plantuml.com/activity-diagram-beta" target="_blank" rel="noopener">Activity diagram</a></li><li><a href="http://plantuml.com/component-diagram" target="_blank" rel="noopener">Component diagram</a></li><li><a href="http://plantuml.com/state-diagram" target="_blank" rel="noopener">State diagram</a></li><li><a href="http://plantuml.com/object-diagram" target="_blank" rel="noopener">Object diagram</a></li><li><a href="http://plantuml.com/deployment-diagram" target="_blank" rel="noopener">Deployment diagram</a></li><li><a href="http://plantuml.com/timing-diagram" target="_blank" rel="noopener">Timing diagram</a></li></ol><p>对于工程师们来说，用代码的方式来画图，简直是为其量身定做的。PlantUML语法也非常简单，参见<a href="http://plantuml.com/PlantUML_Language_Reference_Guide.pdf" target="_blank" rel="noopener">PlantUML Language Reference Guide</a>，它支持很多<a href="http://plantuml.com/running.html" target="_blank" rel="noopener">工具</a>，可以生成PNG、SVG、LaTeX和二进制图片。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>有非常多的工具来协助工程师们使用PlantUML的语法来进行画图，比如ATOM有<a href="https://atom.io/packages/language-plantuml" target="_blank" rel="noopener">language-plantuml</a>、<a href="https://atom.io/packages/plantuml-viewer" target="_blank" rel="noopener">plantuml-viewer</a>、<a href="https://atom.io/packages/markdown-preview-enhanced" target="_blank" rel="noopener">markdown-preview-enhanced</a>等各种Packages。当然其他的编辑器也有同样的类似的插件。</p><p>另外，我也写了一个<a href="https://github.com/tonydeng/plantuml-tour" target="_blank" rel="noopener">plantuml-tour</a>的项目，其中有哦PlantUML的一些例子，执行脚本，以及安装说明等。大家有兴趣，也可以去看看这个项目。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面的例子是通过<a href="http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000" target="_blank" rel="noopener">在线示例工具</a>生成的。</p><h3 id="比如这样简单的三行文本，就能生成一个基本的时序图。"><a href="#比如这样简单的三行文本，就能生成一个基本的时序图。" class="headerlink" title="比如这样简单的三行文本，就能生成一个基本的时序图。"></a>比如这样简单的三行文本，就能生成一个基本的时序图。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Bob -&gt; Alice : hello</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="http://www.plantuml.com/plantuml/png/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000" alt="plantuml online sequence diagram"></p><p><a href="http://www.planttext.com/planttext" target="_blank" rel="noopener">http://www.planttext.com/planttext</a>也是一个类似的导出工具，并且可以在这个网站上直接查看和测试<code>Plantuml</code>不同图形的语法。</p><h3 id="除了之前说过的可以生成的图形，还能生成其他图形，比如生成🌍图形。"><a href="#除了之前说过的可以生成的图形，还能生成其他图形，比如生成🌍图形。" class="headerlink" title="除了之前说过的可以生成的图形，还能生成其他图形，比如生成🌍图形。"></a>除了之前说过的可以生成的图形，还能生成其他图形，比如生成🌍图形。</h3><p><img src="https://www.planttext.com/plantuml/img/RLVRSjis47tNLs2ObtGcml0caNfgV4aQtnBNafjftrOIBAAY01KauoXVtxEWRCcayg8Cl0livUmvouzLJQvkDkNWfy9_Ye4OHpBAn30QXJ8CHN1c5eLrj5A1EFnx9yvAgjRqGJnEpmOYoTbKY3YHMGANkb2cEhRtBdyufHOArebC-IHD-JSufrMnf6NGiRvozDz0HFv64OMX78LiQrPhk-xQpWhI9Pabxfx8IGpxQ2nJH7AkzB_QhBhs5uKsD12ZM8vmEJ-IncpiIctwOIkt8RF3tR5aw-4ubPdmvfjcITsxzyS3aS8SziCiac4ESrlLjd_x7LKLBOgcKdLTjUL4wMNE3wMPdF13ZYfTwhSluI57ltGvW9cC-GHUIMlzwnVzq6Lvr36aRCtA3eP9AiS8VZZAstesojXAd6cd3lr2SzrAcThNA47q8npYDnw9u8AqivqauF1fjTlM0n6Ze7oGvpwK2oeNJLrt0xyoIqq89P4JN_rSfXaRRvMOsMVp5cTJszI5E7joUa4UEcC-7sRy2v-AvcZyulW9rDGwkrXOyVw1vbJ__Xjw4ScSUv5dCkCi2josiZt8bUY_rTKBgcEPeG_3oLZcgDKbbS1yhu4pzPDUFE9SZZcbB9CnFBwgPt6foaA_JQdDdw6AM8PHEF9pTgdC3-Lwrr_O4jEtj2yleDdymcWaOu3gifcJxhVZyUoJU7ysRyHbGNED0WpZJ4Q27vlucVj4LQsSkAfuQe9NlpV7m276cXkKvUmSVCOiTT-24n_xGUNMHnXgr2puew7D2Li-1iE4Ck8auZRpBwgij5dhe7klQMSQg6A0Hr7gm_W298iR-tQgtudNOpX4CecPmJBkEZlOiYcRplrVw9cqtjTrj7yZJ3rohzowgQiUp-oFFuY7fgguXy0LLqZ44_uDha2cPjwKdPTcZLkh7JfYrkI8yJWS-mf4uTZZyPhmXxf79G2ADSe_XF7B-J0PSPp1jN9DHQNQT91LELAW14ovdyFnn5lVK3ScRttsj2h8Q8uPDSkOr32wBOlSK5s0zPRDsmU-gYtXVaY3P_0av7U26wr-d6ZsuzgHDY1yaUopZMI6VjyqL9AuRJRRnXsHpXrETpvP0VBsyIUU6MungjsvurZqIZacaYYMKSYSa35L1RTwGoUYkKV947d4l0VZa4KkkBLSujxGFHfTgwMuWNGiBG2RXYmGy88QGIZkQEdqikSrtI9TJ4BgEIgAFJPWRA1DVTeebBWlmD9wYnfL7hHjpXC_G7TgiUYbWJUeMMhmCyOQXOhyD8EX9duoxjHF3TgxqFNkcFhRum6FMyxMUUXHSQTfSu8xFeDlzF95sT4AdtWKjb5Pu-oFdXJTwhblXKX7FebXvjc0pMkdg3iFVpPghXOVn0KPOgK4cMLUOpAFZpjRBUnphs8lCpUCcFfWFVRJ_PKLQQwxitEZp8wldkn59lI3zgqgU-h5KBBkcQ3mQIvpFmLUkeDxSle4y3uxA8w2WCKjFK9uMQO1iBeuCMLDLJig3zK1NhrC1lVMrSVyktVuvjJAcdtzXs5RVr0mk_pPwFgK_2uQI8G3iu8Y-Gc0QG9uFwZT-b_i0kiEJInKI_089CzvqKYycZneAvPAN9DH1vK_B1eiebnup1ll3WzseqxKyggc4gMCMcRq3ET9cvSkSQTDSS3dE_6NLhMXZNZ_XI2yp8n9rgeYGWC715CoRRqrC74GAcmM-iawerznYZvp9dagmwnrkxQLwfJs0ZiOYGU_IaHv2zNnsC-EzsZ8T3pk6tJLielr6qkBxj3d19TQTzS8lroMJ7hHNb4IZuufk8IsrdNMwDTZlo_oQiPBT8BoJksJFa40vqsv8ZzhW7QotvzulvpMTh4kRDcHXEcpMYhJRbky68_yTXzCTqkZThqPEu1r6FaLQnYb4u-y6HMwxj85QCmVevhZLf_0a25RwysyMTTToGN5Q_7-d3QqjhxP8vzorAv2mSokToVGVKrRLYY05Eo0wa_yjZx3acUwmu3fCVYUqVP0BfZI2Vy92mgptipfhIrxT046OxfeDswFMcxQ8yP4d5DjZ_SotY-nIxSJ3O7bJGCzWmG5Vm6ejkciSUYPl927W40oiKV6M2Re14R0cBu--4vuvSzzI5xT4D9tgl3nidhxAV6gMDEQQeZ9C6qvCifINc63xuetsvuJxwV_W9xzbZMEMtAAsWteRxZOvxNHJsy-8xxAsL4gax3zxXFjfo9e5BlwlJt-ycZPTNyy67Oysks-vt4u7dnKM48svVy0" alt="xearth diagram"></p><p>下面是生成上面地图的plantuml描述</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">xearth</span><br><span class="line"> 61.17 -150.00 &quot;Anchorage&quot;           # Alaska, USA</span><br><span class="line"> 38.00   23.73 &quot;Athens&quot;              # Greece</span><br><span class="line"> 33.4    44.4  &quot;Baghdad&quot;             # Iraq</span><br><span class="line"> 13.73  100.50 &quot;Bangkok&quot;             # Thailand</span><br><span class="line"> 39.92  116.43 &quot;Beijing&quot;             # China</span><br><span class="line"> 52.53   13.42 &quot;Berlin&quot;              # Germany</span><br><span class="line"> 32.3   -64.7  &quot;Bermuda&quot;             # Bermuda</span><br><span class="line"> 42.33  -71.08 &quot;Boston&quot;              # Massachusetts, USA</span><br><span class="line">-15.8   -47.9  &quot;Brasilia&quot;            # Brazil</span><br><span class="line"> -4.2    15.3  &quot;Brazzaville&quot;         # Congo</span><br><span class="line">-34.67  -58.50 &quot;Buenos Aires&quot;        # Argentina</span><br><span class="line"> 31.05   31.25 &quot;Cairo&quot;               # Egypt</span><br><span class="line"> 22.5    88.3  &quot;Calcutta&quot;            # India</span><br><span class="line">-33.93   18.47 &quot;Cape Town&quot;           # South Africa</span><br><span class="line"> 33.6    -7.6  &quot;Casablanca&quot;          # Morocco (Rabat?)</span><br><span class="line"> 41.83  -87.75 &quot;Chicago&quot;             # Illinois, USA</span><br><span class="line"> 32.78  -96.80 &quot;Dallas&quot;              # Texas, USA</span><br><span class="line"> 28.63   77.20 &quot;New Delhi&quot;           # India</span><br><span class="line"> 39.75 -105.00 &quot;Denver&quot;              # Colorado, USA</span><br><span class="line"> 24.23   55.28 &quot;Dubai&quot;               # UAE (Abu Dhabi?)</span><br><span class="line">-27.1  -109.4  &quot;Easter Island&quot;       # Easter Island</span><br><span class="line">-18.0   178.1  &quot;Fiji&quot;                # Fiji</span><br><span class="line"> 13.5   144.8  &quot;Guam&quot;                # Guam</span><br><span class="line"> 60.13   25.00 &quot;Helsinki&quot;            # Finland</span><br><span class="line"> 22.2   114.1  &quot;Hong Kong&quot;           # Hong Kong</span><br><span class="line"> 21.32 -157.83 &quot;Honolulu&quot;            # Hawaii, USA</span><br><span class="line"> 52.2   104.3  &quot;Irkutsk&quot;             # Irkutsk, Russia</span><br><span class="line"> 41.0    29.0  &quot;Istanbul&quot;            # Turkey (Ankara?)</span><br><span class="line"> -6.13  106.75 &quot;Jakarta&quot;             # Indonesia</span><br><span class="line"> 31.8    35.2  &quot;Jerusalem&quot;           # Israel</span><br><span class="line"> 34.5    69.2  &quot;Kabul&quot;               # Afghanistan</span><br><span class="line"> 27.7    85.3  &quot;Kathmandu&quot;           # Nepal</span><br><span class="line"> 50.4    30.5  &quot;Kiev&quot;                # Ukraine</span><br><span class="line">  3.13  101.70 &quot;Kuala Lumpur&quot;        # Malaysia</span><br><span class="line">  6.45    3.47 &quot;Lagos&quot;               # Nigeria</span><br><span class="line">-12.10  -77.05 &quot;Lima&quot;                # Peru</span><br><span class="line"> 51.50   -0.17 &quot;London&quot;              # United Kingdom</span><br><span class="line"> 40.42   -3.72 &quot;Madrid&quot;              # Spain</span><br><span class="line"> 14.6   121.0  &quot;Manila&quot;              # The Phillipines</span><br><span class="line"> 21.5    39.8  &quot;Mecca&quot;               # Saudi Arabia</span><br><span class="line"> 19.4   -99.1  &quot;Mexico City&quot;         # Mexico</span><br><span class="line"> 25.8   -80.2  &quot;Miami&quot;               # Florida, USA</span><br><span class="line">  6.2   -10.8  &quot;Monrovia&quot;            # Liberia</span><br><span class="line"> 45.5   -73.5  &quot;Montreal&quot;            # Quebec, Canada</span><br><span class="line"> 55.75   37.70 &quot;Moscow&quot;              # Russia</span><br><span class="line"> -1.28   36.83 &quot;Nairobi&quot;             # Kenya</span><br><span class="line"> 59.93   10.75 &quot;Oslo&quot;                # Norway</span><br><span class="line"> 48.87    2.33 &quot;Paris&quot;               # France</span><br><span class="line">-32.0   115.9  &quot;Perth&quot;               # Australia</span><br><span class="line"> 45.5  -122.5  &quot;Portland&quot;            # Oregon, USA</span><br><span class="line"> -0.2   -78.5  &quot;Quito&quot;               # Ecuador</span><br><span class="line"> 64.15  -21.97 &quot;Reykjavik&quot;           # Iceland</span><br><span class="line">-22.88  -43.28 &quot;Rio de Janeiro&quot;      # Brazil</span><br><span class="line"> 41.88   12.50 &quot;Rome&quot;                # Italy</span><br><span class="line"> 11.0   106.7  &quot;Ho Chi Minh City&quot;    # Vietnam (Hanoi?)</span><br><span class="line"> 37.75 -122.45 &quot;San Francisco&quot;       # California, USA</span><br><span class="line">  9.98  -84.07 &quot;San Jose&quot;            # Costa Rica</span><br><span class="line"> 18.5   -66.1  &quot;San Juan&quot;            # Puerto Rico</span><br><span class="line">-33.5   -70.7  &quot;Santiago&quot;            # Chile</span><br><span class="line">  1.2   103.9  &quot;Singapore&quot;           # Singapore</span><br><span class="line"> 42.67   23.30 &quot;Sofia&quot;               # Bulgaria</span><br><span class="line"> 59.33   18.08 &quot;Stockholm&quot;           # Sweden</span><br><span class="line">-33.92  151.17 &quot;Sydney&quot;              # Australia</span><br><span class="line">-17.6  -149.5  &quot;Tahiti&quot;              # Tahiti</span><br><span class="line"> 16.8    -3.0  &quot;Timbuktu&quot;            # Mali (Bamako?)</span><br><span class="line"> 35.67  139.75 &quot;Tokyo&quot;               # Japan</span><br><span class="line"> 43.70  -79.42 &quot;Toronto&quot;             # Ontario, Canada</span><br><span class="line"> 32.9    13.2  &quot;Tripoli&quot;             # Libya</span><br><span class="line"> 47.9   106.9  &quot;Ulan Bator&quot;          # Mongolia</span><br><span class="line"> 49.22 -123.10 &quot;Vancouver&quot;           # B.C., Canada</span><br><span class="line"> 48.22   16.37 &quot;Vienna&quot;              # Austria</span><br><span class="line"> 38.9   -77.0  &quot;Washington&quot;          # United States</span><br><span class="line">-41.28  174.78 &quot;Wellington&quot;          # New Zealand</span><br><span class="line"> 62.5  -114.3  &quot;Yellowknife&quot;         # N.T., Canada</span><br><span class="line"> 90.00    0.00 &quot;North Pole&quot;          # North Pole</span><br><span class="line">-90.00    0.00 &quot;South Pole&quot;          # South Pole</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h2 id="PlantUML和Hexo整合"><a href="#PlantUML和Hexo整合" class="headerlink" title="PlantUML和Hexo整合"></a>PlantUML和Hexo整合</h2><p>无意中，发现一个Hexo的插件，就是<a href="https://github.com/oohcoder/hexo-tag-plantuml" target="_blank" rel="noopener">hexo-tag-plantuml</a>，这个插件能够让Hexo生成的网站可以方便的集成PlantUML来生成相关的图。</p><p>使用起来也非常简单，只需要将原来的plantuml文件中的<code>@startuml</code>、<code>@enduml</code>分别改成<code><img  src=http://www.plantuml.com/plantuml/svg/ItZSq9W00000></code>，既可以将原来一个个的plantuml文件中的图形，展示在网站上。</p><h3 id="安装hexo-tag-plantuml"><a href="#安装hexo-tag-plantuml" class="headerlink" title="安装hexo-tag-plantuml"></a>安装hexo-tag-plantuml</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-tag-plantuml <span class="comment">--save</span></span><br></pre></td></tr></table></figure><h3 id="比如我们通过hexo-tag-plantuml插件，在网站上展示相对复杂的类图"><a href="#比如我们通过hexo-tag-plantuml插件，在网站上展示相对复杂的类图" class="headerlink" title="比如我们通过hexo-tag-plantuml插件，在网站上展示相对复杂的类图"></a>比如我们通过hexo-tag-plantuml插件，在网站上展示相对复杂的类图</h3><img  src=http://www.plantuml.com/plantuml/svg/TLLTJnj757tVNp6Fk0Z5IPjMGYXIIbIfYYfLCdzWlJk4RPOTj1wIqZRIEWto6Z1E2KqeWJGEE7RRu1XHkSOB-CTaPtRzn5_edPtr1pP-GSkvvvvxxvaxOsfG4oEsNGlALRxNufiLvZQ2wZfh5HKbewaGl7axcKIF3PqkABDaSObOsA9evfUfANGVhwI9Qkje6WLUXUVRRFKaEF66QIdDnjWQHcSXyPvjFCBsQ2Ipa3897SQ_jmsB0hrNDaBlQjGWLXSR2iuPsaDCxnkMFePm3sUeOQbN99IhacXcQkgpM2b5J3srag5uCPhv6NlknZEFLhe-JxccuXYcz6rCi6_VM89qSKmuDdDCLCayDAmbrLONaMQgcSnTIcqZlKpnjngnKiPF62KLnI8K8qgM49b7_QEQHdpjF3mkTNwj-buZEFOkppPutk5x-HuIx3uBNF4X9KmyJuN6m3frO25VxqWXmOkQ62Zoiu8c3SkW4udfHyJG5OGcTPB2vlmSkDi5dyHfFLsHzG3cn2RMA1O71LIm0PWnDRPS43CBvF4S_d54RS3uM6_MndhKIWfCiXv4pU2qGRzHRGoeJfRJ9WOKJU8VeF1tGc5KDJwjhYRytrViihg79aXBubiUt80BKOMhQ3TvQAlZGXBj-I2fronpJEz7HhkxRhFZj87GBD7nQEx8zHA9uB4nlzApDqs8YLLBZ0aFaxPigXHVzVX9l9Hgj2kBi2dAZ4PCOa_RP4KrlpQNyPs9cmaKlAx13hAzkjopOBlAzylXnGksMWvB6_3yzGZmr_SEWhVPopFNlrXdxv_2EjzA9iDIDJXiSSSB_ldZyYp_oNawSoEgT4UPk9L0_kaEgxrZnO--L-uuks4x5vw_XoTMrkiuURx-bqI2IY6w8ouh_2uAbwkVd2mxtEKVIkp22TlRWB2j3TQgiEPHbopgAHEV9yIp6tX7DrZn9M-uKjnlhedM8uHlv3jRDHZFRsrA9Fpt20IX7wW5ayXyIMEhsR3Mb9s7xJU00za_hKCpxEnjr1WK_IA1-Cu5pCwEY_93Ncvnfq-ymFjJs9XhGSl2LVS_NdmE7BzTujcFaS1j42XkiKA95G_uPfaLNqKN0Xm8DkkTt6yGWG55RwKFh9a5bj1gDU6RLyvbXcH6Sb-2NFu5AzJXrqiEAXkGxaQKhmIb_m2n_HmS3Akz0PKmzpS_SDXfWsVViSC2S-lCtMULzM2jmPsioCQMZiHE_Gy0><p>最后，再安利一句，<strong>plantuml</strong>和<strong>hexo-tag-plantuml</strong>，你值得拥有。</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plantuml </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习常见算法分类汇总</title>
      <link href="2017/03/03/common-algorithms-for-machine-learning/"/>
      <url>2017/03/03/common-algorithms-for-machine-learning/</url>
      
        <content type="html"><![CDATA[<p>机器学习无疑是当前数据分析领域的一个热点内容。很多人在平时的工作中都或多或少会用到机器学习的算法。本文为您总结一下常见的机器学习算法，以供您在工作和学习中参考。</p><p>机器学习的算法很多。很多时候困惑人们都是，很多算法是一类算法，而有些算法又是从其他算法中延伸出来的。这里，从两个方面来给大家介绍，第一个方面是学习的方式，第二个方面是算法的类似性。</p><a id="more"></a><h1 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h1><p>根据数据类型的不同，对一个问题的建模有不同的方式。在机器学习或者人工智能领域，人们首先会考虑算法的学习方式。在机器学习领域，有几种主要的学习方式。将算法按照学习方式分类是一个不错的想法，这样可以让人们在建模和算法选择的时候考虑能根据输入数据来选择最合适的算法来获得最好的结果。</p><h2 id="监督式学习："><a href="#监督式学习：" class="headerlink" title="监督式学习："></a>监督式学习：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b15.jpg" alt="监督式学习"></p><p>在监督式学习下，输入数据被称为“训练数据”，每组训练数据有一个明确的标识或结果，如对防垃圾邮件系统中“垃圾邮件”“非垃圾邮件”，对手写数字识别中的“1“，”2“，”3“，”4“等。在建立预测模型的时候，监督式学习建立一个学习过程，将预测结果与“训练数据”的实际结果进行比较，不断的调整预测模型，直到模型的预测结果达到一个预期的准确率。监督式学习的常见应用场景如分类问题和回归问题。常见算法有逻辑回归（Logistic Regression）和反向传递神经网络（Back Propagation Neural Network）</p><h2 id="非监督式学习："><a href="#非监督式学习：" class="headerlink" title="非监督式学习："></a>非监督式学习：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b2.png" alt="非监督式学习"></p><p>在非监督式学习中，数据并不被特别标识，学习模型是为了推断出数据的一些内在结构。常见的应用场景包括关联规则的学习以及聚类等。常见算法包括Apriori算法以及k-Means算法。</p><h2 id="半监督式学习："><a href="#半监督式学习：" class="headerlink" title="半监督式学习："></a>半监督式学习：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b3.png" alt="半监督式学习"></p><p>在此学习方式下，输入数据部分被标识，部分没有被标识，这种学习模型可以用来进行预测，但是模型首先需要学习数据的内在结构以便合理的组织数据来进行预测。应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，这些算法首先试图对未标识数据进行建模，在此基础上再对标识的数据进行预测。如图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM.）等。</p><h2 id="强化学习："><a href="#强化学习：" class="headerlink" title="强化学习："></a>强化学习：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b4.png" alt="强化学习"></p><p>在这种学习模式下，输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式，在强化学习下，输入数据直接反馈到模型，模型必须对此立刻作出调整。常见的应用场景包括动态系统以及机器人控制等。常见算法包括Q-Learning以及时间差学习（Temporal difference learning）</p><p>在企业数据应用的场景下， 人们最常用的可能就是监督式学习和非监督式学习的模型。 在图像识别等领域，由于存在大量的非标识的数据和少量的可标识数据， 目前半监督式学习是一个很热的话题。 而强化学习更多的应用在机器人控制及其他需要进行系统控制的领域。</p><h1 id="算法类似性"><a href="#算法类似性" class="headerlink" title="算法类似性"></a>算法类似性</h1><p>根据算法的功能和形式的类似性，我们可以把算法分类，比如说基于树的算法，基于神经网络的算法等等。当然，机器学习的范围非常庞大，有些算法很难明确归类到某一类。而对于有些分类来说，同一分类的算法可以针对不同类型的问题。这里，我们尽量把常用的算法按照最容易理解的方式进行分类。</p><h2 id="回归算法："><a href="#回归算法：" class="headerlink" title="回归算法："></a>回归算法：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b22.jpg" alt="回归算法"></p><p>回归算法是试图采用对误差的衡量来探索变量之间的关系的一类算法。回归算法是统计机器学习的利器。在机器学习领域，人们说起回归，有时候是指一类问题，有时候是指一类算法，这一点常常会使初学者有所困惑。常见的回归算法包括：最小二乘法（Ordinary Least Square），逻辑回归（Logistic Regression），逐步式回归（Stepwise Regression），多元自适应回归样条（Multivariate Adaptive Regression Splines）以及本地散点平滑估计（Locally Estimated Scatterplot Smoothing）</p><h2 id="基于实例的算法"><a href="#基于实例的算法" class="headerlink" title="基于实例的算法"></a>基于实例的算法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b33.jpg" alt="基于实例的算法"></p><p>基于实例的算法常常用来对决策问题建立模型，这样的模型常常先选取一批样本数据，然后根据某些近似性把新数据与样本数据进行比较。通过这种方式来寻找最佳的匹配。因此，基于实例的算法常常也被称为“赢家通吃”学习或者“基于记忆的学习”。常见的算法包括 k-Nearest Neighbor(KNN), 学习矢量量化（Learning Vector Quantization， LVQ），以及自组织映射算法（Self-Organizing Map ， SOM）</p><h2 id="正则化方法"><a href="#正则化方法" class="headerlink" title="正则化方法"></a>正则化方法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b11.png" alt="正则化方法"></p><p>正则化方法是其他算法（通常是回归算法）的延伸，根据算法的复杂度对算法进行调整。正则化方法通常对简单模型予以奖励而对复杂算法予以惩罚。常见的算法包括：Ridge Regression， Least Absolute Shrinkage and Selection Operator（LASSO），以及弹性网络（Elastic Net）。</p><h2 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b12.png" alt="决策树学习"></p><p>决策树算法根据数据的属性采用树状结构建立决策模型， 决策树模型常常用来解决分类和回归问题。常见的算法包括：分类及回归树（Classification And Regression Tree， CART）， ID3 (Iterative Dichotomiser 3)， C4.5， Chi-squared Automatic Interaction Detection(CHAID), Decision Stump, 随机森林（Random Forest）， 多元自适应回归样条（MARS）以及梯度推进机（Gradient Boosting Machine， GBM）</p><h2 id="贝叶斯方法"><a href="#贝叶斯方法" class="headerlink" title="贝叶斯方法"></a>贝叶斯方法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b131.jpg" alt="贝叶斯方法"></p><p>贝叶斯方法算法是基于贝叶斯定理的一类算法，主要用来解决分类和回归问题。常见算法包括：朴素贝叶斯算法，平均单依赖估计（Averaged One-Dependence Estimators， AODE），以及Bayesian Belief Network（BBN）。</p><h2 id="基于核的算法"><a href="#基于核的算法" class="headerlink" title="基于核的算法"></a>基于核的算法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b141.jpg" alt="基于核的算法"></p><p>基于核的算法中最著名的莫过于支持向量机（SVM）了。 基于核的算法把输入数据映射到一个高阶的向量空间， 在这些高阶向量空间里， 有些分类或者回归问题能够更容易的解决。 常见的基于核的算法包括：支持向量机（Support Vector Machine， SVM）， 径向基函数（Radial Basis Function ，RBF)， 以及线性判别分析（Linear Discriminate Analysis ，LDA)等</p><h2 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b14.png" alt="聚类算法"></p><p>聚类，就像回归一样，有时候人们描述的是一类问题，有时候描述的是一类算法。聚类算法通常按照中心点或者分层的方式对输入数据进行归并。所以的聚类算法都试图找到数据的内在结构，以便按照最大的共同点将数据进行归类。常见的聚类算法包括 k-Means算法以及期望最大化算法（Expectation Maximization， EM）。</p><h2 id="关联规则学习"><a href="#关联规则学习" class="headerlink" title="关联规则学习"></a>关联规则学习</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b151.jpg" alt="关联规则学习"></p><p>关联规则学习通过寻找最能够解释数据变量之间关系的规则，来找出大量多元数据集中有用的关联规则。常见算法包括 Apriori算法和Eclat算法等。</p><h2 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b16.png" alt="人工神经网络"></p><p>人工神经网络算法模拟生物神经网络，是一类模式匹配算法。通常用于解决分类和回归问题。人工神经网络是机器学习的一个庞大的分支，有几百种不同的算法。（其中深度学习就是其中的一类算法，我们会单独讨论），重要的人工神经网络算法包括：感知器神经网络（Perceptron Neural Network）, 反向传递（Back Propagation）， Hopfield网络，自组织映射（Self-Organizing Map, SOM）。学习矢量量化（Learning Vector Quantization， LVQ）</p><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b16.jpg" alt="深度学习"></p><p>深度学习算法是对人工神经网络的发展。 在近期赢得了很多关注， 特别是AlphaGO战胜李世石之后后， 更是在国内引起了很多关注。   在计算能力变得日益廉价的今天，深度学习试图建立大得多也复杂得多的神经网络。很多深度学习的算法是半监督式学习算法，用来处理存在少量未标识数据的大数据集。常见的深度学习算法包括：受限波尔兹曼机（Restricted Boltzmann Machine， RBN）， Deep Belief Networks（DBN），卷积网络（Convolutional Network）, 堆栈式自动编码器（Stacked Auto-encoders）。</p><h2 id="降低维度算法"><a href="#降低维度算法" class="headerlink" title="降低维度算法"></a>降低维度算法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b17.jpg" alt="降低维度算法"></p><p>像聚类算法一样，降低维度算法试图分析数据的内在结构，不过降低维度算法是以非监督学习的方式试图利用较少的信息来归纳或者解释数据。这类算法可以用于高维数据的可视化或者用来简化数据以便监督式学习使用。常见的算法包括：主成份分析（Principle Component Analysis， PCA），偏最小二乘回归（Partial Least Square Regression，PLS）， Sammon映射，多维尺度（Multi-Dimensional Scaling, MDS）,  投影追踪（Projection Pursuit）等。</p><h2 id="集成算法："><a href="#集成算法：" class="headerlink" title="集成算法："></a>集成算法：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b18.jpg" alt="集成算法"></p><p>集成算法用一些相对较弱的学习模型独立地就同样的样本进行训练，然后把结果整合起来进行整体预测。集成算法的主要难点在于究竟集成哪些独立的较弱的学习模型以及如何把学习结果整合起来。这是一类非常强大的算法，同时也非常流行。常见的算法包括：Boosting， Bootstrapped Aggregation（Bagging）， AdaBoost，堆叠泛化（Stacked Generalization， Blending），梯度推进机（Gradient Boosting Machine, GBM），随机森林（Random Forest）。</p>]]></content>
      
      
      <categories>
          
          <category> 算法及实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
            <tag> machine learning </tag>
            
            <tag> 机器学习算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的JIT</title>
      <link href="2017/03/03/jit-in-python/"/>
      <url>2017/03/03/jit-in-python/</url>
      
        <content type="html"><![CDATA[<h2 id="编译型-or-解释型？"><a href="#编译型-or-解释型？" class="headerlink" title="编译型 or 解释型？"></a>编译型 or 解释型？</h2><p>玩过 <code>Python</code> 的同学应该都听过 <code>python</code> 是解释型语言，那么什么是解释型语言，其实在现代的编程语言中，关于解释型 和 编译型 的界限越来越模糊了，这里我根据我自己的理解下个定义：</p><ul><li>解释型：不能直接编译成可执行二进制程序的语言</li><li>编译型：可以直接编译成可执行二进制程序运行的语言</li></ul><p>根据这个定义的话，可以明确给出界定，<code>C/C++</code> 是 编译型 的，而 <code>Java</code> 则是 解释型 的，为什么我没说 <code>Python，因为</code> Python 我也不敢说它是哪种类型的。为什么？因为这要看你说的 <code>Python</code> 是什么？是说 <code>Python</code> 编程语言，还是 <code>CPython</code> 解释器。如果说的是 <code>CPython</code> 解释器，那么毫无疑问 <code>Python</code> 是解释型的；那如果说的是编程语言，那么还真无法界定，因为 <code>Python</code> 规范只定义了 <code>Python</code> 的语法规定，并没有规定要如何实现编译解析，所以无法确定。</p><a id="more"></a><p><img src="https://ooo.0o0.ooo/2017/02/04/58959aaa98af7.jpg" alt="python is a programming language"></p><p>那么是否就可以说解释型语言一无是处呢？那肯定不是的，存在即合理，虽然解释型语言的速度相比编译型会慢很多，但是解释型语言具有一些编译型无法比拟的优点：</p><ol><li>一次编译，处处执行(Java的最大卖点)</li><li>可以确保你看到的代码就是你执行的代码(python)</li><li>弱类型，开发速度很快</li></ol><h2 id="Python-执行过程"><a href="#Python-执行过程" class="headerlink" title="Python 执行过程"></a>Python 执行过程</h2><p>当然，这里扯那么多其实都不是关键，但是，关键是我这里的观点是 Python 是解释型的，而且我所说的 <code>Python</code> 是指 <code>CPython</code> 解释器器执行的 <code>Python</code> 语言代码。那么这里的问题就来了，<code>CPython</code> 解释器执行 <code>Python</code> 代码的时候是直接将原始的 <code>Python</code> 代码加载进行逐条执行么？可以说无论是 <code>Python2</code> 还是 <code>Python3</code> 都不是，原始的 <code>Python</code> 代码都会被编译成字节码，然后再执行。但是新版本的 <code>Python</code> 和旧版本的 <code>Python</code> 有一些不一样，旧版本的 <code>Python</code> 是在内存中编译成字节码，而新版本的 <code>Python</code> 则会编译成 <code>pyc</code> 文件，放置在源文件的目录。用一张图来表示就是这样的：</p><p><img src="https://ooo.0o0.ooo/2017/02/04/58959ffd5678f.png" alt="python build source code"></p><p>那么这里就有一个问题了，为什么不直接执行 <code>Python</code> 代码呢，而是要编译一遍转换成字节码？其实很多人也想得到，其实就想加快一下 <code>Python</code> 的执行速度，因为边执行边编译速度肯定比先编译好快的，尤其是 <code>CPU</code> 资源占用多的情况更是如此；同时，先编译的话我们可以有更好得优化空间，我们可以做一些更好得代码优化，例如这样的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br><span class="line">a &#x3D; a + b</span><br></pre></td></tr></table></figure><p>如果一边编译一边执行，我们就需要执行 3 条语句了，如果我们预先编译的话，完全可以优化成这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 3</span><br></pre></td></tr></table></figure><p>就是这么好的效果。随着人们的不断使用，人们觉得仅仅编译成字节码的速度不够快，因为毕竟不是机器码，于是就有人想把 <code>python</code> 从源码编译成二进制可执行程序的，不是没有，有！现在有很多工具可以将 Python 代码编译成可执行程序，例如：<code>Py2exe</code>、<code>Installer</code> 和 <code>freeze</code>。正如前面所说，编译成二进制代码是不错，但是缺抛弃了可迁移性，就不能一次编写，处处执行了。</p><p>##JIT(just-in-time)</p><p>为了兼具移植性和性能，聪明的工程师们发明了 <code>JIT</code> 这个东西，所谓的 <code>JIT</code> 就是说在解释型语言中，对于经常用到的或者说有较大性能提升的代码在解释的时候编译成机器码，其他一次性或者说没有太大性能提升的代码还是以字节码的方式执行。这样的话，就能在保证移植性的同时，又能让性能提升一大截，这里学问其实是很深的，因为我们怎么知道编译哪段代码能让我们的性能提升一大截呢？最简单的方式就是看循环，循环体中的代码都给他编译的，这样的话，大部分情况下我们的代码都是比原来高效的，但是，这也仅仅提高了循环的速度，还有其他很多代码有提升的可能，关于这个问题，这里也无法详说，有兴趣的同学可以自行搜索学习。</p><p>继续以 Python 为例介绍一下 <code>Python</code> 中的 <code>JIT</code>，在 <code>CPython</code> 中是没有 <code>JIT</code> 这个功能的，但是，有一个扩展模块 <code>Psyco</code> 可以实现这个功能；除此之外，其他的 <code>python</code> 解释器实现自带 <code>JIT</code>，例如 <code>pypy</code>。这里也不讨论如何使用 <code>Psyco</code> 加速 <code>Python</code> 代码了，有兴趣的同学可以看下 <a href="https://www.ibm.com/developerworks/library/l-psyco/" target="_blank" rel="noopener">Charming Python: Make Python run as fast as C with Psyco</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文从简单的介绍 <code>Python</code> 代码的执行过程出发，探讨了一下解释型和编译型程序的区别，然后引出 JIT 的必要性和强大。然而在生产中 <code>JIT</code> 并不会太多用到，因为目前 <code>Python</code> 还未被大规模应用于高并发的互联网应用中，或者说是性能要求高的场景。然而当真的需要面对这些场景的时候，难道直接编译 <code>Python</code> 代码不会是更好的选择？</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/" target="_blank" rel="noopener">深入浅出 JIT 编译器（java）</a><br><a href="http://www.devshed.com/c/a/python/how-python-runs-programs/" target="_blank" rel="noopener">How Python Runs Programs</a><br><a href="http://stackoverflow.com/questions/2998215/if-python-is-interpreted-what-are-pyc-files" target="_blank" rel="noopener">If Python is interpreted, what are .pyc files?</a><br><a href="https://www.ibm.com/developerworks/library/l-psyco/" target="_blank" rel="noopener">Charming Python: Make Python run as fast as C with Psyco</a><br><a href="http://www.cnblogs.com/kym/archive/2012/05/14/2498728.html" target="_blank" rel="noopener">说说Python程序的执行过程</a></p>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> JIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协同过滤实现及算法</title>
      <link href="2017/01/01/implementation-and-algorithm-of-collaborative-filtering/"/>
      <url>2017/01/01/implementation-and-algorithm-of-collaborative-filtering/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文来自团队中学科同学的分享</p></blockquote><p><img src="/images/blog/recomm.jpg" alt="recommend"></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>根据用户行为分析用户偏好，将不同偏好的用户进行群组划分和“商品”推荐<br>常见于网上购物，点评，游戏市场等</p><h3 id="SPARK实现"><a href="#SPARK实现" class="headerlink" title="SPARK实现"></a>SPARK实现</h3><ul><li><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><em>步骤</em></h4></li></ul><ol><li>读取原始数据</li><li>格式化成RDD数据：用户，产品，评分</li><li>矩阵SVD分解</li><li>计算用户相似度</li><li>根据加权评分计算推荐结果</li></ol><a id="more"></a><ul><li><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><em>代码</em></h3><p>读取文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(sparkConf);</span><br><span class="line">JavaRDD&lt;String&gt; lines = sc.textFile(<span class="string">"..."</span>);</span><br></pre></td></tr></table></figure><p>格式化数据</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JavaRDD&lt;Vector&gt; simple = lines.map(line -&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> Vectors.dense(values);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SVD分解</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RowMatrix mat = <span class="keyword">new</span> RowMatrix(simple.rdd());</span><br><span class="line">SingularValueDecomposition&lt;RowMatrix, Matrix&gt; svd = mat.computeSVD(<span class="number">2</span>, <span class="keyword">true</span>, <span class="number">1.0E-9</span>d);</span><br></pre></td></tr></table></figure><p>计算用户相似度</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dist =  Vectors.sqdist(v1._1.vector(), v1._2.vector());</span><br></pre></td></tr></table></figure></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><hr><ul><li><h4 id="构建用户评分矩阵"><a href="#构建用户评分矩阵" class="headerlink" title="构建用户评分矩阵"></a><em>构建用户评分矩阵</em></h4></li></ul><table><thead><tr><th>Table</th><th>小时代1</th><th>小时代2</th><th>小时代3</th><th>小时代4</th><th>…</th><th>疾病N</th></tr></thead><tbody><tr><td>用户1</td><td>5</td><td>0</td><td>5</td><td>0</td><td></td><td></td></tr><tr><td>用户2</td><td>5</td><td>2</td><td>4</td><td>0</td><td></td><td></td></tr><tr><td>用户3</td><td>3</td><td>1</td><td>3</td><td>0</td><td></td><td></td></tr><tr><td>用户4</td><td>1</td><td>5</td><td>1</td><td>4</td><td></td><td></td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>患者N</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li><h4 id="SVD分解（Singular-value-decomposition）"><a href="#SVD分解（Singular-value-decomposition）" class="headerlink" title="SVD分解（Singular value decomposition）"></a><em>SVD分解（Singular value decomposition）</em></h4></li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAA2CAIAAABhpBOlAAAgAElEQVR4nO2dd7xdVZn392256SQRgmCIgkBIoUuxvDoWVKQkQABhio5YxgEllNDTAGcYR2ccFRGRngaKvu80QYXQE0poYyVAenLraXvv1Z7ye/9Y+5x7bgogIsp4n8/+3M+5Nyf77LX2dz/raes5CYZkSP5sJPljX8CQDMkbJ0O4D8mfkQzhPiR/RjKE+5D8GckQ7kPyxov8sT54CPch+QOJAKKAQEUh2vR3DSoE5ci9Arrzs7y+MoT7kPyBZAB3AgSqqoAABA2QAA3xDQrwG3VNQ7gPyR9QCu0O3RZ3HcJ9SP7XSYN1gaqyKjdwV+X4BPAQ7kPyZhdtUu0R9AJ3ZQz8qgIdwn1I3vTShDtvg3sz6xH3IVd1SN7cEnFX1bpGL+x1EVJlAKJgAQsEOoT7kLy5RevRGG1iPeIe+R7CfUj+9wgLPAXnXBGKFAf10EDkY2iSgKBQgITfsMTTEO5D8vqLApaYASIffA7xbFNoCD4HJPch8xxx96JENIT7kLyJRQETiAFAmCzUgU1W7oVSmmcM1GwIQObie8Ac3pgLG8J9SF5/idF0x+K9hXr16aknfrQ9SdqSpKNzWNLSnnSOHDZ2/C1LlvuiumBIuw/Jm1YUCIrcB0Ak5ODs/LPPgrqN69Ycd8LxPeWaAx58fPXaTVuDgjk4m78xFzaE+5C8/tKUKxUlA1+FK3NevvF7114xf55leOBXazdZwBJ7bwF6Yy5sCPfXKLoT+WNf1x9KdjbeHYooLMMLiDw0QAxMPyg/95wvLFm21AK9mXeAB4JChJjsGzOKiLvs6GcAAkCNOp4dFWrK4L/HIjgZ/E6JJ9nuP8Y6uR2m1KT5VG9QhagOelk/dmpTqiqUIQESFKFR5lrkCItrjsOk37XS9RU/vS6x4opiZE+3uR31xCYARnEdvN1gX62IYiBh5KGsApE4NlaERiUMBKLwgFEwM8iBDTjLqj0HHTytu9zfm+YeyAi5EwVUWeSN0u6qrAjb/AQspG/9S6snjGtv70iSliRpbU3a2pK29iRpb2sfPnv2aSEE41KG5AxCnFZiGAalBqwIHhxIKVPNRH3MLFgXAGE4pzWFC1kWo68UoAwhrWVVBTEZhffqCAUwImCVQoNK07HdsxhT0zu8Y03HYFFA4G0IISjgxDsNDHFiQ4iRY6bgOBAaFIkAAa687OZvtw9Lkvakc9SuScuopHN4x6hRjz/8FAIyW2GYhx75aVtr0tY+LEk6krZhRx39vtyEQMIqAlWIgFmpcQiYIQFECApRZRERYqkPzIe6e6eB8/7Tjv/Q6PakoyN6gsOTlhFJ0tnRNrwzScYkbSOTzvFjd3txS28ZSKE18cVMQIpMvkhxHbrDtH9jwgXOkKnMOvYDI9uSEe1Je+ueScvkpG3kpVddDqTi+2+9+Vsd7Ulb0j6sfZdk+C433/mjoKDggCCSP7LqgY+f/IkcbAFSQGM9zUD+ddvbOvj+bHO8VtwR4hGf//rrXNxmoM/lWy666JyWzs6phx9RcUSAAs8994vx48d3Dm+78qp5AnZArnCegACYzFZUYQ0oxOty0BygalpTILB3zog6QZ7l/RCIUxZ4ARQcRCEu5OxrEtIA75jiSqPayNLVZ2gb3Aegfk24M6BgZoJWTM1DKrbCIIBq1bL4CD2IiAWpNYCQSxFKcN1CfRfMnZO0jO4cv9eK1asdAIZaMILhEnFJKTtx5kkjd9mtp79Wy0O8ah84qnAp0ovFQQXunhAUJGARilCKghgKMKuzOdiAaxt+9fikt7S3tSQLvzLfACmBAPaAF1h+5KcPjho54b4nny4BfSALBEdiCcqKIIUgnrxevcgFFQXxgCjVUkhQWwWX4De9/a3jkuRt869eXmZYOKAGLgHpfffePaxl+EEz3t1nZWvNMABFrdQbfDbn4nNv/eFiA3HRKojWvcQs1GAtth3Rrx/uxaYSGnSoBzLJu8RsuvnGbyRtrYu+9k0LZA4+MLGt1nr23XfPYa3JD+9aXiHkQAAUYrMyECAafKxuVmtqAEEhIp5ThSO2gFAwTP7C8+cSI2XvoHmeQ2GcVWVwABP5wEDN+KDFzRg01B2NXl8r7j43YALEuJwhBHEaUpdVamUANjdQkA+5NfE2eXJAAFVN3zpI9fwvfTFpGX3ZNdfmQMkaCfA25JwHZKAyfPXcOeffuvSHBHgFx8CFcfWEYlS0Be51XVq8rut+YSlgCAQANq1BAySDKz224j9GdSTtbcmS5XdZRTllVagXCMiEW25d8uDqZ3uJalCPuk2jLOpZJZ65kc+PuAuCIBTXEDWLEmdVCTm4GtJ1Z5x6fOfofe5+8EULBHjAiK/kef+SpbeeNOtUG5ArHOADi3dQopBPmbH/up4NFhIAlTruBBFhpUG470ReB9ybCBhEPJkafAXpxjNnf3T0xN1+9thzWVQbzIBh6V9x749GtCQfeO/RW7PQDxggtQZKsDm8gQRPjiGKAEhe894y4IzrzbMyOys+LFpw5WWXLywZl4MyGEDYeQCl/l6EABJTtSywQKqBiqXv5XBv/PZatLuKeGPyKiCWXc1lBImGuPc+OC8iqsoq/dVatLysq4FTcBX96/965vGtI3f7+ZO/LTEMNObGPSR1VfgKXHXatBlb+ypVE6ieXqkv4vVSwSbKG+ZEs8pvuAdEQp6hAnJwNcp6INmym65tT5LRo8c+suppAgwhEIiIVR5e9dhPHnjIABbwUW04B627HPXTNmv3HeAuARqcrUmo5qUX9tx97IgJe68voeS8V6viofTYqkcPPvSQcpp5IIvOmQhZA6UVP//JSaecGMDRPVWpu4eEomhsJ2bM64x7XE+3OQCBBLDd8psndh3dMv2II9dVfa7wAuEQXC+wVf3GKXuMHpYk37x1eTeQAVZITYbg4XOoI3Ee3lENGhCtUTZADchsrbT7hImjR73l3gdXpUAOV+FSnlUQ2FoLBdIcBASEAAv0+VrYHvc4Bfoy/G8jL6vdsyq08M4D+9RlDFhiRbTT4D2FwFpXSQTKQxof89Kvntxv/LgpB757Q4YcMIrMWQLXxHt1oHzz87/49Kc/4wECMs9BwUCaZ4Ep3uxtDhGKtyISTwgBTGCqV1NxEIhChV0OuGrfFrjswr//u46W1vaOET3lPGfE0IcHBTABedAgsIZABHLQCPQr4y4KVY1K2pMJXEXomrznLu3j9/h1V80DxtcAvLBm3YTxE594+pmUfY7ggcxZFYLSKccdO2pYW5IkRxz1Li86gDsXHnCB+6uj+PfHfVviYwGPr/T+8MbvjmpJzr9iXr+iTEgDVDxQhWzIS8/tP7FzwsjOi6/5xmZFL9SBNTcIBGfuu+e/2jpak/Zk3FtaN216fuZxZ7Ynb3n44YdF0n32HDMsSUYOH9PSPiZpH33BvPk5jEem3jz1yKokSVpakgkjh/es3XjScad3dOxy36qVFvIyuDeIf+24Q8Au5OWZxx/TkiStbcknzzzDuuBFnS/W+hX3P/jk6qdNIMPBaSAQI5Cm4Mr/ve4bY5Pk8iu/1sPIgFpghjjxNXIBBMqXff+7S5fdkZJUckeACZRap0BgavDdOIp7zwBDRAgcCSUQRVOHCysFCuHgXQYE2Jyr5b889dS2to4pMw7ry4MFurJapoZALngmqMDlDBUUDhttYxDvDHeBQkHkCQEwa55eMWnXEdOPfM9WLwFcrfU7xsyTz7jl1qXl1DiIRbBqWT00QEnyFCKAWGuJlaWOuyikHjR61RS/LrgPdvYQIDW46l8ef9Lo1lHfX7q8n9Eb4IryhirCWvD6z5368fYkufAr/7o+oALkMPABAacfN3NUR+dDDz2kcJl9/qJLztp9t3cefOAxpWoQdvC9t33v60lL68WLvuqAAOSc5a7/5GM/MSJpe+aZp6zPvKleOvfCCRMmT5l+VG8lNVwYM9IEvWz3l99jsRNINuv4D7a3JMM6khiMau/oPOjgw3NDClgn0w46dGtvX1B4CAE5WUOZSBWanvqh901ob1+x6ukKkDIocgxhSC0rw2efnHXCxk1bfD2yawJ54cCEujEDZRVSFkjDaRuEu0fwCAGByCtLtMtdaoVYoNZk8BbOINi3ve1tSUvHsSefniosYOGCZPGErqZgZFmN4QSBELhw0eue/2DcqVhSQIDzlFpDCMb0PH73nRPakxNP+2Q/Iw+Zgq698ZZjjp/NgGN4SMlVGCGIgXqwJ5OCCApVRA+kaUVuxEjfCElkW60pqjGs0Nf10i8mjpy465i91m/pqQIpkIqKekgNvIF6n5ux18SRHaPmzP/nfqAKyzCmUtt3j73HtI0ubS0pg7kGvDhnzmlJMnr+wuvj06KVjWfM+mDLqJH3rFrtBSzIfLr3PpPGjRxb3tLrXQY4l/fNvei8pHX05Vd9gwHnKTpVzYi/rrjT2jXPffwj7/Z5n5J56cXfTpw4MUla29qHJ0lH0jIsaRt+6byFDGTOE2CFCPCcA9WNLzy566hhRx56RNmhzHDR2iEKwYl6gF749f988XOfYaAavFOtORcJM8bECY+BzgbuQD1SxDGwPYA7wYsQky8C7gwgxmejcx9CXn3xxTXjJ+7ZNnr81mpashnBhlCBSMyjSIgndDHyQ/XNREXSoJjhHeAeH9SK6weqd137T7snyWXzF9QEBF7xwH3Tjzy6z4oNUMCyYxBpDjjvUoCg4nMTg1AxjDDIdSnO/UZIIopAAiCEEF0LJg+kkr90563fHJ6Mmz3rCzbAQnIgh5A4UBl+Xf8Lj08av3try/ib7ry7rAjIBdULzjt/WNvoO5f9u80EHuAM4fm5F36ypWPsyqc31ASBbfea5/Yc0zHj6Hetr6TMgODCuRcnLa1Lb78TBHAOpMF2zTnvi6277P7fDz7FANdng4Rd8JHvwMVaHJhYRQFPQQFrB6XoQohV1wBAtLNppdtvue7pJ+6H5lDLLnfGhsB7Td4nSTpa2kccd+IpTmAZBFgKjokB71L4rXfc8q9Jksy7+qsZYAo3X+JK7U0VsLfffuvS5csYCEBqHdUvXoQAYfJafxEvxRhTECGwuWOliKZVE+CYA5ShUIbNXXyj9Q5KIa+quMyk+02d0dWf5kEV8L4KGBgrKYGhCgvKkQcEQ7kXJiix+sCN+SHy1mcKSl2W+ZwBr7AKD2ShhNBzzw3f2DNJFsxbmCty4/Y9YOq9TzyZFSlSYWYWxzAKp/CKYE0WnIeCAkLgoIgqI4AUIuqJLYAYDFDVEMI2N6vxT/Hvqjp//vz4q/fFvDG/8pbXJE49gEZEMvgcVBHzwoJLPt+SjLnxpv9QIHWZA1INQQxQRdj4xM9+1JaMGj12v1+u7XWA892rH/9ZkrQed8IZxiM+5mATKr8+5aT3Hf6ev1jbl1dBDLfsu9eOa229eNHCHCATVt6/MmntPGH2mYXSg3HV9XBdxx3/kf2PeE8PI3OI62CUiHhujQLWuwh6g/40zwDEKYtzNED0TllHNDHI9gEGIQN7iHobWFDcbIZXWJGcyAvXU6cB5TWfPOHdraNG/mTV0znggZqxQCwIFISMOZt5yskbtvYYZl8PvuXWGGeJfAgush5/eu8rlQqAEBgEWzNQAGJ9xvX0iCoTeRGEwACy3EZ/GiBh60M+6+SZj61+xsUUSYzCVLvBAoZJ2REyeANHIK+Oo0MJGOvjVDGzCLE4T0aLbBcyz0aQqzBSMZu+dvZnJifJbTfeXsrpxJNPXfbDH9eAsogXZvI2zaAi6oJk1mcuWAWIRAixztcxZcF5SBaMISv1sYsIAOdcfBHvFzM3U16tVuPrhQsXxrfFex012sveYgBIIjdEpMrCTskAQV0fV9fs9/Zdxk7Ya/0WX65kgJQz6wFRE7JNSNddc/nclpY9jj3xbB+Xdb/ltJkfGLXLhJ+seNzEZDUH+LT3pV9OHD/q8iuvyYAa+mpm8+xjjh+TjF759HPVYOHtCR85pnPcbg888+uqwjKgGVxX/9pfTNhl+Nx//KfNHmmAKlSLwaRpGl9EXc4qnkJjnETkrYMoc4iT6JyLU2mt38kkCEA26/em/4xTj+9IkvYkOf2U2VD4wCaIV2SeH3pi9f2PPhpj1qVyFQpKK/nG1XuOSaYedXSPohw4PuZ5msECAfDVhx665xOnnGwBp8pANa1Z7wAh8tGMcTYP3gISgmuU3RCJCKAIzgsHgJytiTofMhFSSEzAuuAVUFVrcxZrQ3r2nHMWL19Wrtm4PqhzEAs2CMHmIeb8HcSBPHwp7bfeKVDMjMAZK/WarcxUSYLUjZmajyZ2CX7LX7//vW9LWp998n++f/sPPnrcTKOwQE2DJwP2iFkrBIZjCEGruWGBdzFPJ56Ch/SbqocwxHurLPF5jQYeM2dZhiJ1DQBRec2bNw8A+QDRRYsWoTAaQ+MNr1izVAQi8zyNYTgJqbgauLL6kX9vT5KPzTqjEqCAELMgxuVcvqX7xaffOm5s0r7XvSs3GAKQrX9uxd67dR5w4KFbMqkBDgGhBjYLL7yoPWm/acldKaiqG9ZtfmrSuEnvO+SjtZwN2Zd++dTbd9916ruOXlPKM8ABCCVkW+ed87lRw9quW7asAlQ8IszkQ7NV7pyL9zuuTnFqREQ5ht1FhOL4G7Mg24dk6rgDbtYJH21PkpEdLe1J0p4krUnLEUceXc0NARbY/6BDusvlmrHE8aSgtNLzq/v2HJPMPPNv1qZaISEgM6kWiwJD7CWXzHlo9VMVgmGObAWmEJwIpWk1Ek/B1emHcTZaZtG6UCGQC3kNGsilAJGEhnOnQJbVgrcAEWc33HTdgquujA+kdzGeTDFe/uMf/ziaEGXrCaja1KtjkAIueFV4T94GKIQYEGGn0S2GGOsz570ggAQln25816RJe7SOXvXos0e8/5iMUfGuGjwBLuRQr94gBOczBWXBhejMMJThbRBihfSlfQ7BggzZ6LEQUajbrNEcZeYQAjPHX6+55pqIuBBDcemll0aN7pxrur+vUGWUkHCa1wBScSaNq3kFWrtkzudGdiY3LP1hVWG82tyRAwTeVAFz2skfS1pbblh6d5UhCvjyj7771T2GJxfPv7qLUIXmSIHyg3f/eFTLyLEj37Z2Yzlly9jy0/uWdCSj5l3yL7kDIIu/9y/DkuTiRVeVgJLAAqDyMw/fPb6lZXjrsJf6+nuBGkXLARyoQFk0jhOAMUak+GPMfbLzxT1rKjwyxni/s5VOAHphza8+8sH3IRgyafem9W/ZZWxLkrS3t7cO60ja2pK21suuutJyESkWhjMECf1rHtlrXDJz9pllQZ+pWxAag8r0wm9/8aEPvz9TVLmoho1anCPcGgASDhH0PM9jxNO6wEDV5hy9WHJg0ixd/chDnW2tBx48oz+tVrypBsvxQSXLtvrQ/fec/smTCShnzjICAUyc1Vxadjb93NlnO8ABDzz+WEtL29FHHlWrVVh94dUohBRB2Xl2nslDg/PZqlWPJi3Ju444Ks0zQFjy3Hdx6D983+mdyYgRY9768LO/rnBwKEx/Uc9kgPDgA/e2tbVMmzE9CyEAllQUxUBViK2D86CcLKtAEDIXq5UESsIi4r2vu/IAsGjRossuu2zh/AUL5y9YMG/+FZddHrVYvP6iEOJVSEISFGRNNa/1AkZ8CaG08YXn9pgwesyo0S92lXKgkvvCeTKquXvHpD2SluTWH9xZAVKgVi3D1/7z+n8ZmyTzrv5qL9BFeUX6Nm988sPvPWiXEbvPOv4sFvjAuXvxoks+3dEx5tGVawLjN7/51Y+WfmtEa3LZlVf3eaQKK7Rx/S/f+65pE0eNP+nE03OgCpiiPMlGs11ZnLHBeTR5pcF5DiTEHIoIrndGlUMIjffsfKETQBbffvNjqx7OqyVIAHuQ0+D33POtLcNak7Zk1hmnecAJYo1Y8ApFqXsz8nWnHXv0uDG7vrSp5oCyy13w5IMxGUAnnvDxJ596IiMUvozNvbcxDhNVsrATDqrsvW943o7FcIimLZOFM/AeWQaSR1asuPLqqyykws5B8pAxGah78Rerj/3Qe7q7NjKQhqJKgGwG8RTMpHe8/cKF8/uYqhAPPPHIY1dfvhAQVh9CICIIhGK6JYb8iV0eDcN77/3ZFfMWhBCcrYlUFdXf/PbZieMmdbbvfv3td/UpKgglW4MCPnogwYcacfbIIw9dedVX8iBOkFmGxiVJxOVQn4fUqnFiAXAtwANS5N3iXYomiqpG252ZFyxY8C9f+3q0ZKBQ1YaT2ngwXo12DwoSthADycA1hPIVc88eliQHzjis7FAD0gAFfCXfe9e3DU+G7TZhj/7cllSqQAbWYBHM8/f+1+6tybCx45/Z3FUDblj+ncMP3/26by5oTUbdctN/Xzz36w8/8KRPN++374Tphx/RncqJsz+9cuXKJx++a0RbMm7C+HLKDNx8+20HHvrOb337ayOG7bJk2X9+Zs4FK556ggEmDxYQg8WmWSxfifZ68WRHlR9/smooEthxRuJ0xOqTneEuQioEFVBwaQVKkCDqGeQhBmygAcg9QyFRjbOF9iDbNHnCpI6WcSsee8KiqMF9Yf2aEWM7ly6/XYHMwzIQ9Rp5Co6CEXbQoFJY8ESkQG5c9GWtkAGlkiOGDa2DJ1TSy847f9Xjj3WntRzIEHLOgeBLXdMnTxw3LBneliRJR9K5S9LSmbS0drQnLUmStCbJ8M5zr1pUAUrwHnLFuZc899DjGnxmqgCY2dsQVSwCw5MGD6U8q3hvr7xy4eNPrCbyQCbU57j3nvvvae2Y+KFPfKoC9AEZyMPDKyxA7ChzqBLyyy677InHn0kNEWA8vFMYhRcED3UKF+AsG4jCAqmgXhPFKtHqi1ZKQbACiisXLvLWxSAP6uGa+GBgu4jcjnFXSH07SVDKLjr/i2OGJdF47WgfmbSMSIaNSjpHJknrqNaO9xx8hC87MDJFH/sqvI+x3FoVtdKya7/VPmJ0MnJk0pFcfOWFgu5bbvrXJBne3rHHD5bfKxbw6d5vf0syrKNt7K6PPPaciKjffNfybydJkiQdrS3D5i24guGu/d63WltHtnWMv+2HdxmIgmxaeedee40dPrzS0zP3vDlHHnZonmYP3v9AkiSLFy9m5qlTp/Z290Tibc0cOH3GhvVrmcMee+w+ZsyY7u7uFStWdHaOmDd/4c5wj9YzBQcKUAF774wi+mpiOASol8Jqh0b3jhD6wTU43PK9pUlre9LelrS0JUly6JGHZL7mghVFZlkLxUMAmby616S37jJ25MYNL829cM5hhx6cptVHH320paVl6fJltSydPuOgLT29seLA5ubQA6bWNm1CbpDmh804aEvX1uNmn5QM70zak6989eos69tv0m5j2pLOJBnR3jKsc3TS0jli7ISkpbWlNWlrTZKWJBkx/LvLl/SITeGNSw975wHVDVtPPH5m0t7W0tY6d+4FM6ZP7evqjouCqWSHzDiwr2szEAKZvfd+++bNW48//vi2JGlrT+YtuuCGW2884KD3dddQBWpAFZ4g8IoAqARKFdWe0tr993vn1i29M2efmbSMaO0cs3DB1TD+sP33t91dcLkqWwr7T5u+du36A/eZtuuI8Vu3dv/8/hUtHe3zFi2keiIlaqvCGXU+Lt0xFIGmOAwRxSjkK2v35lveVChWFFk1MgKNJyz+wo26uiJLIuAAZilyBioICgv1RSF1PLcyNBQdkGOYDA6wA3XVEAUFtgBc8AwieIV3tkZp5a9mn/zFv/3UrddfN/2de9+5ePFZn/qbC86fs2DefAClUuWAqdP7+su5cVOnHdTT0wMIk1XlWbNOvPun98w8adajKx+bNfv0ovRvm47jzWUFWg/hFf+04+yVqqoy1ENCUciqMRUezyGNzRmx5kTFAyEGvvJa/2mnnPiFz37q9ltu2Pcdey2+/eYvfP6zF5w/Z9HC+SqUVmsHHDCtryc3GWZMPazcUyJTg7rf/vIXnzvrsyI0f+GCrt6KJVUIS25MH2CgoVEJWr9UAcSYTCEBnuFEzUvPP3vOWX8F8vMXXN1dynLvHGVMZtrUKX1bS2wwbd+Durf2AAHInn/h2bM++6ngdeGCr6zduIEhhJDmNWaFIpDEZIIJokUgwYrvB/rWrVl51qdPDyqXfOXr60q2qvAAJEet991TppTXbZaAqdOP2txdY6DaXzrj1Nn3rrjvw8ceu3L16k/MmuVU63Q1DtmmrOjlsX5F3H9f+Z02dxWsNNW+NqoCAWEOALE4FitqrKsAbtVDK848eebP//P/bXj+1x//8F/MnfOlUk/36aecfMey5d46AGlm9pq8z/ARY7Zs7SVWJgvQAw+suOKKy87+0jkCPWfOBZcvuJLqG7Qihahj8XqNdyfvZCCQq7KvQe3Kh1ecPnvmvT/9r5fW/OpjH/6LL33x812bNp4y88Q7ly4R7yAsjvfY7Z2jOidWSz44AWwIleuuu/aOO+6YM+fLP/jBD4jgHFhFETyngYrk5Y7GIrW0BPUQA6otuenb/37nzV/6+7Nuvu0HVuEhQQzgqpW+SbtPHtO5W9fmChRp1md97+Kl1y9bftuF511y++13EVB2lqDOZ1BSb8Q7DqKADcg8K8C+pq4HYctt1131g2U3XHjp3G/ddkefogZUgwdV4Svo75sycfLItrf09nMpBwFPPv7EeXO+/IWz/94Df3fenHlXXWVFDDMDoZ5UibWif0K4/67SzHcz7tGoUISIOxCMLRtbPu/LXzz84Bns8sW33NieJA/ff++6tS++dffdurd2RWOuUqlNnvyOiRPf+tKLGwBQcNDw5S+fM2JEZ7layUx+yulnPrb6mW1wV63vSfsDjlRVOWp3IGRp6dJLLjjqyEOztPy966/taG999pmn1q19cdLb9ujashWiQpxWs6n7Hzxi2PgtG3ugMLbMmp5xxumxfm7ZsmVMgCA3Lm7+0ujr6aDNkI0sPbGNuC3W9hUAAAnnSURBVJta95mnHDuiJRnZ2Xr70h9XHSomY7jclCrl3in7TB0/avferpRjIJvLM0/6SNKStLUMi7inJAwAFEwK9tC4J6rInWUmV8qAlCvr/va0jwzvSJLW5LYf/6SkKAs8oLYK04+0uv/ue44eMaGn5B2QOr547iUjh4/Y2tuTkz/1L89Y+cTjDFgK8WdDwW/bSfg1yZ8c7oWLGXKAWCyxAVyg/KCDp/WXuo2tfeK4jy6/YzFA119/3exTTooBSmf8ke86asumreWe0hGHvKu/qw8Q77IpU/ZbufIRBX675vkPHvPRnlK1URT1xuMefBZ85l069YB3bt2y3rvstFNPWrL4NkBu+N53Z808IUaUs1p68IGHbNqwlbxO2W9ab08XYH7z/Or3f+A9zrnzzjt34cKFNo+VBBBobjNr83rtTdPnRluUQ5Eph9u47tcf/D+HUdZz4XnnLLzqazGG4zm3rnLIwdPXv7CRDaZNOaynuxQoX7v+F8d87D3GVi+56PIF8/8hdeoBx7Fgs0gCeO+J4aWxQ9fDlbrX/s8nPniIS9edf+EXL5h/dQ0oBTgAGpD2HrL3pNLG9dbQftMOWt/dVzV+2gEHrl71JAmv3bjhqPe+p7u/j+MHbVet+SbGvd4Jtlh8G8ZATCkHMorAYhVeYX++4u6TTptl2FVNbfohM7p7u6w3X57zpaVLFwfnS339B02b3ru1K85KVqocdMC03q1b1jz/qw9/+IOVSslTuOW2Wy++/Aqqp/HfeNzjxshA5sGH7jv1tJOyvBKCmzJlv+7urd7byy+/fNmyZSKS5/nUqVO7urriAuS933e/d/T2r7tt8XWXXjYXwH33/fyII44q9fl/+9fvM0EahBclA2j8VuCuFHE3pnTbzd/5yqKLgOzhB35+wPTDeqr+m9/9TrnWu9/+k8ulHghcjWtlN33awT29m2+46VtXXn0psXn4wZUHH3RkKfX//I1vMxCCi/vdomukgAligoiCgoG667/xj/+04AJo76OP/nS/GYdtqeHr1y+rOvi8dvi0vWtb10Mdke9P08lT9n/i6ec+/Bcfy8q5qn77O9+68upF0e0hCY04Y9M0vpzR+GrkTw73GJkW9aLR2w8sdukdt51/yYUesuKRB46deVwA1Wz6jn3enrQmS5YsiTfWZbmtpojZayKbVpYtve2aa/5BhALTl879clvn8Ej8H8OYUVX2IRf1t9524/wFlynCgw/eP3PmCYBkWW3y5MkxyoR62JSCi24MiwXSc8/77JKlt1prmcPEiW8dOfwtTz7+ayhU4IM6F4NxhdU+WC8K1zuQzvnS55ctvgEwJq/s9Y79OkaOe+CRh4MYIORZpYhQCJigCOee/4WbbrlW4dOq2X+/A1s7xzy06smasXHZhLg4kYEp9sfzgQFRb6644Ms/WvJ9cI/JuvaZcmDrqD3vefBZBwjHRHvu0n4SRxAL+bdrv7PgiqtA8N5fMPf8JEkuueSiPE/jWJqrvv534h7zjkQ+equ1tB8IjrIANmArlJOPhl1uTdRmxhjvTIyai3egwM5GlZbnKXNh/wUSrYM+yFXdJubyeksBuxIruWADewHnNosLdIwxN8qYRWGsD1wscYD4kHkqAcbaHEUlH7KUILCmaE/QmFQ06/WiWNIopFrrj56DqgHn0NCIrQUxPmTQAEGwanLKc8vqGQZwxDY4ghalcrG2OUbYKBgR0lib5oICyqLBQwg+g+0BTCBkARbwQJZXoDlgAMfqA7jYHsnFTmfE77EBAWLy1DvT7HYPrP8vt531FeRPEfdozRN5G6tE2AhCAAVoBD1zlgFPodGbQOp1hVEpNlL0sVBMoLk1RUn39oHINwR3AQf2JCGqWwGzCgkL1FMoCpgDD3S/KOoEY5eK3IcaEGt+xPuimBb1paBRM6Lb4R4NA0BYHAWj4oAg6oPCFWUwQdgC4m2I/0EVgiCwWV4GCAJhkML4Yg9uI2CtCJF4FhAV+SB1AcGBU6gThhcYIGNlOCBXNVpU0ks5rwqUPMfigiwtx9RbrA+FsjS1Sn1z494U6R+EezP0zVvFJe5Nhhab5wd2ewzsX44YDWy3Hdjh37QHarB2/z0Xx99ltDvYlRJHQcKNLjONwTSLwit8LAstfLViSFwkSQaDvt1RbOlumk8JCg8EEKuPhBU2XTF9HFNHitA4BQ10xBi4NbEpiDYqtItZjnudgwqCwAEOzMgEmSKoKgFBJYAEXBQhMYF9cRTffcBoUogYPKjXJn8quGNb4hsOeDGtBZQS2wAN7GxqtCIicAAFUOzTom8e3Ae1vtDtVh6gqHQvIo2x6j02JAo7a/a2Q+KbtLLEaWUlqePevHWPlVi9qI+bxLX+uGyPe1P3paaqJAWIwSqMILHDmCekjCw2rpHiSSKJbbxiczKpH38OuGMnxBcz08SpsjTeRMKscUMnB5AH+foW5qYQZ0H0gJVc/1Pj+MOPdse4v/xGRGyv0Qvc4+V7wDVw3+YTt8NiYMIVEnvtxZ5NxXdYSzEVLIiKg5XqXx42cFX1Kxy0fm6zNsfaFxAkbktBCLCEVJBHw67xUAm8FGtI88GD8Ri47KbuAa9F/rRwxw6JbyiAwf1BmnGPjeYI7EHxVr1ZcNft/mlb3GV73H0D91ipEb+Sd5tP3JEWHJjz5m42jbmtbwqPXSeLvk5NtKH5IgefsOGi1C9ToAzhuCwEhlMYgVUdOIUiCHzjSup+Ku2Q9f+duO/0PfWv5Gz6Yk7V2OKwCREamEzRwbjHM26vh34f1+fVi+5IRAbVUAzqOVO/LtmBdvf1q/eAravD30kG496kPuKHNLZsN5tAA8TvwNEfaIRGjSZQDfMMqtGvRRjwy5QVXuBjQ9d4VTs/aPDxZsNdBy1YO5OmJ3vbb+Xk+nnqHNd/1aJs8c2Ee3OfGRES9fVOLzqQTSxijrEtQGxBXDTjfQ0DkAI+lqaGH6qFOxGKYmgVcL1QuTD6iydw4ETRDSpuCsWOCGBq6oo84D8UqWCFMNQDucA3niTdiQ2zI9xfI/F/1CIChJfHfZsiuKiNGnGYHfzfAScUGGS6DHo8BmhrWh3/0LLNWLZR5zvC3QpsfbBBMBj3AroADYMGsL2X2qS5m4w3LR6nGFdh1N0hrrM+kHSChhi+jK0GBs7dyBRE3BE0ZviKI1BsyVQv5ImfCwWEITZ2clH4hqMt26zMhdGyPeg79lVejbx23LXp5+8u29TJNJ12kAxgUb/xumPcGy5sU9ueV8a9yWJ+jeN41fLyuG9LvHpBPEIz7gDQ6LklGvs8RprrH/NqcS8iWiJ13NEIeTXKzesnpUY7we1xL+a83i5GQZF4RmBIA3eJC6mgwF0tNAdyRSCtb4kcuB0DrWHrqr3552vX7v8fibQbdMjL5sMAAAAASUVORK5CYII="></p><ul><li><h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a><em>几何意义</em></h4>  <img src="http://img.blog.csdn.net/20140524002918937"></li></ul><ul><li><h4 id="降维原理"><a href="#降维原理" class="headerlink" title="降维原理"></a><em>降维原理</em></h4><p>  <img src="http://img.blog.csdn.net/20160730135911445"></p><p>  分解后，U、V是正交矩阵，∑是对角矩阵</p><p>  <img src="http://img.blog.csdn.net/20160730141314586"></p><p>  舍弃不重要的特征向量，把数据集映射到低维空间中去，构建近似矩阵，达到降维的目的</p></li><li><h4 id="SVD的作用"><a href="#SVD的作用" class="headerlink" title="SVD的作用"></a><em>SVD的作用</em></h4><p> 将高维空间数据投影至低维空间，提炼出主要特征维度</p><p> 维度的降低极大的减少计算量</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法及实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sprak </tag>
            
            <tag> 协同过滤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcd4j阻塞排查和解除过程</title>
      <link href="2016/11/03/etcd4j-blocking-investigation-and-lifting-process/"/>
      <url>2016/11/03/etcd4j-blocking-investigation-and-lifting-process/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/etcd4j/debug.jpg" alt="debug"></p><h2 id="先说一下背景"><a href="#先说一下背景" class="headerlink" title="先说一下背景"></a>先说一下背景</h2><p>最近将整个微服务的体系从原来的通过使用<a href="https://github.com/tonydeng/tcp4j" target="_blank" rel="noopener">TCP4J</a>加上固定的<code>HOST+PORT</code>的方式转成使用<a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">ETCD</a>的服务发现体系（大家想了解ETCD可以关注我之前的两篇博文<a href="/2015/11/24/etcd-the-first-using/">初试ETCD</a>,<a href="/2015/10/19/etcd-application-scenarios/">ETCD应用场景 </a>）。</p><a id="more"></a><h3 id="基于ETCD的注册-amp-服务发现架构"><a href="#基于ETCD的注册-amp-服务发现架构" class="headerlink" title="基于ETCD的注册 &amp; 服务发现架构"></a>基于ETCD的注册 &amp; 服务发现架构</h3><p><img src="/images/blog/etcd4j/etcd-registry.png" alt="etcd registry"></p><ol><li>etcd registry 做为服务中心，提供注册与服务发现。</li><li>资源服务在准备完毕之后将服务实例注册到服务中心。</li><li>客户端到服务注册中心根据服务名称获取资源服务的地址。</li><li>客户端获取资源服务的地址后，调用资源服务。</li><li>资源服务在关闭时需要将服务实例在服务中心进行注销操作。</li></ol><p>我们使用<a href="https://github.com/jurmous/etcd4j" target="_blank" rel="noopener">etcd4j</a>这个etcd的java client实现，在使用的过程中，etcd4j-client会首先去请求一下etcd server，看看当前etcd server的版本是多少。</p><p>比如这样：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">http</span> <span class="string">http://etcd.dev.cim.in:2379/version</span></span><br><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">44</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Wed,</span> <span class="number">02</span> <span class="string">Nov</span> <span class="number">2016</span> <span class="number">08</span><span class="string">:21:34</span> <span class="string">GMT</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">   <span class="attr">"etcdcluster":</span> <span class="string">"2.3.0"</span><span class="string">,</span></span><br><span class="line">   <span class="attr">"etcdserver":</span> <span class="string">"2.3.7"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="看看问题"><a href="#看看问题" class="headerlink" title="看看问题"></a>看看问题</h2><p>看起来貌似很简单的情况，但是在改造某个项目的时候，在这个简单的场景下，出现了一个问题，让@webwyz同学头疼了一下午。</p><p>在启动项目时，就停在get version这儿死活过不去了。</p><p>日志如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">06</span> DEBUG m.etcd4j.transport.EtcdNettyClient - Connected to etcd.dev.cim.in/<span class="number">192.168</span><span class="number">.1</span><span class="number">.86</span>:<span class="number">2379</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">06</span> DEBUG i.n.u.i.JavassistTypeParameterMatcherGenerator - Generated: io.netty.util.internal.__matchers__.io.netty.handler.codec.http.FullHttpResponseMatcher</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">07</span> DEBUG m.e.transport.EtcdResponseHandler - Received <span class="number">200</span> <span class="keyword">for</span> GET /version</span><br></pre></td></tr></table></figure><p>正确的启动日志应该如此：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> DEBUG m.etcd4j.transport.EtcdNettyClient - Connected to etcd.dev.cim.in/<span class="number">192.168</span><span class="number">.1</span><span class="number">.86</span>:<span class="number">2379</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> DEBUG m.e.transport.EtcdResponseHandler - Received <span class="number">200</span> <span class="keyword">for</span> GET /version</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> DEBUG m.etcd4j.transport.EtcdNettyClient - Connection closed <span class="keyword">for</span> request GET on uri /version</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> INFO  c.c.a.k.etcd.EtcdAutoConfiguration - etcd version is <span class="number">2.3</span><span class="number">.0</span> , urls are [ http:<span class="comment">//etcd.dev.cim.in:2379 ]</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><h2 id="排查异常"><a href="#排查异常" class="headerlink" title="排查异常"></a>排查异常</h2><h3 id="是否是网络连接问题？"><a href="#是否是网络连接问题？" class="headerlink" title="是否是网络连接问题？"></a>是否是网络连接问题？</h3><p>当时我查看网络状况，网络连接也是正常的。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">lsof -nP -iTCP:2379</span><br><span class="line">COMMAND   PID    <span class="built_in"> USER </span>  FD  <span class="built_in"> TYPE </span>            DEVICE SIZE/OFF NODE NAME</span><br><span class="line">java     7142 tonydeng  317u <span class="built_in"> IPv6 </span>0x235c7b856fde6855      0t0  TCP 192.168.2.231:50774-&gt;192.168.1.86:2379 (ESTABLISHED)</span><br><span class="line">java    12179 tonydeng  293u <span class="built_in"> IPv6 </span>0x235c7b857295c315      0t0  TCP 192.168.2.231:52504-&gt;192.168.1.86:2379 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>甚至通过tcpdump来进行抓包也没有发现什么问题。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo tcpdump host 192.168.2.231 <span class="keyword">and</span> 192.168.1.86 <span class="keyword">and</span> tcp<span class="built_in"> port </span>2379 -vv</span><br></pre></td></tr></table></figure><p>看来不是在网络层面的问题。</p><h3 id="追追代码"><a href="#追追代码" class="headerlink" title="追追代码"></a>追追代码</h3><p>从日志上看，最后的输出应该是<a href="https://github.com/jurmous/etcd4j/blob/release-2.12.0/src/main/java/mousio/etcd4j/transport/EtcdResponseHandler.java#L100" target="_blank" rel="noopener">mousio.etcd4j.transport.EtcdResponseHandler</a>，先看看这个类的代码(有兴趣的同学，可以在Github上查看<a href="https://github.com/jurmous/etcd4j/blob/release-2.12.0/src/main/java/mousio/etcd4j/transport/EtcdResponseHandler.java" target="_blank" rel="noopener">相关代码</a>，就不列出所有代码了)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Received &#123;&#125; for &#123;&#125; &#123;&#125;"</span>, <span class="keyword">new</span> Object[]&#123;Integer.valueOf(status.code()), <span class="keyword">this</span>.request.getMethod().name(), <span class="keyword">this</span>.request.getUri()&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!status.equals(HttpResponseStatus.MOVED_PERMANENTLY) &amp;&amp; !status.equals(HttpResponseStatus.TEMPORARY_REDIRECT)) &#123;</span><br><span class="line">    EtcdResponseDecoder failureDecoder = (EtcdResponseDecoder)failureDecoders.get(status);</span><br><span class="line">    <span class="keyword">if</span>(failureDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.promise.setFailure((Throwable)failureDecoder.decode(headers, content));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!content.isReadable()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!status.equals(HttpResponseStatus.OK) &amp;&amp; !status.equals(HttpResponseStatus.ACCEPTED) &amp;&amp; !status.equals(HttpResponseStatus.CREATED)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.promise.setFailure(<span class="keyword">new</span> IOException(<span class="string">"Content was not readable. HTTP Status: "</span> + status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.promise.setSuccess(<span class="keyword">this</span>.request.getResponseDecoder().decode(headers, content));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">            <span class="keyword">if</span>(var10 <span class="keyword">instanceof</span> EtcdException) &#123;</span><br><span class="line">                <span class="keyword">this</span>.promise.setFailure(var10);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.promise.setFailure((Throwable)EtcdException.DECODER.decode(headers, content));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.promise.setFailure(var10);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码上看，应该是阻塞在<code>decode</code>过程中了（如果大家看到上面的代码和github上不一样，请不要奇怪，这个是用过java工具反编译出来的）。</p><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(failureDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.promise.setFailure((Throwable)failureDecoder.decode(headers, content));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是这样，那应该是在进行version信息的序列化时出现的问题，看看etcd4j使用的json序列化包是什么？</p><p>通过<code>mvn dependency:tree</code>命令查看，这里果然有问题。</p><p>正常启动项目的jackson相关的依赖及版本</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[INFO]</span> |  |  |  \<span class="selector-tag">-</span> <span class="selector-tag">org</span><span class="selector-class">.mousio</span><span class="selector-pseudo">:etcd4j</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.12.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-core</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-databind</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-annotations</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     \<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.module</span><span class="selector-pseudo">:jackson-module-afterburner</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br></pre></td></tr></table></figure><p>异常启动项目的jackson相关的依赖及版本</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[INFO]</span> +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-databind</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.7.4</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-annotations</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.7.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  \<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-core</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.7.4</span><span class="selector-pseudo">:compile</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |  \<span class="selector-tag">-</span> <span class="selector-tag">org</span><span class="selector-class">.mousio</span><span class="selector-pseudo">:etcd4j</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.12.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     \<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.module</span><span class="selector-pseudo">:jackson-module-afterburner</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br></pre></td></tr></table></figure><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>既然知道，这儿有问题，那就简单了，在启动异常的项目中去掉不一致的jackson依赖，一切问题就都解决了。</p><blockquote><p>etcd4j项目中也有人提到类似的问题<a href="https://github.com/jurmous/etcd4j/issues/116" target="_blank" rel="noopener">i update version to 2.12.0 my programmer has been blocked #116</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> etcd </tag>
            
            <tag> etcd4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为ZSH实现Fish Shell的效果</title>
      <link href="2016/08/05/zsh-plugins-like-fish-shell/"/>
      <url>2016/08/05/zsh-plugins-like-fish-shell/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/zsh-like-fish-shell/fish-shell.jpg"></p><p>很久之前就见过同事用过<a href="https://fishshell.com/" target="_blank" rel="noopener"><code>Fish Shell</code></a>，看到几个非常棒的特性和效果，比如下面两个特性就非常吸引我。</p><a id="more"></a><h2 id="Fish-Shell的炫酷"><a href="#Fish-Shell的炫酷" class="headerlink" title="Fish Shell的炫酷"></a>Fish Shell的炫酷</h2><p><img src="https://fishshell.com/assets/img/screenshots/autosuggestion.png" alt="智能提示"></p><p><img src="https://fishshell.com/assets/img/screenshots/colors.png" alt="语法高亮"></p><p><code>Fish Shell</code>的<strong>智能提示</strong>和<strong>语法高亮</strong>，是我觉得非常酷炫的功能，让我眼馋，为此我也试用过多次<code>Fish Shell</code>，但是每次都坚持不了多久，因为还是有很多地方不习惯：</p><ul><li>无插件系统，功能上还是比<a href="http://ohmyz.sh/" target="_blank" rel="noopener"><code>Oh My ZSH</code></a>少了很多</li><li>不兼容<code>bash</code>语法，导致我之前的很多脚本无法运行</li></ul><blockquote><p><a href="http://ohmyz.sh/" target="_blank" rel="noopener"><code>Oh My ZSH</code></a>才是我的真爱！</p></blockquote><h2 id="Oh-My-ZSH"><a href="#Oh-My-ZSH" class="headerlink" title="Oh My ZSH"></a>Oh My ZSH</h2><p>那么问题来了，<code>oh-my-zsh</code>中有没有插件可以实现类似的功能？</p><p>我先是在oh-my-zsh官方插件库里找了一下，但是没找到，后来发现了这样一个项目：</p><blockquote><p>zsh-users</p></blockquote><p>上面的介绍说是：<code>Zsh community projects</code>，感觉是非官方的项目。</p><p>里面有两个插件：</p><ol><li><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh-autosuggestions</a></li><li><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a></li></ol><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>这两个插件安装起来非常简单。</p><p>创建一个目录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.zsh/plugins</span><br></pre></td></tr></table></figure><p>clone这两个项目到刚刚创建的目录下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/zsh-users/zsh-autosuggestions.git ~/.zsh/plugins/zsh-autosuggestions</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:zsh-users/zsh-syntax-highlighting.git ~/.zsh/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>设置<code>.zshrc</code>中的<code>$ZSH_CUTOM</code>变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Would you like to use another custom folder than $ZSH/custom?</span></span><br><span class="line"><span class="comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span><br><span class="line">ZSH_CUSTOM=~/.zsh</span><br></pre></td></tr></table></figure><p>添加插件配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(zsh-autosuggestions zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure><p>最终效果图如下：</p><p><img src="/images/blog/zsh-like-fish-shell/autosuggestions.png" alt="autosuggestions"></p><p>途中可以看到git是绿色的，代表存在这个命令，如果打错了，它就是红色的：</p><p><img src="/images/blog/zsh-like-fish-shell/color.png" alt="color"></p><p>一目了然，不用等出错了再去修正错误了。</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zsh </tag>
            
            <tag> autosuggestions </tag>
            
            <tag> color </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Tesseract图片文字识别初探</title>
      <link href="2016/07/28/on-the-use-of-tesseract-picture-text-recognition/"/>
      <url>2016/07/28/on-the-use-of-tesseract-picture-text-recognition/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/tesseract-to-pages.png" alt="tesseract-to-pages"></p><p>一直以来都想尝试一下图片的中文识别，直到最近才有点空闲时间，主要目的是证实一下到底可不可行，正确率能否达到 95% 以上。自己从头写起十分费时间，因为图片处理很麻烦，所以我选用了<code>Tesseract OCR</code>。</p><p>所谓 <code>OCR</code>(Optical Character Recognition)是指对文本资料进行扫描，然后对图像文件进行分析处理，获取文字和版面信息的过程。<code>OCR</code>是图像识别领域中的一个子领域，该领域专注于对图片中的文字信息进行识别并转换成能被常规文本编辑器编辑的文本。</p><a id="more"></a><h2 id="Tesseract介绍"><a href="#Tesseract介绍" class="headerlink" title="Tesseract介绍"></a>Tesseract介绍</h2><p><code>Tesseract</code>(/‘tesərækt/) 这个词的意思是”超立方体”，指的是几何学里的四维标准方体，又称”正八胞体”，是一款被广泛使用的开源 <code>OCR</code> 工具。</p><p><img src="http://linusp.github.io/assets/img/tesseract.gif" alt="tesseract"></p><p><code>Tesseract</code> 已经有 30 年历史，开始它是惠普实验室于1985年开始研发的一款专利软件，到1995年一件成为OCR业界内最准确的识别引擎之一。然而，HP不久便决定放弃OCR业务，<code>Tesseract</code>从此尘封。数年之后，HP意识到与其将Tesseract束之高阁，还不如贡献给开源，让其重焕新生。在 2005 年，<code>Tesseract</code>由美国内华达州信息技术研究所获得，并求助于<code>Google</code>对<code>Tesseract</code>进行改进、消除Bug、优化工作，并开源，其后一直由 <code>Google</code> 赞助进行后续的开发和维护。因为其免费与较好的效果，许多的个人开发者以及一些较小的团队在使用着 <code>Tesseract</code> ，诸如验证码识别、车牌号识别等应用中，不难见到 <code>Tesseract</code> 的身影。</p><p>现在<code>Tesseract</code>托管在<code>Github</code>上，大家有兴趣可以上<code>Github</code>上<code>Star</code>或<code>Frok</code><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">该项目</a>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Mac-OSX"><a href="#Mac-OSX" class="headerlink" title="Mac OSX"></a>Mac OSX</h3><p>在<code>Mac</code>上安装<code>Tesseract</code>是一件非常简单的事情，我们还是使用<code>brew</code>来进行安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install tesseract</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ tesseract --version</span><br><span class="line">tesseract 3.04.01</span><br><span class="line"> leptonica-1.73</span><br><span class="line">  libjpeg 8d : libpng 1.6.23 : libtiff 4.0.6 : zlib 1.2.5</span><br></pre></td></tr></table></figure><p>不过，如果你只是用上述命令来安装Tesseract的话，就会发现，只支持英文，因为它只默认安装了<code>eng</code>的语言包。如果我们需要识别其他的语言该如何来办呢？</p><p>安装指定的语言包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew intsall tesseract</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/Cellar/tesseract/&#123;version&#125;/share/tessdata</span><br><span class="line">wget https://github.com/tesseract-ocr/tessdata/raw/master/chi_sim.traineddata</span><br></pre></td></tr></table></figure><p>使用<code>brew</code>安装所有语言包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install tesseract --all-languages</span><br></pre></td></tr></table></figure><h3 id="其他平台安装"><a href="#其他平台安装" class="headerlink" title="其他平台安装"></a>其他平台安装</h3><p>更多Tesseract的安装可以查看这儿<a href="https://github.com/tesseract-ocr/tesseract/wiki" target="_blank" rel="noopener">Install Tesseract via pre-built binary package</a>或 <a href="https://github.com/tesseract-ocr/tesseract/wiki/Compiling" target="_blank" rel="noopener">build it from source</a></p><h2 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h2><p>这里只见到讲一下Tesseract识别图像的基本用法，关于训练和开发将来在另开新篇来专门讲述。</p><p>由于Tesseract只提供命令行工具，这里讲的用法对于Linux和Windows平台都适用。</p><p>首先可以通过<code>&quot;--list-langs&quot;</code>来查看哪些可用的“语言”，如果之前的<code>TESSDATA_PREFIX</code>环境变量没有设置错误，将看到这样的输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~tesseract --list-langs</span><br><span class="line">List of available languages (107):</span><br><span class="line">afr</span><br><span class="line">amh</span><br><span class="line">ara</span><br><span class="line">asm</span><br><span class="line">aze</span><br><span class="line">aze_cyrl</span><br><span class="line">bel</span><br><span class="line">ben</span><br><span class="line">bod</span><br><span class="line">bos</span><br><span class="line">bul</span><br><span class="line">cat</span><br><span class="line">ceb</span><br><span class="line">ces</span><br><span class="line">chi_sim</span><br><span class="line">chi_tra</span><br><span class="line">chr</span><br><span class="line">cym</span><br><span class="line">dan</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>大家可以看到，我安装了107个语言包，其中,<code>eng</code>和<code>chi_sim</code>是<code>Tesseract</code>提供的英文和简体中文的语言文件。</p><p>另外，要说明的是，这里的 “语言文件” 的本质是包含了某种 “自然语言” 的文字的特征等辅助识别的一些资源，但像 <code>chi_sim</code> 这个中文简体里也包含了英文字母与阿拉伯数字的资源。而我们也可以为了特定的用途而去训练产生对应的资源，并且可以给这个资源自定义一个名字。</p><p>如果发现以上命令的输出为空，那应该去检查一下 <code>TESSDATA_PREFIX</code> 这个环境变量。在这个环境变量无误且 “语言文件” 存在的情况下，假设我们有一张名为 <code>paper.png</code> 的图片，则通过以下命令对图片进行识别，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper -l chi_sim</span><br></pre></td></tr></table></figure><ol><li>第一个参数是待识别的图像的文件名</li><li>第二个参数用于指定输出，如果希望直接输出而不是保存到文件，那么就使用 <code>stdout</code>，否则这个参数将会作为保存结果的文件的前缀</li><li>-l <code>chi_sim</code> 这个应该很好理解，就是用来指定使用哪个 “语言文件”，如果是使用 英文(<code>eng</code>) ，这个参数可以不加，因为默认就是使用英文的 “语言文件” 来进行识别</li></ol><blockquote><p>以上命令如不出错，结果将会保存到 paper.txt 这个文本文件中。</p></blockquote><p>此外 <code>Tesseract</code> 还提供非常丰富的可选参数来对识别过程进行调整，可用的参数及其默认值可以通过以下命令进行查看:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract --<span class="built_in">print</span>-parameters</span><br></pre></td></tr></table></figure><p>参数的使用有两种:</p><ul><li>使用 -c 选项来设定单项参数的值，比如:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper -l chi_sim -c language_model_ngram_on=1</span><br></pre></td></tr></table></figure><p>允许使用多个 -c 选项来设置多个参数的值。</p><ul><li>将多项参数设置写入文件，然后在识别时使用该文件，比如:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper -l chi_sim tess.conf</span><br></pre></td></tr></table></figure><p>需要注意的是，如果使用配置文件，用作参数的配置文件名要放在最后面——这里也支持多个配置文件，但它们必须要在最后面。假如我有两个配置文件 tess_1.conf 和 tess_2.conf，那么这样是正确的:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper -l chi_sim tess_1.conf tess_2.conf</span><br></pre></td></tr></table></figure><p>而这样则是错误的:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper tess_1.conf -l chi_sim tess_2.conf</span><br></pre></td></tr></table></figure><p>至于 <code>Tesseract</code> 那些参数各有什么含义，官方没有提供任何文档来进行解释，这里有一个<a href="http://www.sk-spell.sk.cx/tesseract-ocr-parameters-in-302-version" target="_blank" rel="noopener">链接</a>提供了部分参数的用处说明，应该是阅读了 <code>Tesseract</code> 源代码后得到的结论。</p><h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>关于<code>Tesseract</code>的文档，可以查看<a href="http://tesseract-ocr.github.io/index.html" target="_blank" rel="noopener">Tetesseract官方Blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tesseact </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看看程序猿是如何来下载和处理视频</title>
      <link href="2016/07/19/how-the-program-ape-is-coming-to-download-and-process-video/"/>
      <url>2016/07/19/how-the-program-ape-is-coming-to-download-and-process-video/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/ffmpeg-youtube-dl.png" alt="FFMpeg and Youtube-dl"></p><p>我们经常在各大视频网站上看到一些很不错的视频，希望能够下载收藏起来，但是无法在网站上找到下载的按钮或者入口，很是郁闷。</p><p>那么来看看程序猿是如何来下载和处理视频的。</p><a id="more"></a><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>今天我看到了一个英国拍的工程师吐槽的视频，准备下载拿来做分享的素材。但是你如果在优酷上遍寻不到可以直接下载的链接，只有使用优酷的客户端才能给下载。</p><p>对于程序猿来说，这个事情实在是太让人不爽了，那我们该怎么办？</p><h3 id="YouTube-DL"><a href="#YouTube-DL" class="headerlink" title="YouTube-DL"></a>YouTube-DL</h3><p>那就该视频下载神器<code>youtube-dl</code>入场。别看名字和youtube相关，其实它支持大部分的视频网站。比如，我们现在要下载视频的优酷。</p><p>我们来试试<code>youtube-dl</code>的使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ youtube-dl http://v.youku.com/v_show/id_XNzE1NTk3Mzky.html</span><br><span class="line"></span><br><span class="line">[youku] XNzE1NTk3Mzky: Downloading JSON metadata</span><br><span class="line">[download] Downloading playlist: 工程师的痛只有工程师能懂_高清</span><br><span class="line">[youku] playlist 工程师的痛只有工程师能懂_高清: Collected 2 video ids (downloading 2 of them)</span><br><span class="line">[download] Downloading video 1 of 2</span><br><span class="line">[download] Destination: 工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part1.flv</span><br><span class="line">[download] 100% of 7.82MiB <span class="keyword">in</span> 00:07</span><br><span class="line">[download] Downloading video 2 of 2</span><br><span class="line">[download] Destination: 工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part2.flv</span><br><span class="line">[download] 100% of 7.73MiB <span class="keyword">in</span> 00:10</span><br><span class="line">[download] Finished downloading playlist: 工程师的痛只有工程师能懂_高清</span><br></pre></td></tr></table></figure><h3 id="FFMpeg"><a href="#FFMpeg" class="headerlink" title="FFMpeg"></a>FFMpeg</h3><p>很简单就下载了这个视频，不过新的问题就来了，我下载下来的视频有两个，怎么能合并成一个文件呢？</p><p>嗯，应该引入我们另外一个神器<code>FFMpeg</code>,这是一个在视频领域里面家喻户晓的类库+工具，我之前做的视频相关的应用就是利用了<code>FFMpeg</code>。有兴趣的同学可以去看看我开源的项目<a href="https://github.com/tonydeng/fmj" target="_blank" rel="noopener">FMJ</a>。</p><p>那继续看看，我们怎么利用<code>FFMpeg</code>合并视频的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i <span class="string">"工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part1.flv"</span> -c copy -bsf:v h264_mp4toannexb -f mpegts 1.ts</span><br><span class="line">ffmpeg -i <span class="string">"工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part2.flv"</span> -c copy -bsf:v h264_mp4toannexb -f mpegts 2.ts</span><br><span class="line">ffmpeg -i <span class="string">"concat:1.ts|2.ts"</span> -c copy -bsf:a aac_adtstoasc <span class="string">"工程师的痛只有工程师能懂.mp4"</span></span><br></pre></td></tr></table></figure><p>这样我们就解决了下载和视频处理的需求，看起来是不是和使用鼠标点点点来完成这些事情不一样呢？</p><p>其实，我这儿还只是粗浅的演示，更多的方式可以，去<a href="http://youtube-dl.org/" target="_blank" rel="noopener">Youtube-DL官网</a>、<a href="https://github.com/rg3/youtube-dl/" target="_blank" rel="noopener">youtube-dl的开源项目地址</a>,<a href="http://ffmpeg.org/" target="_blank" rel="noopener">FFMpeg官网</a>看看更详细的介绍和使用说明。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>另外，也可以看看其他人总结的一些更详细的经验和组合的自动化脚本工具。</p><p>比如：</p><ol><li><a href="http://www.5yun.org/7636.html" target="_blank" rel="noopener">youtube-dl高级使用方法，混合参数下载</a></li><li><a href="http://www.5yun.org/8224.html" target="_blank" rel="noopener">优酷付费vip视频下载方法</a></li><li><a href="https://github.com/kashu/ydl.sh" target="_blank" rel="noopener">使用youtube-dl下载视频的开源脚本</a></li><li><a href="https://github.com/kashu/merge.videos" target="_blank" rel="noopener">自动批量合并视频文件</a></li></ol><p>附上这个视频吧,有兴趣的人可以看看。</p><iframe height=498 width=510 src="http://player.youku.com/embed/XNzE1NTk3Mzky" frameborder=0 allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> video </tag>
            
            <tag> ffmpeg </tag>
            
            <tag> youtube-dl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leiningen + Clojure Hello World!</title>
      <link href="2016/07/19/leiningen-clojure-hello-world/"/>
      <url>2016/07/19/leiningen-clojure-hello-world/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/hello-world.jpg" alt="hello world"></p><p>我们之前已经写过<a href="/categories/Leiningen-Clojure%E4%B9%8B%E6%97%85/">Leiningen + Clojure之旅</a>一篇Blog<a href="/2015/11/19/install-leiningen/">安装Leiningen</a>。</p><p>今天我们在看看如何结合Leiningen写一个Clojure的Hello World，毕竟开始一门语言，都是从Hello World开始。</p><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>我们还是先用lein创建一个项目，使用标准项目模板。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein new app clojure-demo --force</span><br><span class="line">Generating a project called clojure-demo based on the <span class="string">'app'</span> template.</span><br></pre></td></tr></table></figure><p>这儿有关于new这个指令的详细使用介绍，包括项目模板的介绍。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein <span class="built_in">help</span> new</span><br><span class="line">Generate scaffolding <span class="keyword">for</span> a new project based on a template.</span><br><span class="line"></span><br><span class="line">If only one argument is passed to the <span class="string">"new"</span> task, the default template</span><br><span class="line">is used and the argument is used as the name of the project.</span><br><span class="line"></span><br><span class="line">If two arguments are passed, the first should be the name of a template,</span><br><span class="line">and the second is used as the name of the project, <span class="keyword">for</span> example:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span></span><br><span class="line"></span><br><span class="line">To generate to a directory different than your project<span class="string">'s name use --to-dir:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    lein new $TEMPLATE_NAME $PROJECT_NAME --to-dir $DIR</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">By default, the "new" task will not write to an existing directory.</span></span><br><span class="line"><span class="string">Supply the --force option to override this behavior:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    lein new $TEMPLATE_NAME $PROJECT_NAME --force</span></span><br><span class="line"><span class="string">    lein new $TEMPLATE_NAME $PROJECT_NAME --to-dir $DIR --force</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Arguments can be passed to templates by adding them after "new"'</span>s options. Use</span><br><span class="line">`--` to separate arguments to lein new and the actual template you are using:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span> --to-dir <span class="variable">$DIR</span> -- template-arg-1 template-arg-2</span><br><span class="line"></span><br><span class="line">If you<span class="string">'d like to use an unreleased (ie, SNAPSHOT) template, pass in --snapshot:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    lein new $TEMPLATE_NAME $PROJECT_NAME --snapshot</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If you'</span>d rather like to use a specific version of template, specify the version</span><br><span class="line">with --template-version option:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span> --template-version <span class="variable">$TEMPLATE_VERSION</span></span><br><span class="line"></span><br><span class="line">If you use the `--snapshot` or `--template-version` argument with template args</span><br><span class="line">you may need to use `--` to prevent template args from being interpreted as</span><br><span class="line">arguments to `lein new`:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span> --snapshot -- template-arg-1 template-arg-2</span><br><span class="line"></span><br><span class="line">Third-party templates can be found at https://clojars.org/search?q=lein-template.</span><br><span class="line">When creating a new project from a third-party template, use its group-id</span><br><span class="line">as the template name. Note that there<span class="string">'s no need to "install" a given third-</span></span><br><span class="line"><span class="string">party template --- lein will automatically fetch it for you.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Use `lein new :show $TEMPLATE` to see details about a given template.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To create a new template of your own, see the documentation for the</span></span><br><span class="line"><span class="string">lein-new Leiningen plug-in.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Subtasks available:</span></span><br><span class="line"><span class="string">default    A general project template for libraries.</span></span><br><span class="line"><span class="string">plugin     A leiningen plugin project template.</span></span><br><span class="line"><span class="string">app        An application project template.</span></span><br><span class="line"><span class="string">template   A meta-template for '</span>lein new<span class="string">' templates.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Run `lein help new $SUBTASK` for subtask details.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Arguments: ([project-name] [template project-name [-- &amp; args]])</span></span><br></pre></td></tr></table></figure><h2 id="project-clj说明"><a href="#project-clj说明" class="headerlink" title="project.clj说明"></a>project.clj说明</h2><p><code>project.clj</code>是<code>Leigingen</code>为项目添加的配置文件，类似于<code>Maven</code>的<code>pom.xml</code>。我们来先看看都有些什么内容。</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">defproject</span> clojure-demo <span class="string">"0.1.0-SNAPSHOT"</span></span><br><span class="line">  <span class="symbol">:description</span> <span class="string">"FIXME: write description"</span></span><br><span class="line">  <span class="symbol">:url</span> <span class="string">"http://example.com/FIXME"</span></span><br><span class="line">  <span class="symbol">:license</span> &#123;<span class="symbol">:name</span> <span class="string">"Eclipse Public License"</span></span><br><span class="line">            <span class="symbol">:url</span> <span class="string">"http://www.eclipse.org/legal/epl-v10.html"</span>&#125;</span><br><span class="line">  <span class="symbol">:dependencies</span> [[org.clojure/clojure <span class="string">"1.8.0"</span>]]</span><br><span class="line">  <span class="symbol">:main</span> ^<span class="symbol">:skip-aot</span> clojure-demo.core</span><br><span class="line">  <span class="symbol">:target-path</span> <span class="string">"target/%s"</span></span><br><span class="line">  <span class="symbol">:profiles</span> &#123;<span class="symbol">:uberjar</span> &#123;<span class="symbol">:aot</span> <span class="symbol">:all</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><ol><li>第一行，描述了项目名称以及版本，当前的项目名称就是 <code>clojure-demo</code>,版本是<code>0.1.0-SNAPSHOT</code>。如果一个项目版本以<code>SNAPSHOT</code>结尾，通常表明该项目还处于开发阶段，还没有正式的release。</li><li><code>description</code>是该项目的简要描述。</li><li><code>url</code>是可选的网址，可以是你项目将来上线后的实际地址。</li><li><code>license</code>是该项目使用License，默认给你设置为<code>Eclipse Public License</code>。</li><li><code>dependencies</code>是我们初期最需要关注的内容，也就是我们项目中需要依赖的其他项目及其版本的配置。比如<code>clojure-demo</code>这个项目就依赖了clojore-1.8.0的版本。</li><li><code>main</code>是配置了当前项目执行的文件，比如<code>clojure-demo.core</code>这个配置就表明了，执行文件就在<code>src/clojure-demo/core.clj</code>。</li><li><code>profiles</code>是我们自己个性化定制的不同profile的指令，比如，我们现在可以通过<code>lein uberjar</code>将项目生成一个jar供其他项目使用。</li></ol><h2 id="结合IntelliJ"><a href="#结合IntelliJ" class="headerlink" title="结合IntelliJ"></a>结合IntelliJ</h2><p>当你用IntelliJ打开<code>clojure-demo</code>，发现你根本看不到项目的结构，只能看到最外层的文件，比如<code>project.clj</code>等。src,test等目录和实际的代码你根本就看不到。那该怎么办？</p><p>可以先执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein pom</span><br></pre></td></tr></table></figure><p>这样lein帮你生成了一个<code>pom.xml</code>，你就可以按照Maven的方式import到IntelliJ中了。</p><h2 id="执行Hello-World"><a href="#执行Hello-World" class="headerlink" title="执行Hello World!"></a>执行Hello World!</h2><p>好，项目也生成了，IDE也可以使用了，我们就开始经典的<code>Hello World</code>吧。</p><p>我们在<code>project.clj</code>中配置了直接运行的方式，那我们现在开始编辑一下<code>core.clj</code>。</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> clojure-demo.core</span><br><span class="line">  (<span class="symbol">:gen-class</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> -main</span><br><span class="line">  <span class="string">"I don't do a whole lot ... yet."</span></span><br><span class="line">  [&amp; args]</span><br><span class="line">  (<span class="name">println</span> <span class="string">"Hello, Clojure World!"</span>))</span><br></pre></td></tr></table></figure><p>执行一下看看效果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein run</span><br><span class="line">Hello, Clojure World!</span><br></pre></td></tr></table></figure><h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><p>我们先添加一个简单的方法，然后测试一下。</p><p>在<code>core.clj</code>中添加<code>my-plus</code>方法，简单计算一下两个数的相加</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> my-plus</span><br><span class="line">  <span class="string">"I don't do a whole lot."</span></span><br><span class="line">  [a b]</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> a b))</span><br></pre></td></tr></table></figure><p>在<code>core_test.clj</code>中添加<code>my-plus-test</code>的测试方法，测试一下1+1是否等于2</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">deftest</span> my-plus-test</span><br><span class="line">  (<span class="name">testing</span> <span class="string">"Test my plus."</span></span><br><span class="line">    (<span class="name">is</span> (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">my-plus</span> <span class="number">1</span> <span class="number">1</span>) <span class="number">2</span>)))</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">lein <span class="built_in">test</span> clojure-demo.core-test</span><br><span class="line"></span><br><span class="line">Ran 1 tests containing 1 assertions.</span><br><span class="line">0 failures, 0 errors.</span><br></pre></td></tr></table></figure><p>如果，你做到这一步的话，欢迎你来到Leiningen + Clojure的世界，Java工程师也可以体验一把Clojure带给你的不同体验吧。</p>]]></content>
      
      
      <categories>
          
          <category> Leiningen + Clojure之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leiningen </tag>
            
            <tag> clojure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>靠谱的产品经理之七字真言</title>
      <link href="2016/07/14/product-seven-words/"/>
      <url>2016/07/14/product-seven-words/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/seven-words/kaopu.jpg" alt="怎样才算靠谱的产品经理"></p><p>工作那么多年，合作过的产品经理有很多，但是被我和工程师团队认为靠谱的产品经理却不多，工程师也经常吐槽产品经理不靠谱（貌似，我们之前合作过靠谱的产品经理女性居多，也不知道是什么原因……）。</p><a id="more"></a><h2 id="产品汪和程序猿之间的现状"><a href="#产品汪和程序猿之间的现状" class="headerlink" title="产品汪和程序猿之间的现状"></a>产品汪和程序猿之间的现状</h2><p>我们去通过Google或Baidu搜索关键词 “产品经理 程序员”，也经常出现如下的内容。</p><p>比如，想不通的……</p><p><img src="http://www.wanho.net/data/upload/ueditor/56d65d9d43914.jpg" alt="产品经理频繁改需求为什么会惹毛程序员？"></p><p>比如，比较暴力的……</p><p><img src="http://www.dongao.com/kjzx/UploadFiles_5705/201507/2015071016354845.png" alt="产品经理改需求惨遭囚禁凌虐"></p><p>或者，如此求解的……</p><p><img src="http://www.dongao.com/kjzx/UploadFiles_5705/201507/2015071016360147.png" alt="产品经理如何和程序员共处"></p><p>感觉整个互联网行业，甚至IT圈都在上演产品经理和程序员的“恩怨情仇”，堪比各大影院前段时间上映的迪斯尼大片《Zootopia》（疯狂动物城）。</p><p><img src="http://www.woshipm.com/wp-content/uploads/2015/07/QQ20150717145729.png" alt="产品经理和程序员的恩怨情仇"></p><h2 id="矛盾如何产生？"><a href="#矛盾如何产生？" class="headerlink" title="矛盾如何产生？"></a>矛盾如何产生？</h2><p>很多产品汪都经常会碰到这样的场景：</p><p>一个非常复杂的产品设计终于加班加点的完成了，你满心欢喜的召集程序猿们开产品讨论会，但是过程中却备受打击，经常会碰到如下问题，而你还回答不出来：</p><ul><li>是否要搜索？模糊搜索还是精确搜索？</li><li>是否有翻页，每页显示多少条数据？</li><li>能不能输入小数点、负数、字母？</li><li>公式怎么算的？</li><li>各种状态如何定义？如何转换状态？</li><li>……</li></ul><p>很郁闷的是上述问题，你在产品设计过程中，你根本没有考虑过这些问题，你一直在考虑如何来创建订单，应该让用户更简单的使用。而这些问题，你认为都是小问题，还需要我来考虑吗？</p><p>这个会议的效果可想而知。</p><p>程序猿们会认为这么长的时间了，你产品经理在想什么，这些都没有想明白，没干活啊！</p><p>产品汪们会非常委屈，觉得程序猿是有意刁难自己。要么觉得这些问题难道不是应该程序猿考虑的吗？要么觉得，这些问题复杂想不清楚。</p><p>最后会议草草收场，团队之间出现嫌隙。</p><p>当产品汪把上述问题的答案整理完之后，再次召集程序猿们开产品讨论会，发现貌似还是会有类似的问题。</p><p>哲人发出如此的感叹:</p><blockquote><p><img src="/images/blog/seven-words/product-workshop.png" alt="吐槽产品讨论会"></p></blockquote><p>慢慢的，产品汪和程序猿之间的情绪就越来越对立，对这个产品的热情也慢慢下降，更多的精力和时间都放在两边对耗上了，产品推行的非常之慢。</p><p>直到Boos来过问产品的状况，只有互相推诿和指责。</p><h2 id="回顾矛盾的产生"><a href="#回顾矛盾的产生" class="headerlink" title="回顾矛盾的产生"></a>回顾矛盾的产生</h2><p>其实矛盾产生的根源在于我们在产品讨论会上碰到哪些可能答不出来的问题。</p><p>那么，这些问题需要产品经理考虑吗？答案是显而易见的，产品经理必须要考虑这些问题、</p><p>因为这些最基本的问题会影响到系统的设计，没有考虑到，意味着产品经理对于规划的产品可以做什么？如何做？能做到什么程度？没有概念，规划产品的可行性就会大打折扣。</p><p><img src="/images/blog/seven-words/upstream-and-downstream.png" alt="产品流程的上下游"></p><p>一般产品研发的上下游基本上下图，程序猿处于产品汪的下游。</p><p>一个没有概念，规划的产品设计，你让一个思维严谨的程序猿如何能接受？他们只会认为，产品经理不靠谱，这种不靠谱的需求只会导致如下情况：</p><blockquote><p>如果让这个产品通过了产品讨论阶段，那么他们只能为这个不靠谱的产品设计和产品经理买单，程序猿们会产生这样的想法： 我TMD就是那个“接盘侠”。<br><img src="http://www.cyxqd.com/wp-content/uploads/2014/01/jiepanxia.jpg" alt="接盘侠"></p></blockquote><p>** 产品汪们，你们也想想，你们愿意当这个接盘侠吗？ **</p><h2 id="解决矛盾的办法"><a href="#解决矛盾的办法" class="headerlink" title="解决矛盾的办法"></a>解决矛盾的办法</h2><p>那么我们怎么来解决这些矛盾呢？</p><p>产品如同人一样，有样貌、皮肤等外在结构，也有筋骨、神经网络等内在体系。在产品设计及规划中，产品汪除了要对UI、UE等外在负责以外，还需要对产品的筋骨、神经网络负责。</p><p>产品的筋骨、神经网络就是产品隐含的逻辑规则，才是产品运转正常的保证。</p><p>我们推出一个产品，一般要解决两类问题：</p><ol><li>人的问题，业务的问题</li><li>计算机的问题，也就是技术的问题</li></ol><p>那我们设计一个产品，不管我们想的如何天马行空，如何炫酷，也一定要通过一整套的IT系统来支撑。而IT系统本质上就是对数据的各种处理，各种状态流转，使用了各种形态来展示这些数据和状态流转。</p><p>而产品汪一般的产品设计思路都是按照人的思维模式来进行设计的，但是人本身就是一种适配功能很强的“适配器”，人可以对模糊的信息做出自己的补充，完善自己对这个模糊的信息补充，并作出自己的反应。</p><p>但是计算机并非如此，比如，我们进出地铁，站在扶梯上，会有语音提示“上下楼梯，请握紧扶手”。我们很容易理解这个句话，并作出自己适当的反应，来握紧扶手。</p><p>但是计算机如何来理解？用手施加10牛顿的力吗？</p><p>那产品汪在做产品设计时，<strong>是否要考虑到如何来定义这个“紧”？！</strong></p><p>那很多产品汪就非常郁闷的说，这么多的问题，怎么样才能够都考虑到呢？</p><p><img src="http://images.rednet.cn/articleimage/2006/07/29/104016572.jpg" alt="我们不专业"></p><p>那怎么办呢？我们是不是需要进修一下呢？比如学星爷研读的秘籍《产品狗的自我修养》。</p><p><img src="http://image.woshipm.com/wp-files/2015/07/chanpingou.jpg" alt="产品狗的自我修养"></p><p>其实，我们并不需要研读那么深刻的著作，其实我们只要掌握了产品设计的<strong>七字真言</strong>，基本上也程序猿的在产品讨论会上碰到的问题就能解决的差不多了。</p><h2 id="七字真言"><a href="#七字真言" class="headerlink" title="七字真言"></a>七字真言</h2><p>很多人看到“七字真言”的第一反应可能是这样的。</p><p><img src="/images/blog/seven-words/seven.png" alt="七字真言"></p><p>其实产品设计的七字真言就是增 、删、改、查、显、算、 传</p><p>所有的产品设计，本质上都是对于一些数据、内容、结构层、信息做一些交互，这是产品的本质。</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ol><li>增加按钮的样式、位置</li><li>增加按钮的文案：添加、创建、新建？</li><li>增加内容的字段</li><li>字段的必填非必填说明</li><li>字段的验证、提示说明</li><li>界面排列的说明</li><li>弹窗还是当前页跳转？</li><li>……</li></ol><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ol><li>删除按钮的样式、位置</li><li>删除案例的文案： 删除</li><li>删除时是否要确认？确认窗口的样式</li><li>删除完以后界面布局的变化</li><li>逻辑删除</li><li>物理删除</li><li>删除之后是否会影响到其他的功能模块？</li><li>…….</li></ol><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ol><li>编辑按钮的样式、位置</li><li>编辑按钮的文案： 修改、编辑？</li><li>弹窗还是当前页面跳转？</li><li>可以修改与不可修改的说明</li><li>更改数据之后，对其他功能模块的影响</li><li>……</li></ol><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ol><li>按照哪些字段进行排序？</li><li>搜索框：需要对哪些进行搜索？是否可以组合搜索？搜索后的界面如何程序？模糊搜索还是精确搜索？</li><li>搜索结果的展示如何？是否和搜索条件有关系？</li><li>搜索条件之间是否有冲突？</li><li>查不到数据该如何？</li><li>需要查看哪些数据？</li><li>……</li></ol><blockquote><p>一般来说，产品经理做到以上四点就能把原型做的非常完善，例如数据做成了列表样式，是否考虑了分页？是否需要排序？排序的话按什么条件进行？排序满足不了需求的话是否需要搜索框？查询框？查看详细列表的打开方式是怎么样的？本页操作还是新窗口操作？跳转之后需不需要跳回来？选择数据支持单选还是多选？单选的话是用下拉还是radio？如此等等</p><p>细节交代的越清楚，和程序猿的沟通成本就越小</p></blockquote><h3 id="显"><a href="#显" class="headerlink" title="显"></a>显</h3><ol><li>页面内容的布局</li><li>每页多少条数据、数据的排序？</li><li>是否有翻页、翻页样式如何？</li><li>是否提供查看详情，如何查看？</li><li>查看是弹窗还是当前页打开，还是新页面？</li><li>如何从各个操作页面跳转回原页面的方法？</li><li>跳转回来的页面如何显示？</li><li>不同权限用户的数据展示是否有不同？展现规则是怎么样的？</li><li>……</li></ol><h3 id="算"><a href="#算" class="headerlink" title="算"></a>算</h3><ol><li>计算规则</li><li>页面公式、特定指标的计算规则</li><li>数据背后的逻辑</li><li>……</li></ol><h3 id="传"><a href="#传" class="headerlink" title="传"></a>传</h3><ol><li>不同用户之间、不同操作之间传递哪些数据？哪些字段？</li><li>需要提供哪些API的接口？整合其他第三方系统时，他们提供的API是否能够满足我们现有需求？</li><li>数据的流向规则</li><li>……</li></ol><p>每当我们在做产品设计的时候，都在心里默念着七个字，基本上设计出来的产品功能点就都覆盖到了，省去了产品讨论和产品研发过程中很多不必要的沟通、交流和冲突。</p><p>有一个比喻非常好，“产品是孩子，开发是妈妈，产品经理是爸爸，测试时医生”，<strong>We are 伐木累！</strong>，产品汪，你们觉得呢？</p><p><img src="http://www.android100.org/uploadfile/2015/0829/20150829004427_0.gif" alt="we are 伐木累"></p><p>最后说一句，不管怎么样，各位产品汪们，需要对产品经理本身的职责要搞清楚，如果你短时间内不能达到产品经理本身应该具备的素质，那你就应该努力提高自己对产品设计和产品经理职责的理解，good good study,day day up！并且，要发挥自己的亲和力将整个团队的各个成员的长处组合起来，一起完成一个满意的产品。</p><p><img src="http://image.woshipm.com/wp-files/2015/07/QQ20150727200359.png" alt="任何不能杀了我的只会让我更强"></p><p>另外，程序猿们也不要太过难为产品汪，大家都是在一个团队工作，为了同一个目标而努力，能够互相支持，互相补位的就多多支持和补位。毕竟大家也都是在<strong>同一个马勺里喝水</strong>。</p><p><img src="http://www.yixieshi.com/uploads/allimg/140525/1-14052520102TZ.jpg" alt="同一个马勺里喝水"></p>]]></content>
      
      
      <categories>
          
          <category> 产品设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> product </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑客的统计学</title>
      <link href="2016/07/12/statistics-for-hackers/"/>
      <url>2016/07/12/statistics-for-hackers/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/sfh/statistics-for-hackers.png" alt="statistics for hackers"></p><p>最近看到一个题为<a href="https://speakerdeck.com/jakevdp/statistics-for-hackers" target="_blank" rel="noopener">《Statistics for Hackers》</a>(黑客的统计学)的PPT，非常有意思，和大家分享一下。</p><a id="more"></a><p><img src="/images/blog/sfh/hackers.png" alt="黑客不是窃贼"></p><blockquote><p>这儿的Hacker（黑客）并不是是指那些尝试窃取你银行密码的人，而是那些善用编程来解决问题的人。</p></blockquote><p>作者<a href="https://twitter.com/jakevdp" target="_blank" rel="noopener">Jake VanderPlas</a>是华盛顿大学的资深数学科学研究员，他在PPT中表示统计学很难，但是使用编程技能后，它也可以很简单，他深圳宣称： 只要你会写 <code>for</code> 循环，你就能做统计。</p><p>最重要的是： <strong>问正确的问题</strong></p><h2 id="1-热身：-抛硬币问题（直接模拟）"><a href="#1-热身：-抛硬币问题（直接模拟）" class="headerlink" title="1. 热身： 抛硬币问题（直接模拟）"></a>1. 热身： 抛硬币问题（直接模拟）</h2><p><img src="/images/blog/sfh/coin-problem.png" alt="硬币问题"></p><blockquote><p>问题： 你抛一个硬币30次，其中22次正面朝上。问这个硬币是均匀的吗？</p></blockquote><p><img src="/images/blog/sfh/coin-dispute.png" alt="硬币问题争执"></p><p>这是一个经典的问题。有人认为均匀的硬币抛 30 次应该有 15 次朝上，所以这个硬币不均匀，也有人认为即使是均匀的硬币也有可能因为偶然而抛出 22 次朝上。</p><p><img src="/images/blog/sfh/coin-solution.png" alt="硬币问题解法"></p><p>经典的解法如下：</p><blockquote><p>假设硬币是均匀的，然后验证这个原假设，计算一个均匀的硬币抛出 22 次正面的概率是多少?</p></blockquote><p>开始计算，如下图所示：</p><p><img src="/images/blog/sfh/coin-expressions.png" alt="硬币问题解法公式"></p><p>列出公式后，计算得知如果硬币是均匀的，那么抛 30 次并且有 22 次正面朝上的概率是 0.008，或者说如果抛 30 次并且观察到 22 次正面朝上，则这枚硬币是均匀的概率为 0.008。这个 0.008 一般称为 p 值，习惯上，当 p 值小于 0.05（有些时候取 0.01）时，我们认为这件事是不太可能发生的，因此拒绝原假设，即得到结论：硬币不是均匀的。</p><p>那么，是否有什么简单的方法呢？</p><p>这时，编程方法就可以派上用场了，我们只需要模拟一下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">N = <span class="number">1000000</span>;</span><br><span class="line">M = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">trials = (randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>)) </span><br><span class="line"><span class="keyword">if</span> sum(trials) &gt;= <span class="number">22</span>:</span><br><span class="line">M += <span class="number">1</span></span><br><span class="line">p = M / N <span class="comment">#0.00819</span></span><br></pre></td></tr></table></figure><p>结论： 由于 p = 0.008，拒绝原假设，硬币不是均匀的。</p><p>简单来说，计算样板分别比较困难，但模拟样本分布很简单。</p><p><img src="/images/blog/sfh/coin-ultimateness.png" alt="硬币问题解法公式"></p><h2 id="2-随机打乱"><a href="#2-随机打乱" class="headerlink" title="2. 随机打乱"></a>2. 随机打乱</h2><p>观察两组数据：</p><table border="1"><thead><tr><th colspan="2">★</th><th colspan="2">✖︎</th></tr></thead><tbody><tr><td>84</td><td>72</td><td>81</td><td>69</td></tr><tr><td>57</td><td>46</td><td>74</td><td>61</td></tr><tr><td>63</td><td>76</td><td>56</td><td>87</td></tr><tr><td>99</td><td>91</td><td>69</td><td>65</td></tr><tr><td>  </td><td>  </td><td>66</td><td>44</td></tr><tr><td>  </td><td>  </td><td>62</td><td>69</td></tr></tbody></table><p>★ 均值：73.5<br>✖︎ 均值：66.9<br>差异：6.6</p><p>问题来了：两组数据的差异 6.6 是统计显著的吗？</p><p>经典解法如下：</p><p><img src="/images/blog/sfh/welch-ultimateness-1.png" alt="welch-ultimateness-1"></p><p><img src="/images/blog/sfh/welch-ultimateness-2.png" alt="welch-ultimateness-2"></p><p><img src="/images/blog/sfh/welch-ultimateness-3.png" alt="welch-ultimateness-3"></p><p><img src="/images/blog/sfh/welch-ultimateness-4.png" alt="welch-ultimateness-4"></p><p><img src="/images/blog/sfh/welch-ultimateness-5.png" alt="welch-ultimateness-5"></p><p>然后查表，可得：</p><p><img src="/images/blog/sfh/welch-ultimateness-result.png" alt="welch-ultimateness-result"></p><p>由于 t = 0.932 &gt; tcrit = 1.796，所以我们得到结论：在 p = 0.05 的水平上差异 6.6 不是显著的。</p><p>所以……，我们刚刚究竟都做了些什么？最大的问题，是我们在解题过程中已经忘了我们最初要回答的问题。</p><p>为什么不直接使用流行的编程方法来处理呢？比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.stats.weightstats <span class="keyword">import</span> ttest_indt, p, dof = ttest_ind(group1, group2,</span><br><span class="line">alternative=<span class="string">'larger'</span>,</span><br><span class="line">usevar=<span class="string">'unequal'</span>)</span><br><span class="line">print(p)  <span class="comment"># 0.186</span></span><br></pre></td></tr></table></figure><p>这当然可以，但是……，我们正尝试回答的是什么问题呢？</p><p>让我们回到问题本身，上面的样本分布和抛硬币的原理其实是一样的，让我们用一个抽样方法来处理。和抛硬币不同，这儿我们没有生成器（模拟抛硬币的结果），但这不是问题，我们可以引入一个新的解决方案：随机打乱（Shuffling）。</p><p>过程如下图所示：</p><p><img src="/images/blog/sfh/welch-ultimateness-result.gif" alt="welch-ultimateness-result"></p><p>执行数千次，最后得到结论：</p><p><img src="/images/blog/sfh/welch-ultimateness.png" alt="welch-ultimateness"></p><p>在 p = 0.05 的水平上，差异 6.6 不是显著的。</p><h3 id="关于随机打乱需要注意的事："><a href="#关于随机打乱需要注意的事：" class="headerlink" title="关于随机打乱需要注意的事："></a>关于随机打乱需要注意的事：</h3><p>– 只能在原假设认为两组相同时使用<br>– 和所有其他方法一样，只能在样本有代表性时使用，千万要注意选择偏差<br>– 要注意相关实验。这点在《Simon’s Resampling: The New Statistics》一书中有很好的讨论 </p><h2 id="3-亚特尔的乌龟塔"><a href="#3-亚特尔的乌龟塔" class="headerlink" title="3. 亚特尔的乌龟塔"></a>3. 亚特尔的乌龟塔</h2><p>亚特尔的乌龟塔是一则童话寓言，讲述的是一只叫亚特尔的乌龟命令其他乌龟叠在一起成为高塔的故事，知名中文博主<a href="http://www.ruanyifeng.com/blog/2005/08/post_142.html" target="_blank" rel="noopener">阮一峰曾经翻译过一个版本</a>。</p><p><img src="/images/blog/sfh/the-tortoise-tower-of-atlantis.jpg" alt="The tortoise tower of Atlantis"></p><p>假设我们观察到了 20 个亚特尔乌龟塔，高度分别为：</p><table><thead><tr><th>48</th><th>24</th><th>32</th><th>61</th><th>51</th><th>12</th><th>32</th><th>18</th><th>19</th><th>24</th></tr></thead><tbody><tr><td>21</td><td>41</td><td>29</td><td>21</td><td>25</td><td>23</td><td>42</td><td>18</td><td>23</td><td>13</td></tr></tbody></table><p>问题是：<br>– 亚特尔乌龟塔的平均高度是多少？<br>– 这个估值有多少偏差？</p><p>需要注意的是，这儿问的是全体亚特尔乌龟塔的平均高度，即可能存在成千上万个乌龟塔，我们只观察了其中 20 个样本，并对整体均值进行估计，而不是简单地问这 20 个样本的均值，所以才有第二个问题：这个估值有多少偏差。</p><p>经典解法如下：</p><p><img src="/images/blog/sfh/tortoise-tower-ultimateness.jpg" alt="tortoise-tower-ultimateness"></p><p>那么，我们是否可以使用抽样方法来处理这个问题呢？和之前一样，我们的问题是没有生成器，这次的解决方案是自助重抽样法（Bootstrap Resampling）。如下图所示：</p><p><img src="/images/blog/sfh/bootstrap-resampling.gif" alt="Bootstrap Resampling"></p><p>简单来说，就是从现有的 20 个样本中，随机抽取 20 个值（抽完后放回去，因此可能会抽到重复的值），然后计算新样本的均值。</p><p>重复这个步骤成千上万次，最后，我们得到下面的结果：</p><p><img src="/images/blog/sfh/tortoise-tower-result.jpg" alt="tortoise-tower-result"></p><p>可以看到，与上面使用公式计算出的结果几乎一样。</p><p>** 自助重抽样法（Bootstrap Sampling）** 甚至还可以用在更复杂的统计上，同样的，也有一些注意点：</p><p>– 自助重抽样法（Bootstrap Sampling）被认真地研究过，有坚实的理论基础<br>– 自助重抽样法通常不太适用于基于排序的统计（如求最大值）<br>– 如果样本太小，效果会比较差（N &gt; 20 比较好）<br>– 注意选择偏差以及非独立数据 </p><h2 id="4-交叉验证"><a href="#4-交叉验证" class="headerlink" title="4. 交叉验证"></a>4. 交叉验证</h2><p>最后，PPT 中还举了一个交叉验证的例子。大致思想是将样本随机分为两部分，各自算出需要的值，然后用另一份样本来校验当前样本的值。重复成千上万次，最后得到可信的结果。限于篇幅，这儿就不详细介绍了，有兴趣的同学可以直接看原 <a href="https://speakerdeck.com/jakevdp/statistics-for-hackers" target="_blank" rel="noopener">PPT</a>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>相对抽象的统计学公式而言，抽样方法是一种更符合直觉的计算近似法。只要会写 <code>for</code> 循环，就可以做统计分析。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://speakerdeck.com/jakevdp/statistics-for-hackers" target="_blank" rel="noopener">《Statistics for Hackers》</a></p>]]></content>
      
      
      <categories>
          
          <category> 工程师文化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> statistics </tag>
            
            <tag> hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 lsof 代替 Mac OS X 中的 netstat 查看占用端口的程序</title>
      <link href="2016/07/07/use-lsof-to-replace-netstat/"/>
      <url>2016/07/07/use-lsof-to-replace-netstat/</url>
      
        <content type="html"><![CDATA[<p>众所周知水果系统内核是有 BSD 血统的 <code>Darwin</code>，OS X 自带的很多 CLI 工具也是 BSD style 的，有一部分使用起来和 Linux 无异，有一部分可以通过 <code>brew</code> 安装 GNU 版本（如 <code>tar</code>），但是 OS X 的 <code>netstat</code> 不能查看使用端口的程序名让我一直很不爽，而且也没找到 GNU 版本，于是去搜了一下解决办法，stackoverflow 上的结论基本都是建议使用 <code>lsof</code> 代替 <code>netstat</code> 进行查看：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">sudo lsof -nP -<span class="string">iTCP:</span>端口号 -<span class="string">sTCP:</span>LISTEN</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>-n 表示不显示主机名</li><li>-P 表示不显示端口俗称</li><li>不加 sudo 只能查看以当前用户运行的程序</li></ul><p>另外，还可以通过管道来过滤想要的信息</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo lsof -nP -iTCP -sTCP:LISTEN | <span class="keyword">grep</span> <span class="keyword">python</span></span><br></pre></td></tr></table></figure><p>基本效果如下：</p><p>查看当前所有监听的端口以及对应的<code>Command</code>和<code>PID</code></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">➜  ~ lsof -nP -iTCP -sTCP:LISTEN</span><br><span class="line">COMMAND    PID    <span class="built_in"> USER </span>  FD  <span class="built_in"> TYPE </span>            DEVICE SIZE/OFF NODE NAME</span><br><span class="line">SSH\x20Pr 1553 tonydeng    8u  IPv4 0xee7327e39355d175      0t0  TCP 127.0.0.1:8087 (LISTEN)</span><br><span class="line">SSH\x20Pr 1553 tonydeng    9u <span class="built_in"> IPv6 </span>0xee7327e38aad6e15      0t0  TCP [::1]:8087 (LISTEN)</span><br><span class="line">java      2978 tonydeng  166u <span class="built_in"> IPv6 </span>0xee7327e38aad7e35      0t0  TCP *:62622 (LISTEN)</span><br><span class="line">node      3319 tonydeng   31u  IPv4 0xee7327e39f0f8745      0t0  TCP *:4000 (LISTEN)</span><br></pre></td></tr></table></figure><p>查看指定端口对应的<code>Command</code>和<code>PID</code></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">➜  ~ lsof -nP -iTCP:4000 -sTCP:LISTEN</span><br><span class="line">COMMAND  PID    <span class="built_in"> USER </span>  FD  <span class="built_in"> TYPE </span>            DEVICE SIZE/OFF NODE NAME</span><br><span class="line">node    3319 tonydeng   31u  IPv4 0xee7327e39f0f8745      0t0  TCP *:4000 (LISTEN)</span><br></pre></td></tr></table></figure><p>PS ： 输出占用该端口的 PID</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -nP -iTCP:<span class="number">4000</span> |grep LISTEN|awk <span class="string">'&#123;print <span class="variable">$2</span>;&#125;'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mac OSX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> lsof </tag>
            
            <tag> netstat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任意文件下载漏洞的简单防护措施</title>
      <link href="2016/06/13/simple-protection-measures-to-download-any-file/"/>
      <url>2016/06/13/simple-protection-measures-to-download-any-file/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/download-vulnerability/security.jpg" alt="security"></p><p>我们在开发Web应用时，经常会提供文件下载的功能。工程师们一般会考虑遵循“单一原则”，会开发一个将请求中的<code>file</code>或<code>filePath</code>作为参数，来下载指定的文件。这样开发一个下载的功能，就能支持所有的下载需求了。</p><p>比如，输入这样的URL</p><blockquote><p><a href="http://tonydeng.github.io/download?file=123.txt">http://tonydeng.github.io/download?file=123.txt</a></p></blockquote><p>就能够下载<code>123.txt</code>这个文件了。</p><p>这样的确很方便，但是，大家有没有想过，这样的功能可能会出现什么样的安全隐患或者漏洞呢？</p><a id="more"></a><p>来，我们先看看例子：</p><p>下面是一段提供文件下载的<code>spring mvc</code>的java代码，使用<code>filePath</code>来指定要下载的文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/file/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDownloadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(FileDownloadController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"download.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileDownload</span><span class="params">(HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                             HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                             @RequestParam(<span class="string">"filePath"</span>)</span> String filePath) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(Constants.TMP_PATH + filePath);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == file || !file.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OutputStream toClient = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 清空response</span></span><br><span class="line">            response.reset();</span><br><span class="line">            <span class="comment">// 设置response的Header</span></span><br><span class="line">            response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span> + <span class="keyword">new</span> String(filePath.getBytes(<span class="string">"utf-8"</span>)));</span><br><span class="line">            response.addHeader(<span class="string">"Content-Length"</span>, <span class="string">""</span> + file.length());</span><br><span class="line">            response.setContentType(<span class="string">"application/octet-stream; charset=utf-8"</span>);</span><br><span class="line">            toClient = <span class="keyword">new</span> BufferedOutputStream(response.getOutputStream());</span><br><span class="line">            toClient.write(FileUtil.getByteForFile(file));</span><br><span class="line">            toClient.flush();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            log.error(<span class="string">"file download error"</span>, ex);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != toClient) &#123;</span><br><span class="line">                toClient.close();</span><br><span class="line">            &#125;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们做个测试，在下载的目录下添加一个<code>123.txt</code>的文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"123abc一二三"</span> &gt; 123.txt</span><br></pre></td></tr></table></figure><p>测试<code>123.txt</code>是否可以下载。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">http http:<span class="comment">//localhost:8080/file/download.do\?filePath\=123.txt</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Disposition: attachment;filename=<span class="number">123.</span>txt</span><br><span class="line">Content-Length: <span class="number">16</span></span><br><span class="line">Content-Type: application/octet-stream; charset=utf<span class="number">-8</span></span><br><span class="line">Server: Jetty(<span class="number">9.3</span><span class="number">.8</span>.v20160314)</span><br><span class="line"></span><br><span class="line"><span class="number">123</span>abc一二三</span><br></pre></td></tr></table></figure><p>看起来上面的代码和测试结果，貌似没有什么问题，也能够方便的提供文件下载服务（只需要将要下载的文件保存在<code>Constants.TMP_PATH</code>这个常量中指定的目录下就可以了）。</p><p>好，貌似下载的工作就完成了，我们可以考虑做别的功能了。</p><p>稍等，既然我们这边blog要聊<em>任意文件下载漏洞</em>，那这个漏洞到底是什么呢？我们不是已经指定了文件下载的目录了吗？</p><p>那我们在继续做做做测试，在指定的下载目录的上一级来创建一个<code>456.txt</code>文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"456def四五六"</span> &gt; ../456.txt</span><br></pre></td></tr></table></figure><p>测试<code>456.txt</code>是否可以下载。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/file/download.do\?filePath\=../456.txt</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Disposition: attachment;filename=../<span class="number">456.</span>txt</span><br><span class="line">Content-Length: <span class="number">16</span></span><br><span class="line">Content-Type: application/octet-stream; charset=utf<span class="number">-8</span></span><br><span class="line">Server: Jetty(<span class="number">9.3</span><span class="number">.8</span>.v20160314)</span><br><span class="line"></span><br><span class="line"><span class="number">456</span>def四五六</span><br></pre></td></tr></table></figure><p>啊！！！居然能够下载！！！</p><p>其实，还有更恐怖的事情。</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取系统用户信息</span></span><br><span class="line">http:<span class="regexp">//localhost:8080/file/download.do\?filePath\=../</span>..<span class="regexp">/../</span>..<span class="regexp">/../</span>..<span class="regexp">/../</span>../etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 脱裤</span></span><br><span class="line">http:<span class="regexp">//localhost:8080/file/download.do\?filePath\=../</span>..<span class="regexp">/../</span>..<span class="regexp">/../</span>..<span class="regexp">/../</span>../data/mysql/data/mysql.dat</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>情绪稳定之后，我们肯定要问一问，这个漏洞出现在哪儿呢？</p><p>我们来看看这两行代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过输入的filePath参数+加上预设的下载目录，获取最终下载地址</span></span><br><span class="line">File file = <span class="keyword">new</span> File(Constants.TMP_PATH + filePath);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//读取文件并写入到Response</span></span><br><span class="line">toClient.write(FileUtil.getByteForFile(file));</span><br></pre></td></tr></table></figure><p>专门把这两行提出来，大家应该能够理解这个漏洞出现在哪儿了吧。</p><p>那我们可以通过什么样的方式来解决这个漏洞呢？</p><ol><li>是否可以通过<code>HTTP Request</code>中的<code>Referrer</code>来做判断？ <strong>貌似会误杀。</strong></li><li>是否可以指定的文件名来做判断？ <strong>这样太麻烦了，就不灵活了。</strong></li><li>是否可以通过操作系统和Web容器的文件读写权限来限制？ <strong>研究文件权限，发现根本不可行。</strong></li><li>……</li></ol><p>其实，我们可以通过一个简单粗暴的方式就能解决这个安全漏洞。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == file || !file.exists() </span><br><span class="line">                || !file.getCanonicalFile().getParent().equals(<span class="keyword">new</span> File(Constants.TMP_PATH).getCanonicalPath())) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理就不解释了，看看<a href="http://docs.oracle.com/javase/8/docs/api/java/io/File.html#getCanonicalPath--" target="_blank" rel="noopener">Java的File API文档</a>吧。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> security </tag>
            
            <tag> download </tag>
            
            <tag> vulnerability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Junit的一些的高级用法</title>
      <link href="2016/05/11/junit-more-feature/"/>
      <url>2016/05/11/junit-more-feature/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/junit.png" alt="Junit"></p><p><code>Junit</code> 是Java开发领域中非常普遍的单元测试框架，不过，大部分的使用者仅仅只是使用它一部分的功能。</p><p>先整理一部分相对不常用，但是个人觉得非常有用的功能（其他的慢慢补充），希望对大家有所帮助。</p><a id="more"></a><h2 id="Rule注解"><a href="#Rule注解" class="headerlink" title="Rule注解"></a>Rule注解</h2><p>比如，我们可以使用 @Role 注解来提高我们写单元测试的效率。</p><p><code>@Rule</code> 这个注解是 <code>Junit4</code> 的新特性，我们可以去看看Junit的关于<a href="https://github.com/junit-team/junit4/wiki/Rules" target="_blank" rel="noopener">Rule的使用例子</a>。</p><p>利用 <code>@Rule</code> 我们可以扩展 <code>Junit</code> 的功能，在执行case的时候加入测试者特有的操作，而不影响原有case的代码，减少了特有操作和test case原逻辑的耦合。</p><p><code>@Rule</code> 只能注解在字段中，该字段必须是 <code>public</code> 的并且类型必须实现了 <code>TestRule</code> 接口或者 <code>MethodRule</code> 接口。</p><p>Junit 4.9之后还加入了一个 <code>@ClassRule</code> 注解。相对 <code>@Rule</code> 来说， <code>@ClassRule</code> 是一个类级别的注解。就像 <code>@Before</code> 与 <code>@BeforeClass</code> 的区别。</p><h3 id="通过-Rule注解生成临时文件或临时文件夹"><a href="#通过-Rule注解生成临时文件或临时文件夹" class="headerlink" title="通过@Rule注解生成临时文件或临时文件夹"></a>通过@Rule注解生成临时文件或临时文件夹</h3><p>有时候程序运行时必须生成文件或文件夹，往往需要写不少代码来实现这个功能。我们可以使用 TemporaryFolder 来在测试的时候创建文件和目录，最爽的是它在测试运行结束之后会将测试时创建的文件和目录的自动删除。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.rules.TemporaryFolder;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tonydeng on 16/5/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitRuleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(JunitRuleTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> TemporaryFolder tempFolder = <span class="keyword">new</span> TemporaryFolder();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileCreateAndWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = tempFolder.newFile(<span class="string">"simple.txt"</span>);</span><br><span class="line">        log.info(<span class="string">"temp file:'&#123;&#125;'"</span>, file.getPath());</span><br><span class="line">        FileUtils.writeStringToFile(file, <span class="string">"Junit Rules!"</span>);</span><br><span class="line">        String line = FileUtils.readFileToString(file);</span><br><span class="line">        Assert.assertThat(line, is(<span class="string">"Junit Rules!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试完成之后，生成的这个simple.txt文件就会自动删除了。</p><h3 id="取得当前的测试方法名称"><a href="#取得当前的测试方法名称" class="headerlink" title="取得当前的测试方法名称"></a>取得当前的测试方法名称</h3><p>想要取得执行中的测试方法名的时候，通过@Rule注解TestName类的实例化对象可以取得。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Rule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TestName name = <span class="keyword">new</span> TestName();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   log.info(<span class="string">"Test method name: &#123;&#125;"</span>,name.getMethodName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Test <span class="function"><span class="keyword">method</span> <span class="title">name</span>:</span><span class="string">'testMethodName'</span></span><br></pre></td></tr></table></figure><h3 id="在一个运行测试方法过程中收集多个错误信息"><a href="#在一个运行测试方法过程中收集多个错误信息" class="headerlink" title="在一个运行测试方法过程中收集多个错误信息"></a>在一个运行测试方法过程中收集多个错误信息</h3><p>使用 <code>ErrorCollector</code> 类，可以在一个测试方法中收集多个测试错误。也就是说，一个测试方法执行中，不会在第一个确认出错后就停止执行。使用 <code>ErrorCollector</code> 可以在所有点确认完后统一报出。</p><p>比如，有三个点需要check，但是又不想出错了就马上退出测试，可以尝试下面的方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="keyword">public</span> ErrorCollector collector = <span class="keyword">new</span> ErrorCollector();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMoreCollector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line">collector.checkThat(<span class="string">"Value should not be null"</span>, <span class="keyword">null</span>, is(s));</span><br><span class="line"></span><br><span class="line">s = <span class="string">""</span>;</span><br><span class="line">collector.checkThat(<span class="string">"Value should have the length of 1"</span>,s.length(),is(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">s = <span class="string">"Junit!"</span>;</span><br><span class="line">collector.checkThat(<span class="string">"Value should have the length of 10"</span>,s.length(),is(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的测试会报这样的错误信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Failed tests:   testMoreCollector(com.github.tonydeng.demo.java8.JunitRuleTest): Value should have the length of <span class="number">1</span>(..)</span><br><span class="line">  testMoreCollector(com.github.tonydeng.demo.java8.JunitRuleTest): Value should have the length of <span class="number">10</span>(..)</span><br></pre></td></tr></table></figure><p>或者自己手工捕获异常，添加到 <code>ErrorCollector</code> 中，通过 <code>addError</code> 添加的错误信息：。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testErrorCollector</span><span class="params">()</span></span>&#123;</span><br><span class="line">collector.addError(<span class="keyword">new</span> Throwable(<span class="string">"first thing went wrong"</span>));</span><br><span class="line">collector.addError(<span class="keyword">new</span> Throwable(<span class="string">"second thing went wrong"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tests in error:</span><br><span class="line">  testErrorCollector(com.github.tonydeng.demo.java8.JunitRuleTest): first thing went wrong</span><br><span class="line">  testErrorCollector(com.github.tonydeng.demo.java8.JunitRuleTest): second thing went wrong</span><br></pre></td></tr></table></figure><h3 id="设置执行最长时间"><a href="#设置执行最长时间" class="headerlink" title="设置执行最长时间"></a>设置执行最长时间</h3><p>我们有时候要对某些方法调用的时长有要求，如果超出某些时长就算是不符合要求。那我们平时怎么来测试呢？</p><blockquote><p>计算一下调用方法之前和之后的时间差，如果超出某个值，就算不符合要求。</p></blockquote><p>的确，使用上述的方式也可以达到目的，但是还是有太多多余的代码要写了。完全可以尝试一下 <code>Junit</code> 的 <code>Timeout</code>，非常简单就达到你的目的了。</p><p>比如，我们先设置一个5秒的超时，然后用一个无限循环的方法来测试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Rule</span></span><br><span class="line">  <span class="keyword">public</span> Timeout timeout = Timeout.seconds(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.junit.runners.model.TestTimedOutException: test timed out after <span class="number">5</span> seconds</span><br></pre></td></tr></table></figure><h3 id="使用RuleChain"><a href="#使用RuleChain" class="headerlink" title="使用RuleChain"></a>使用RuleChain</h3><p>RuleChain提供一种将多个TestRule串在一起执行的机制。这在JUnit 4.10以后的版本中可以使用。需要根据特定顺序执行多个处理的时候，用RuleChain可以提高效率。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UseRuleChain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> TestRule chain = RuleChain</span><br><span class="line">                           .outerRule(<span class="keyword">new</span> LoggingRule(<span class="string">"outer rule"</span>))</span><br><span class="line">                           .around(<span class="keyword">new</span> LoggingRule(<span class="string">"middle rule"</span>))</span><br><span class="line">                           .around(<span class="keyword">new</span> LoggingRule(<span class="string">"inner rule"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertTrue(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">starting outer rule</span><br><span class="line">starting middle rule</span><br><span class="line">starting inner rule</span><br><span class="line">finished inner rule</span><br><span class="line">finished middle rule</span><br><span class="line">finished outer rule</span><br></pre></td></tr></table></figure><h2 id="Parameterized注解"><a href="#Parameterized注解" class="headerlink" title="Parameterized注解"></a>Parameterized注解</h2><p>如果我们需要对我们的测试方法进行参数化，也就是只写一个测试方法，把若干种情况作为参数传递进去，一次性完成测试。那我们该怎么办？</p><p>可以使用 <code>Parameterized</code> 相关的注解来解决这个问题。</p><p>来一个简单的计算斐波纳契数的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tonydeng on 16/5/12.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(Parameterized<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FibonacciNumbersTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(FibonacciNumbersTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Integer[]&gt; data() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Integer[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>&#125;, &#123;<span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">8</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expected;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FibonacciNumbersTest</span><span class="params">(<span class="keyword">int</span> input, <span class="keyword">int</span> expected)</span> </span>&#123;</span><br><span class="line">        value = input;</span><br><span class="line">        <span class="keyword">this</span>.expected = expected;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fibonacciNumberCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"expected &#123;&#125; fib(value) &#123;&#125;"</span>, expected, fib(value));</span><br><span class="line">        Assert.assertEquals(expected, fib(value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，这么来写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by tonydeng on 16/5/12.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(Parameterized<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FibonacciNumbersTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(FibonacciNumbersTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters(name = <span class="string">"&#123;index&#125;: fib(&#123;0&#125;=&#123;1&#125;)"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Integer[]&gt; data() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Integer[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>&#125;, &#123;<span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">8</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameter</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> fInput;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameter(value = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> fExpected;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParemeter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"fExpected &#123;&#125; fib(fInput) &#123;&#125;"</span>, fExpected, fib(fInput));</span><br><span class="line">        Assert.assertEquals(fExpected, fib(fInput));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的两个例子中，都是利用了 <code>data()</code> 方法构建了各个测试方法的参数，其中返回值的第一个是input参数，第二个是expected参数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/junit-team/junit4/wiki" target="_blank" rel="noopener">junit4 wiki via github</a></p><p><a href="http://www.codeaffine.com/2014/09/24/junit-nutshell-junit-tutorial/" target="_blank" rel="noopener">JUnit Tutorial</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> juit </tag>
            
            <tag> rule </tag>
            
            <tag> testcase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Stream详解</title>
      <link href="2016/04/25/java-stream/"/>
      <url>2016/04/25/java-stream/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/stream-api-java8.png" alt="java8 stream api"></p><p>Stream是 Java 8新增加的类，用来补充集合类。</p><p>Stream代表数据流，流中的数据元素的数量可能是有限的，也可能是无限的。</p><p>Stream和其它集合类的区别在于：其它集合类主要关注与有限数量的数据的访问和有效管理(增删改)，而Stream并没有提供访问和管理元素的方式，而是通过声明数据源的方式，利用可计算的操作在数据源上执行，当然<code>BaseStream.iterator()</code> 和 <code>BaseStream.spliterator()</code>操作提供了遍历元素的方法。</p><p>Java Stream提供了提供了串行和并行两种类型的流，保持一致的接口，提供函数式编程方式，以管道方式提供中间操作和最终执行操作，为Java语言的集合提供了现代语言提供的类似的高阶函数操作，简化和提高了Java集合的功能。</p><p>本文首先介绍Java Stream的特点，然后按照功能分类逐个介绍流的中间操作和终点操作，最后会介绍第三方为Java Stream做的扩展。</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本节翻译整理自<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">Java8 Stream Javadoc</a>，并对流的这些特性做了进一步的解释。</p><p>Stream接口还包含几个基本类型的子接口如<code>IntStream</code>, <code>LongStream</code> 和 <code>DoubleStream</code>。</p><p>关于流和其它集合具体的区别，可以参照下面的列表：</p><ol><li>不存储数据。流是基于数据源的对象，它本身不存储数据元素，而是通过管道将数据源的元素传递给操作。</li><li>函数式编程。流的操作不会修改数据源，例如filter不会将数据源中的数据删除。</li><li>延迟操作。流的很多操作如filter,map等中间操作是延迟执行的，只有到终点操作才会将操作顺序执行。</li><li>可以解绑。对于无限数量的流，有些操作是可以在有限的时间完成的，比如limit(n) 或 findFirst()，这些操作可是实现”短路”(Short-circuiting)，访问到有限的元素后就可以返回。</li><li>纯消费。流的元素只能访问一次，类似Iterator，操作没有回头路，如果你想从头重新访问流的元素，对不起，你得重新生成一个新的流。</li></ol><p>流的操作是以管道的方式串起来的。流管道包含一个数据源，接着包含零到N个中间操作，最后以一个终点操作结束。</p><p><img src="/images/streams.png" alt="java stream"></p><h3 id="并行-Parallelism"><a href="#并行-Parallelism" class="headerlink" title="并行 Parallelism"></a>并行 Parallelism</h3><p>所有的流操作都可以串行执行或者并行执行。</p><p>除非显示地创建并行流，否则Java库中创建的都是串行流。 <code>Collection.stream()</code>为集合创建串行流而<code>Collection.parallelStream()</code>为集合创建并行流。<code>IntStream.range(int, int)</code>创建的是串行流。通过<code>parallel()</code>方法可以将串行流转换成并行流,sequential()方法将流转换成串行流。</p><p>除非方法的Javadoc中指明了方法在并行执行的时候结果是不确定(比如<code>findAny</code>、<code>forEach</code>)，否则串行和并行执行的结果应该是一样的。</p><h3 id="Non-interference"><a href="#Non-interference" class="headerlink" title="Non-interference"></a>Non-interference</h3><p>流可以从非线程安全的集合中创建，当流的管道执行的时候，非concurrent数据源不应该被改变。下面的代码会抛出<code>java.util.ConcurrentModificationException</code>异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>));</span><br><span class="line">Stream&lt;String&gt; sl = l.stream();</span><br><span class="line">sl.forEach(s -&gt; l.add(<span class="string">"three"</span>));</span><br></pre></td></tr></table></figure><p>在设置中间操作的时候，可以更改数据源，只有在执行终点操作的时候，才有可能出现并发问题(抛出异常，或者不期望的结果)，比如下面的代码不会抛出异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>));</span><br><span class="line">Stream&lt;String&gt; sl = l.stream();</span><br><span class="line">l.add(<span class="string">"three"</span>);</span><br><span class="line">sl.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>对于concurrent数据源，不会有这样的问题，比如下面的代码很正常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;(Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>));</span><br><span class="line">Stream&lt;String&gt; sl = l.stream();</span><br><span class="line">sl.forEach(s -&gt; l.add(<span class="string">"three"</span>));</span><br></pre></td></tr></table></figure><p>虽然我们上面例子是在终点操作中对非并发数据源进行修改，但是非并发数据源也可能在其它线程中修改，同样会有并发问题。</p><h3 id="无状态-Stateless-behaviors"><a href="#无状态-Stateless-behaviors" class="headerlink" title="无状态 Stateless behaviors"></a>无状态 Stateless behaviors</h3><p>大部分流的操作的参数都是函数式接口，可以使用Lambda表达式实现。它们用来描述用户的行为，称之为行为参数(behavioral parameters)。</p><p>如果这些行为参数有状态，则流的操作的结果可能是不确定的，比如下面的代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>, ……));</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> State state = <span class="keyword">new</span> State();</span><br><span class="line">Stream&lt;String&gt; sl = l.stream().map(e -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.s)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        state.s = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line">sl.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上面的代码在并行执行时多次的执行结果可能是不同的。这是因为这个lambda表达式是有状态的。</p><h3 id="排序-Ordering"><a href="#排序-Ordering" class="headerlink" title="排序 Ordering"></a>排序 Ordering</h3><p>某些流的返回的元素是有确定顺序的，我们称之为 <em>encounter order</em>。这个顺序是流提供它的元素的顺序，比如数组的encounter order是它的元素的排序顺序，List是它的迭代顺序(iteration order)，对于HashSet,它本身就没有encounter order。</p><p>一个流是否是encounter order主要依赖数据源和它的中间操作，比如数据源List和Array上创建的流是有序的(ordered)，但是在HashSet创建的流不是有序的。</p><p><code>sorted()</code>方法可以将流转换成有序的，<code>unordered</code>可以将流转换成无序的。<br>除此之外，一个操作可能会影响流的有序,比如<code>map</code>方法，它会用不同的值甚至类型替换流中的元素，所以输入元素的有序性已经变得没有意义了，但是对于<code>filter</code>方法来说，它只是丢弃掉一些值而已，输入元素的有序性还是保障的。</p><p>对于串行流，流有序与否不会影响其性能，只是会影响确定性(determinism)，无序流在多次执行的时候结果可能是不一样的。</p><p>对于并行流，去掉有序这个约束可能会提供性能，比如<code>distinct</code>、<code>groupingBy</code>这些聚合操作。</p><h3 id="结合性-Associativity"><a href="#结合性-Associativity" class="headerlink" title="结合性 Associativity"></a>结合性 Associativity</h3><p>一个操作或者函数op满足结合性意味着它满足下面的条件：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">(a <span class="keyword">op</span> b) <span class="keyword">op</span> c == a <span class="keyword">op</span> (b <span class="keyword">op</span> c)</span><br></pre></td></tr></table></figure><p>对于并发流来说，如果操作满足结合性，我们就可以并行计算：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a op b op c op d == (a op b) op (c op d)</span><br></pre></td></tr></table></figure><p>比如<code>min</code>、<code>max</code>以及字符串连接都是满足结合性的。</p><h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><p>可以通过多种方式创建流：</p><ol><li>通过集合的<code>stream()</code>方法或者<code>parallelStream()</code>，比如<code>Arrays.asList(1,2,3).stream()</code>。</li><li>通过<code>Arrays.stream(Object[])</code>方法, 比如<code>Arrays.stream(new int[]{1,2,3})</code>。</li><li>使用流的静态方法，比如<code>Stream.of(Object[])</code>, <code>IntStream.range(int, int)</code> 或者 <code>Stream.iterate(Object, UnaryOperator)，如Stream.iterate(0, n -&gt; n * 2)</code>，或者<code>generate(Supplier&lt;T&gt; s)</code>如<code>Stream.generate(Math::random)</code>。</li><li><code>BufferedReader.lines()</code>从文件中获得行的流。</li><li><code>Files</code>类的操作路径的方法，如<code>list</code>、<code>find</code>、<code>walk</code>等。</li><li>随机数流<code>Random.ints()</code>。</li><li>其它一些类提供了创建流的方法，如<code>BitSet.stream()</code>, <code>Pattern.splitAsStream(java.lang.CharSequence)</code>, 和 <code>JarFile.stream()</code>。</li><li>更底层的使用<code>StreamSupport</code>，它提供了将<code>Spliterator</code>转换成流的方法。</li></ol><h2 id="中间操作-intermediate-operations"><a href="#中间操作-intermediate-operations" class="headerlink" title="中间操作 intermediate operations"></a>中间操作 intermediate operations</h2><p>中间操作会返回一个新的流，并且操作是延迟执行的(lazy)，它不会修改原始的数据源，而且是由在终点操作开始的时候才真正开始执行。<br>这个Scala集合的转换操作不同，Scala集合转换操作会生成一个新的中间集合，显而易见Java的这种设计会减少中间对象的生成。</p><p>下面介绍流的这些中间操作：</p><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p><code>distinct</code>保证输出的流中包含唯一的元素，它是通过<code>Object.equals(Object)</code>来检查是否包含相同的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l = Stream.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"b"</span>)</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(l); <span class="comment">//[a, b, c]</span></span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code>返回的流中只包含满足断言(predicate)的数据。</p><p>下面的代码返回流中的偶数集合。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; l = IntStream.range(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">        .filter( i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .boxed()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(l); <span class="comment">//[2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code>方法将流中的元素映射成另外的值，新的值类型可以和原来的元素的类型不同。</p><p>下面的代码中将字符元素映射成它的哈希码(ASCII值)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; l = Stream.of(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>)</span><br><span class="line">        .map( c -&gt; c.hashCode())</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(l); <span class="comment">//[97, 98, 99]</span></span><br></pre></td></tr></table></figure><h3 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap"></a>flatmap</h3><p><code>flatmap</code>方法混合了<code>map</code> + <code>flattern</code>的功能，它将映射后的流的元素全部放入到一个新的流中。它的方法定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span></span><br></pre></td></tr></table></figure><p>可以看到<code>mapper</code>函数会将每一个元素转换成一个流对象，而flatMap方法返回的流包含的元素为<code>mapper</code>生成的所有流中的元素。</p><p>下面这个例子中将一首唐诗生成一个按行分割的流，然后在这个流上调用<code>flatmap</code>得到单词的小写形式的集合，去掉重复的单词然后打印出来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String poetry = <span class="string">"Where, before me, are the ages that have gone?\n"</span> +</span><br><span class="line">        <span class="string">"And where, behind me, are the coming generations?\n"</span> +</span><br><span class="line">        <span class="string">"I think of heaven and earth, without limit, without end,\n"</span> +</span><br><span class="line">        <span class="string">"And I am all alone and my tears fall down."</span>;</span><br><span class="line">Stream&lt;String&gt; lines = Arrays.stream(poetry.split(<span class="string">"\n"</span>));</span><br><span class="line">Stream&lt;String&gt; words = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">" "</span>)));</span><br><span class="line">List&lt;String&gt; l = words.map( w -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (w.endsWith(<span class="string">","</span>) || w.endsWith(<span class="string">"."</span>) || w.endsWith(<span class="string">"?"</span>))</span><br><span class="line">        <span class="keyword">return</span> w.substring(<span class="number">0</span>,w.length() -<span class="number">1</span>).trim().toLowerCase();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> w.trim().toLowerCase();</span><br><span class="line">&#125;).distinct().sorted().collect(Collectors.toList());</span><br><span class="line">System.out.println(l); <span class="comment">//[ages, all, alone, am, and, are, before, behind, coming, down, earth, end, fall, generations, gone, have, heaven, i, limit, me, my, of, tears, that, the, think, where, without]</span></span><br></pre></td></tr></table></figure><p><code>flatMapToDouble</code>、<code>flatMapToInt</code>、<code>flatMapToLong</code>提供了转换成特定流的方法。</p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p><code>limit</code>方法指定数量的元素的流。对于串行流，这个方法是有效的，这是因为它只需返回前n个元素即可，但是对于有序的并行流，它可能花费相对较长的时间，如果你不在意有序，可以将有序并行流转换为无序的，可以提高性能。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; l = <span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range(<span class="number">1</span>,<span class="number">100</span>).limit(<span class="number">5</span>)</span><br><span class="line">        .boxed<span class="literal">()</span></span><br><span class="line">        .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">List()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(l);<span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><p><code>peek</code>方法方法会使用一个<code>Consumer</code>消费流中的元素，但是返回的流还是包含原来的流中的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">Arrays.stream(arr)</span><br><span class="line">        .peek(System.out::println) <span class="comment">//a,b,c,d</span></span><br><span class="line">        .count();</span><br></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p><code>sorted()</code>将流中的元素按照自然排序方式进行排序，如果元素没有实现Comparable，则终点操作执行时会抛出<code>java.lang.ClassCastException</code>异常。<br><code>sorted(Comparator&lt;? super T&gt; comparator)</code>可以指定排序的方式。</p><p>对于有序流，排序是稳定的。对于非有序流，不保证排序稳定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"b_123"</span>,<span class="string">"c+342"</span>,<span class="string">"b#632"</span>,<span class="string">"d_123"</span>&#125;;</span><br><span class="line">List&lt;String&gt; l  = Arrays.stream(arr)</span><br><span class="line">        .sorted((s1,s2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(<span class="number">0</span>) == s2.charAt(<span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> s1.substring(<span class="number">2</span>).compareTo(s2.substring(<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> s1.charAt(<span class="number">0</span>) - s2.charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(l); <span class="comment">//[b_123, b#632, c+342, d_123]</span></span><br></pre></td></tr></table></figure><h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p><code>skip</code>返回丢弃了前n个元素的流，如果流中的元素小于或者等于n，则返回空的流。</p><h2 id="终点操作-terminal-operations"><a href="#终点操作-terminal-operations" class="headerlink" title="终点操作 terminal operations"></a>终点操作 terminal operations</h2><h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br></pre></td></tr></table></figure><p>这一组方法用来检查流中的元素是否满足断言。</p><p><code>allMatch</code>只有在所有的元素都满足断言时才返回true,否则flase,流为空时总是返回true</p><p><code>anyMatch</code>只有在任意一个元素满足断言时就返回true,否则flase,</p><p><code>noneMatch</code>只有在所有的元素都不满足断言时才返回true,否则flase,</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span><span class="keyword">of</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).all<span class="constructor">Match( <span class="params">i</span> -&gt; <span class="params">i</span> &gt; 0)</span>); <span class="comment">//true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span><span class="keyword">of</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).any<span class="constructor">Match( <span class="params">i</span> -&gt; <span class="params">i</span> &gt; 0)</span>); <span class="comment">//true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Stream</span>.</span></span><span class="keyword">of</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).none<span class="constructor">Match( <span class="params">i</span> -&gt; <span class="params">i</span> &gt; 0)</span>); <span class="comment">//false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(Stream.&lt;Integer&gt;empty<span class="literal">()</span>.all<span class="constructor">Match( <span class="params">i</span> -&gt; <span class="params">i</span> &gt; 0)</span>); <span class="comment">//true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(Stream.&lt;Integer&gt;empty<span class="literal">()</span>.any<span class="constructor">Match( <span class="params">i</span> -&gt; <span class="params">i</span> &gt; 0)</span>); <span class="comment">//false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(Stream.&lt;Integer&gt;empty<span class="literal">()</span>.none<span class="constructor">Match( <span class="params">i</span> -&gt; <span class="params">i</span> &gt; 0)</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><code>count</code>方法返回流中的元素的数量。它实现为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapToLong(e -&gt; <span class="number">1L</span>).sum();</span><br></pre></td></tr></table></figure><h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R,A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T,A,R&gt; collector)</span></span></span><br><span class="line"><span class="function">&lt;R&gt; R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? <span class="keyword">super</span> T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</span></span></span><br></pre></td></tr></table></figure><p>使用一个<code>collector</code>执行<code>mutable reduction</code>操作。辅助类<code>Collectors</code>提供了很多的<code>collector</code>，可以满足我们日常的需求，你也可以创建新的<code>collector</code>实现特定的需求。它是一个值得关注的类，你需要熟悉这些特定的收集器，如聚合类<code>averagingInt</code>、最大最小值<code>maxBy</code> <code>minBy</code>、计数<code>counting</code>、分组<code>groupingBy</code>、字符串连接<code>joining</code>、分区<code>partitioningBy</code>、汇总<code>summarizingInt</code>、化简<code>reducing</code>、转换<code>toXXX</code>等。</p><p>第二个提供了更底层的功能，它的逻辑类似下面的伪代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R result = supplier.get();</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">    accumulator.accept(result, element);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; asList = stringStream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add,</span><br><span class="line">                                           ArrayList::addAll);</span><br><span class="line">String concat = stringStream.collect(StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">                                     StringBuilder::append)</span><br><span class="line">                            .toString();</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>findAny()</code>返回任意一个元素，如果流为空，返回空的<code>Optional</code>，对于并行流来说，它只需要返回任意一个元素即可，所以性能可能要好于<code>findFirst()</code>，但是有可能多次执行的时候返回的结果不一样。<br><code>findFirst()</code>返回第一个元素，如果流为空，返回空的<code>Optional</code>。</p><h3 id="forEach、forEachOrdered"><a href="#forEach、forEachOrdered" class="headerlink" title="forEach、forEachOrdered"></a>forEach、forEachOrdered</h3><p><code>forEach</code>遍历流的每一个元素，执行指定的action。它是一个终点操作，和peek方法不同。这个方法不担保按照流的<code>encounter order</code>顺序执行，如果对于有序流按照它的<code>encounter order</code>顺序执行，你可以使用<code>forEachOrdered</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="max、min"><a href="#max、min" class="headerlink" title="max、min"></a>max、min</h3><p><code>max</code>返回流中的最大值，</p><p><code>min</code>返回流中的最小值。</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>reduce</code>是常用的一个方法，事实上很多操作都是基于它实现的。</p><p>它有几个重载方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">pubic Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span></span><br><span class="line"><span class="function">pubic T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span></span><br><span class="line"><span class="function">pubic &lt;U&gt; U <span class="title">reduce</span><span class="params">(U identity, BiFunction&lt;U,? <span class="keyword">super</span> T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span></span></span><br></pre></td></tr></table></figure><p>第一个方法使用流中的第一个值作为初始值，后面两个方法则使用一个提供的初始值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; total = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).reduce( (x, y) -&gt; x +y);</span><br><span class="line">Integer total2 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).reduce(<span class="number">0</span>, (x, y) -&gt; x +y);</span><br></pre></td></tr></table></figure><p>值得注意的是<code>accumulator</code>应该满足结合性(associative)。</p><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h3><p>将流中的元素放入到一个数组中。</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><code>concat</code>用来连接类型一样的两个流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span></span><br></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p><code>toArray</code>方法将一个流转换成数组，而如果想转换成其它集合类型，西需要调用<code>collect</code>方法，利用<code>Collectors.toXXX</code>方法进行转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,C extends Collection&lt;T&gt;&gt; Collector&lt;T,?,C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> …… toConcurrentMap(……)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T,?,List&lt;T&gt;&gt; toList()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> …… toMap(……)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T,?,Set&lt;T&gt;&gt; toSet()</span><br></pre></td></tr></table></figure><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>虽然Stream提供了很多的操作，但是相对于Scala等语言，似乎还少了一些。一些开源项目提供了额外的一些操作，比如<a href="https://github.com/poetix/protonpack" target="_blank" rel="noopener">protonpack</a>项目提供了下列方法：</p><ul><li>takeWhile and takeUntil</li><li>skipWhile and skipUntil</li><li>zip and zipWithIndex</li><li>unfold</li><li>MapStream</li><li>aggregate</li><li>Streamable</li><li>unique collector</li></ul><p><a href="https://github.com/NitorCreations/java8-utils" target="_blank" rel="noopener">java8-utils</a> 也提供了一些有益的辅助方法。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a><br><a href="http://www.leveluplunch.com/java/examples/" target="_blank" rel="noopener">http://www.leveluplunch.com/java/examples/</a><br><a href="https://github.com/poetix/protonpack" target="_blank" rel="noopener">https://github.com/poetix/protonpack</a><br><a href="https://github.com/NitorCreations/java8-utils" target="_blank" rel="noopener">https://github.com/NitorCreations/java8-utils</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitignore最佳实践</title>
      <link href="2016/04/01/gitignore/"/>
      <url>2016/04/01/gitignore/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/gitignore.jpg" alt="gitignore"></p><h2 id="gitignore的使用场景"><a href="#gitignore的使用场景" class="headerlink" title="gitignore的使用场景"></a>gitignore的使用场景</h2><p>使用Git的同学都知道<code>.gitignore</code> 配置文件用于配置不需要加入版本管理的文件，对版本管理带来很大的便利。今天有个需求就是忽略版本库下除少数几个文件和文件夹之外的所有文件，首先想到的方式是使用gitignore树的概念，即在需要的文件夹下都添加 <code>.gitignore</code> 文件，并在其中设定相应的规则。但是，这种方式比较麻烦。</p><a id="more"></a><h2 id="gitignore的使用模式"><a href="#gitignore的使用模式" class="headerlink" title="gitignore的使用模式"></a>gitignore的使用模式</h2><p>好好研究了一下gitignore的语法，知道了<code>.gitignore</code> 文件过滤有两种模式：开放模式和保守模式。</p><h3 id="开放模式"><a href="#开放模式" class="headerlink" title="开放模式"></a>开放模式</h3><p>开放模式负责设置过滤哪些文件和文件夹</p><p>例如： </p><pre><code> /target/ 表示项目根目录下的target文件夹里面所有的内容都会被过滤，不被跟踪 .classpath 表示项目根目录下的.classpath文件会被过滤，不被跟踪</code></pre><h3 id="保守模式"><a href="#保守模式" class="headerlink" title="保守模式"></a>保守模式</h3><p>保守模式负责设置哪些文件不被过滤，也就是哪些文件要被跟踪</p><p>例如：</p><pre><code> !/target/*.h 表示target文件夹目录下所有的.h文件将被跟踪</code></pre><p>还有就是，gitignore是从上到下逐行匹配的，因此.gitignore文件的编写原则就是：</p><p><strong>先编写开放模式，在编写保守模式</strong></p><p>要不然，开放模式的规则会把保守模式的规则给覆盖了。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面附上我的 <code>.gitignore</code> 文件的示例：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"><span class="addition">!.gitignore</span></span><br><span class="line"><span class="addition">!/posts/</span></span><br></pre></td></tr></table></figure><p>只跟踪版本库中的.gitignore文件和posts目录。这里需要注意的是：</p><pre><code>一定是/*而不是*，/*表示当前目录下的所有文件，而不是所有文件*</code></pre><h2 id="gitignore的简单语法："><a href="#gitignore的简单语法：" class="headerlink" title="gitignore的简单语法："></a>gitignore的简单语法：</h2><ol><li><p>以斜杠“/”开头表目录</p></li><li><p>以星号“*”通配多字符</p></li><li><p>以问号“?”通配单字符</p></li><li><p>以方括号“[]”包含单个字符的匹列表</p></li><li><p>以叹号“!”对匹配结果反</p></li></ol><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>附上几个对大家有帮助的gitignore相关的链接。</p><p><a href="https://git-scm.com/docs/gitignore" target="_blank" rel="noopener">git-scm官网的gitinore文档</a></p><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">progit的Git基础中gitignore相关的部分</a></p><p><a href="https://help.github.com/articles/ignoring-files/" target="_blank" rel="noopener">Github的Ignoring files相关文章</a></p><p><a href="https://github.com/tonydeng/gitignore" target="_blank" rel="noopener">我forked的Github的gitignore项目</a></p><p><a href="https://www.gitignore.io/" target="_blank" rel="noopener">自动生成gitignore配置的网站</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> gitignore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批量转换文件编码</title>
      <link href="2015/11/27/batch-conversion-file-encoding/"/>
      <url>2015/11/27/batch-conversion-file-encoding/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/encoding.png" alt="encoding"></p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>之前同事有一个项目给过来，由于他之前的开发环境是Windows的，文件编码都是GBK的，看起挺不爽的，不符合我们现在的规范。需要将里面的文件全部转换成UTF8的文件编码。</p><p>那我们应该怎么来做呢？</p><p>很简单，写一个shell，利用 <code>iconv</code>转换一下就好了，于是花了5分钟左右写了一个脚本来搞定这个事情。</p><a id="more"></a><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">DIR=<span class="variable">$1</span> <span class="comment"># 转换编码文件目录</span></span><br><span class="line">FT=<span class="variable">$2</span>  <span class="comment"># 需要转换的文件类型（扩展名）</span></span><br><span class="line">SE=<span class="variable">$3</span>  <span class="comment"># 原始编码</span></span><br><span class="line">DE=<span class="variable">$4</span>  <span class="comment"># 目标编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `find <span class="variable">$DIR</span> -<span class="built_in">type</span> f -name <span class="string">"*.<span class="variable">$FT</span>"</span>`; <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"conversion <span class="variable">$file</span> encoding <span class="variable">$SE</span> to <span class="variable">$DE</span>"</span></span><br><span class="line">    iconv -f <span class="variable">$SE</span> -t <span class="variable">$DE</span> <span class="string">"<span class="variable">$file</span>"</span> &gt; <span class="string">"<span class="variable">$file</span>"</span>.tmp</span><br><span class="line">    mv -f <span class="string">"<span class="variable">$file</span>"</span>.tmp <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>该脚本已经提交到<a href="https://github.com/tonydeng/note/blob/1594ae267114effa910ff2511176d3dbf7968471/sh/batch_conversion_encoding.sh" target="_blank" rel="noopener">github</a>上。</p><h1 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h1><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="string">./batch_conversion_encoding.sh</span> ~<span class="string">/sdk1</span> java GBK UTF8</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> iconv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Leiningen</title>
      <link href="2015/11/19/install-leiningen/"/>
      <url>2015/11/19/install-leiningen/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/leiningen.png" alt="leiningen logo"></p><h2 id="Leiningen简单介绍"><a href="#Leiningen简单介绍" class="headerlink" title="Leiningen简单介绍"></a>Leiningen简单介绍</h2><p><a href="http://leiningen.org/" target="_blank" rel="noopener">Leiningen</a>是<a href="https://clojure.org/" target="_blank" rel="noopener">Clojure</a>（貌似需要自备梯子）的项目生命周期管理工具，就像<a href="http://maven.apache.org/" target="_blank" rel="noopener">Maven</a>在<a href="https://java.com/" target="_blank" rel="noopener">Java</a>中的地位一样。</p><p>关于Leiningen具体的情况和使用方法，它的<a href="http://leiningen.org/" target="_blank" rel="noopener">官网</a>和<a href="https://github.com/technomancy/leiningen" target="_blank" rel="noopener">GitHub</a>看看，上面会有更清楚的描述。</p><a id="more"></a><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>我只是给大家说说，在安装Leiningen时可能会碰到的坑。</p><p>先说说，基本安装流程，咱们就遇坑填坑。</p><h3 id="下载lein命令"><a href="#下载lein命令" class="headerlink" title="下载lein命令"></a>下载lein命令</h3><p>下载Leiningen很简单，你使用我的命令来直接下载（仅限Mac OSX和Linux）。当然，你也可以尝试用自己系统的包管理系统来安装。比如Mac OSX可以使用<code>brew install leiningen</code>。</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>cd /usr/local/bin</span><br><span class="line"><span class="variable">$ </span>wget <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/technomancy</span><span class="regexp">/leiningen/stable</span><span class="regexp">/bin/lein</span></span><br><span class="line"><span class="variable">$ </span>chmod <span class="number">755</span> lein</span><br></pre></td></tr></table></figure><p>那我们是否就已经算是安装成功，可以使用Leiningen了呢？别着急，你要是有兴趣，你看看lein这个命令，它其实就只是一段<code>Shell</code>脚本，光有它还是不够的。</p><h3 id="下载Leiningen"><a href="#下载Leiningen" class="headerlink" title="下载Leiningen"></a>下载Leiningen</h3><p>你可以执行一下lein，它就会自动帮你下载正在工作的那个具有超牛力的Leiningen。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ lein </span><br><span class="line">Downloading Leiningen to /Users/tonydeng/.lein/self-installs/leiningen<span class="number">-2.5</span><span class="number">.3</span>-standalone.jar now...</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line"><span class="number">100</span>   <span class="number">605</span>    <span class="number">0</span>   <span class="number">605</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">262</span>      <span class="number">0</span> --:--:--  <span class="number">0</span>:<span class="number">00</span>:<span class="number">02</span> --:--:--   <span class="number">262</span></span><br><span class="line">  <span class="number">0</span> <span class="number">15.0</span>M    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> --:--:--  <span class="number">0</span>:<span class="number">00</span>:<span class="number">37</span> --:--:--     <span class="number">0</span></span><br><span class="line">  <span class="number">0</span> <span class="number">15.0</span>M    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> --:--:--  <span class="number">0</span>:<span class="number">00</span>:<span class="number">38</span> --:--:--     <span class="number">0</span></span><br></pre></td></tr></table></figure><p>然后我就满心期待的等啊等啊，可惜等到的只是一个让人沮丧的错误提示。</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Failed to download https:<span class="regexp">//gi</span>thub.com<span class="regexp">/technomancy/</span>leiningen<span class="regexp">/releases/</span>download<span class="regexp">/2.5.3/</span>leiningen-<span class="number">2.5</span>.<span class="number">3</span>-standalone.zip (<span class="keyword">exit</span> code <span class="number">56</span>)</span><br><span class="line">It<span class="string">'s possible your HTTP client'</span>s certificate store does not have the</span><br><span class="line">correct certificate authority needed. This is often caused by an</span><br><span class="line">out-of-date version of libssl. It<span class="string">'s also possible that you'</span>re behind a</span><br><span class="line">firewall and haven<span class="string">'t set HTTP_PROXY and HTTPS_PROXY.</span></span><br></pre></td></tr></table></figure><p>看到这个提示之后，我的第一反应就是 <del>Fuck GFW</del>！赶紧搭上梯子，再试，依然是不好使。然后怀疑是<code>curl</code>的问题，升级<code>curl</code>到最新版本，依然是不行。没有办法，只好祭出Google（min）大（gan）法（ci）。</p><p>就看到了下面这个leiningen项目中的issue #1634 – <a href="https://github.com/technomancy/leiningen/issues/1634" target="_blank" rel="noopener">Leiningen installation issue on Debian Wheezy #1634</a>，试了试上面给的方案，设置一下<code>HTTP_CLIENT</code>，毕竟上面的错误提示也说到了证书的问题。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">HTTP_CLIENT</span>=<span class="string">"wget --no-check-certificate -O"</span></span><br></pre></td></tr></table></figure><p>这些就OK了。</p><p>不过，让我比较郁闷的，为什么Leiningen版本升级之后，反而错误提示比以前的版本要检阅了呢？还是说，我使用的系统和这个 <code>issue #1634</code>遇到问题的操作系统不一样呢？不管怎么样，也算是安装成功了。</p><p>当你看到下面的命令输出，就说明安装成功了。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ lein --version</span><br><span class="line">Leiningen 2.5.3 on Java 1.8.0_40 Java HotSpot(TM) 64-Bit<span class="built_in"> Server </span>VM</span><br></pre></td></tr></table></figure><p>你可以使用Leiningen的帮助来简单看看它提供的功能。</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ lein -<span class="keyword">h</span></span><br><span class="line">Leiningen is a tool <span class="keyword">for</span> working with Clojure projects.</span><br><span class="line"></span><br><span class="line">Several tasks are available:</span><br><span class="line">change              Rewrite project.clj <span class="keyword">by</span> applying a function.</span><br><span class="line">check               Check <span class="keyword">syntax</span> and warn <span class="keyword">on</span> reflection.</span><br><span class="line">classpath           <span class="keyword">Print</span> the classpath of the current project.</span><br><span class="line">clean               Remove all files from project's target-path.</span><br><span class="line">compile             Compile Clojure source into .<span class="keyword">class</span> files.</span><br><span class="line">deploy              Build and deploy jar to remote repository.</span><br><span class="line">deps                Download all dependencies.</span><br><span class="line"><span class="keyword">do</span>                  Higher-<span class="keyword">order</span> task to perform other tasks <span class="keyword">in</span> succession.</span><br><span class="line"><span class="keyword">help</span>                <span class="keyword">Display</span> a <span class="keyword">list</span> of tasks or <span class="keyword">help</span> <span class="keyword">for</span> a given task.</span><br><span class="line">install             Install the current project to the <span class="keyword">local</span> repository.</span><br><span class="line">jar                 Package up all the project's files into a jar <span class="keyword">file</span>.</span><br><span class="line">javac               Compile Java source files.</span><br><span class="line">new                 <span class="keyword">Generate</span> project scaffolding based <span class="keyword">on</span> a template.</span><br><span class="line"><span class="keyword">plugin</span>              DEPRECATED. Please <span class="keyword">use</span> the :user profile instead.</span><br><span class="line">pom                 Write a pom.xml <span class="keyword">file</span> to disk <span class="keyword">for</span> Maven interoperability.</span><br><span class="line">release             Perform :release-tasks.</span><br><span class="line">repl                Start a repl session either with the current project or standalone.</span><br><span class="line">retest              <span class="keyword">Run</span> only the <span class="keyword">test</span> namespaces <span class="keyword">which</span> failed last time around.</span><br><span class="line"><span class="keyword">run</span>                 <span class="keyword">Run</span> a -main function with optional command-<span class="keyword">line</span> arguments.</span><br><span class="line"><span class="keyword">search</span>              <span class="keyword">Search</span> remote maven repositories <span class="keyword">for</span> matching jars.</span><br><span class="line">show-profiles       <span class="keyword">List</span> all available profiles or <span class="keyword">display</span> <span class="keyword">one</span> <span class="keyword">if</span> given <span class="keyword">an</span> argument.</span><br><span class="line"><span class="keyword">test</span>                <span class="keyword">Run</span> the project's tests.</span><br><span class="line">trampoline          <span class="keyword">Run</span> a task without nesting the project's JVM inside Leiningen's.</span><br><span class="line">uberjar             Package up the project files and dependencies into a jar <span class="keyword">file</span>.</span><br><span class="line"><span class="keyword">update</span>-<span class="keyword">in</span>           Perform arbitrary transformations <span class="keyword">on</span> your project map.</span><br><span class="line">upgrade             Upgrade Leiningen to specified <span class="keyword">version</span> or latest stable.</span><br><span class="line">vcs                 Interact with the <span class="keyword">version</span> control system.</span><br><span class="line"><span class="keyword">version</span>             <span class="keyword">Print</span> <span class="keyword">version</span> <span class="keyword">for</span> Leiningen and the current JVM.</span><br><span class="line">with-profile        Apply the given task with the profile(s) specified.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Run</span> `lein <span class="keyword">help</span> <span class="variable">$TASK</span>` <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Global</span> Options:</span><br><span class="line">  -o             <span class="keyword">Run</span> a task offline.</span><br><span class="line">  -<span class="keyword">U</span>             <span class="keyword">Run</span> a task after forcing <span class="keyword">update</span> of snapshots.</span><br><span class="line">  -<span class="keyword">h</span>, --<span class="keyword">help</span>     <span class="keyword">Print</span> this <span class="keyword">help</span> or <span class="keyword">help</span> <span class="keyword">for</span> a specific task.</span><br><span class="line">  -v, --<span class="keyword">version</span>  <span class="keyword">Print</span> Leiningen's <span class="keyword">version</span>.</span><br><span class="line"></span><br><span class="line">These aliases are available:</span><br><span class="line">downgrade, expands to upgrade</span><br><span class="line"></span><br><span class="line">See also: readme, faq, <span class="keyword">tutorial</span>, <span class="keyword">news</span>, <span class="keyword">sample</span>, profiles, deploying, gpg,</span><br><span class="line">mixed-source, templates, and copying.</span><br></pre></td></tr></table></figure><p>接下来，我就要使用Leiningen来创建和管理Clojure项目了。可以参考一下<a href="https://github.com/technomancy/leiningen/blob/stable/sample.project.clj" target="_blank" rel="noopener">官方提供的简单project.clj例子</a>。</p><h2 id="新建Clojure项目"><a href="#新建Clojure项目" class="headerlink" title="新建Clojure项目"></a>新建Clojure项目</h2><p>用下面的命令就可以轻松创建一下用Leiningen管理的Clojure项目。</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">➜  lein <span class="keyword">new</span> <span class="type">clojure</span>-demo</span><br></pre></td></tr></table></figure><p>我们来看看项目的目录结构，非常全面。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">➜  <span class="selector-tag">clojure-demo</span> <span class="selector-tag">git</span><span class="selector-pseudo">:(master)</span>  <span class="selector-tag">tree</span></span><br><span class="line">.</span><br><span class="line">├── <span class="selector-tag">CHANGELOG</span><span class="selector-class">.md</span></span><br><span class="line">├── <span class="selector-tag">LICENSE</span></span><br><span class="line">├── <span class="selector-tag">README</span><span class="selector-class">.md</span></span><br><span class="line">├── <span class="selector-tag">clojure-demo</span><span class="selector-class">.iml</span></span><br><span class="line">├── <span class="selector-tag">dev-resources</span></span><br><span class="line">├── <span class="selector-tag">doc</span></span><br><span class="line">│   └── <span class="selector-tag">intro</span><span class="selector-class">.md</span></span><br><span class="line">├── <span class="selector-tag">project</span><span class="selector-class">.clj</span></span><br><span class="line">├── <span class="selector-tag">resources</span></span><br><span class="line">├── <span class="selector-tag">src</span></span><br><span class="line">│   └── <span class="selector-tag">clojure_demo</span></span><br><span class="line">│       └── <span class="selector-tag">core</span><span class="selector-class">.clj</span></span><br><span class="line">├── <span class="selector-tag">target</span></span><br><span class="line">│   ├── <span class="selector-tag">classes</span></span><br><span class="line">│   │   └── <span class="selector-tag">META-INF</span></span><br><span class="line">│   │       └── <span class="selector-tag">maven</span></span><br><span class="line">│   │           └── <span class="selector-tag">clojure-demo</span></span><br><span class="line">│   │               └── <span class="selector-tag">clojure-demo</span></span><br><span class="line">│   │                   └── <span class="selector-tag">pom</span><span class="selector-class">.properties</span></span><br><span class="line">│   └── <span class="selector-tag">stale</span></span><br><span class="line">│       └── <span class="selector-tag">extract-native</span><span class="selector-class">.dependencies</span></span><br><span class="line">└── <span class="selector-tag">test</span></span><br><span class="line">    └── <span class="selector-tag">clojure_demo</span></span><br><span class="line">        └── <span class="selector-tag">core_test</span><span class="selector-class">.clj</span></span><br></pre></td></tr></table></figure><p>好了，今天就先弄到这儿。改天在继续更新这个Leiningen + Clojure之旅，比如Leiningen和Maven的整合、Clojure和Java的互相调用等等。</p>]]></content>
      
      
      <categories>
          
          <category> Leiningen + Clojure之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leiningen </tag>
            
            <tag> clojure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程师字体</title>
      <link href="2015/11/19/engineering-fonts/"/>
      <url>2015/11/19/engineering-fonts/</url>
      
        <content type="html"><![CDATA[<p><img src="http://dejavu-fonts.org/wiki/images/d/d3/Dejavu_title.png"></p><p>工程师是一个比较有有意思的群体，比如像我这样有些强迫症的工程师，开始工作之前必须要先选择一个对工程师友好的字体。</p><p>国外有人在2009年就写了一篇文章讲关于程序员的字体。<a href="http://hivelogic.com/articles/top-10-programming-fonts" target="_blank" rel="noopener">top 10 programming forts</a>，上面列了不少优秀的字体。</p><p>知乎上也有不少人在讨论程序员用什么字体比较爽，比如<a href="http://www.zhihu.com/question/20455297" target="_blank" rel="noopener">【哪些字体适合程序员用来维护代码？】</a> ， <a href="http://www.zhihu.com/question/19637242" target="_blank" rel="noopener">【程序员编程看起来最舒服的字体（英文的和中文的）、字号、颜色和背景色是什么？】</a>。</p><p>不过，经过我自己的测试，还是觉得“<a href="http://www.dafont.com/bitstream-vera-mono.font" target="_blank" rel="noopener">Bitstream Vera Mono</a>”，和“<a href="http://dejavu-fonts.org/wiki/Main_Page" target="_blank" rel="noopener">DejaVu Sans Mono</a>”最好用，给大家推荐一下。</p><p>贴一下在终端的效果。</p><p><img src="/images/blog/engineering-fonts/bitstream-vera-mono.png" alt="bitestream-vera-mono font"></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> engineering </tag>
            
            <tag> fonts </tag>
            
            <tag> Bitstream Vera Mono </tag>
            
            <tag> DejaVu Sans Mono </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Java中使用Maven配置的版本信息</title>
      <link href="2015/11/17/using-maven-version/"/>
      <url>2015/11/17/using-maven-version/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/using-maven-version.png" alt="HSC Maven Version"></p><h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>我们在开发一些项目的时候需要知道当前的版本状态，比如传递版本客户端信息到服务端等等。</p><p>那我们有些什么办法能够获取当前项目版本呢？</p><p>比较简单的办法就是在我们的程序中写一个常量来记录版本号，每次升级了就更新这个常量。但是这个方案还需要我们每次升级的时候都要记得这个事情，这个对于我这种记性不太好的人来说，简直就是灾难。</p><p>那还有什么更好的办法吗？</p><a id="more"></a><p>那我们可以从本身项目所使用的项目生命周期管理工具来考虑。比如现在<code>Java</code>的项目大部分还是用Maven来做项目生命周期管理的，那我们可不可以将<code>Maven</code>所记录的版本信息读取出来呢？</p><p>应该是可以，不过，如果要读取出来，我们是否需要去分析<code>Maven</code>的<code>pom.xml</code>文件吗？如果是这样，工作量也有点大。</p><p>其实<code>maven</code>已经给出了方案，就是可以在自定义的资源文件（<code>properties</code>）中放置<code>pom.xml</code>设置的变量，就会自动将变量替换成为真实地值。</p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p>我有一个hsc的项目，代码中需要知道当前项目的版本。那我应该怎么来做呢？</p><h3 id="在src-main-resources-hsc-application-properties文件中放置如下内容："><a href="#在src-main-resources-hsc-application-properties文件中放置如下内容：" class="headerlink" title="在src/main/resources/hsc-application.properties文件中放置如下内容："></a>在src/main/resources/hsc-application.properties文件中放置如下内容：</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">hsc.version</span>=<span class="variable">$&#123;project.version&#125;</span></span><br></pre></td></tr></table></figure><h3 id="配置pom-xml"><a href="#配置pom-xml" class="headerlink" title="配置pom.xml"></a>配置pom.xml</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;build&gt;</span></span><br><span class="line">       <span class="params">&lt;resources&gt;</span></span><br><span class="line">           <span class="params">&lt;resource&gt;</span></span><br><span class="line">               <span class="params">&lt;directory&gt;</span>src<span class="meta-keyword">/main/</span>resources<span class="params">&lt;/directory&gt;</span></span><br><span class="line">               <span class="params">&lt;filtering&gt;</span>true<span class="params">&lt;/filtering&gt;</span></span><br><span class="line">           <span class="params">&lt;/resource&gt;</span></span><br><span class="line">       <span class="params">&lt;/resources&gt;</span></span><br><span class="line"><span class="params">&lt;/build&gt;</span></span><br></pre></td></tr></table></figure><h3 id="实现对hsc-version的读取"><a href="#实现对hsc-version的读取" class="headerlink" title="实现对hsc.version的读取"></a>实现对hsc.version的读取</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取HSC版本信息</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   public static String get<span class="constructor">HSCVersion()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (null<span class="operator"> == </span>HSCVersion) &#123;</span><br><span class="line">           Properties properties = <span class="keyword">new</span> <span class="constructor">Properties()</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               properties.load(<span class="module-access"><span class="module"><span class="identifier">HSCUtils</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>.get<span class="constructor">ResourceAsStream(<span class="string">"hsc-application.properties"</span>)</span>);</span><br><span class="line">               <span class="keyword">if</span> (!properties.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">                   HSCVersion = properties.get<span class="constructor">Property(<span class="string">"hsc.version"</span>)</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (IOException e) &#123;</span><br><span class="line">               e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return HSCVersion;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="测试获取版本信息"><a href="#测试获取版本信息" class="headerlink" title="测试获取版本信息"></a>测试获取版本信息</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">  <span class="built_in">public</span> <span class="type">void</span> testApplicationVersion()&#123;</span><br><span class="line">      String version = HSCUtils.getHSCVersion();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">log</span>.<span class="keyword">info</span>("hsc version:'&#123;&#125;'",<span class="keyword">version</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://books.sonatype.com/mvnref-book/reference/resource-filtering-sect-properties.html" target="_blank" rel="noopener">maven可以使用内部变量</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
            <tag> properties </tag>
            
            <tag> version </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java发送邮件出现&quot;no object dch for mime type multipart/mixed&quot;异常的解决办法及过程</title>
      <link href="2015/10/30/java-mail-no-object-dch-for-mime-type-multipart-mixed/"/>
      <url>2015/10/30/java-mail-no-object-dch-for-mime-type-multipart-mixed/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/email-error/error.jpg" alt="email error"></p><p>前两天写了一个发送邮件的功能，结果出现了一个比较灵异的状况，现在整理一下解决办法和中间的过程。</p><a id="more"></a><h1 id="发送邮件配置及代码"><a href="#发送邮件配置及代码" class="headerlink" title="发送邮件配置及代码"></a>发送邮件配置及代码</h1><p>通过Java来发送邮件现在已经是非常方便就实现的功能。只需要使用<code>commons-email</code>这个第三方的包就可以很轻松的完成功能。</p><p><code>commons-email</code>的<code>maven</code>依赖配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-email<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它会传递依赖<code>mail</code>和<code>activation</code>这两个包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.mail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>发送邮件的代码也非常简单：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param recipients</span></span><br><span class="line"><span class="comment"> * @param subject</span></span><br><span class="line"><span class="comment"> * @param content</span></span><br><span class="line"><span class="comment"> * @throws TException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public void send<span class="constructor">Mails(List&lt;Recipient&gt; <span class="params">recipients</span>, String <span class="params">subject</span>, String <span class="params">content</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;InternetAddress&gt; addresses = get<span class="constructor">Replys(<span class="params">recipients</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(log.is<span class="constructor">InfoEnabled()</span>)&#123;</span><br><span class="line">            log.info(<span class="string">"send mail to recipients:'&#123;&#125;' subject:'&#123;&#125;'"</span>, addresses, subject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">CollectionUtils</span>.</span></span>is<span class="constructor">NotEmpty(<span class="params">addresses</span>)</span>)&#123;</span><br><span class="line">            Email email = setting<span class="constructor">Email(<span class="params">new</span> HtmlEmail()</span>);</span><br><span class="line">            email.set<span class="constructor">Subject(<span class="params">subject</span>)</span>;</span><br><span class="line">            email.set<span class="constructor">Msg(<span class="params">content</span>)</span>;</span><br><span class="line">            email.set<span class="constructor">To(<span class="params">addresses</span>)</span>;</span><br><span class="line">            email.send<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (EmailException e) &#123;</span><br><span class="line">        e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置邮件配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param email</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> * @throws EmailException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Email setting<span class="constructor">Email(Email <span class="params">email</span>)</span> throws EmailException &#123;</span><br><span class="line">    email.set<span class="constructor">HostName(<span class="params">mailConfig</span>.<span class="params">getProperty</span>(<span class="string">"mail.host"</span>)</span>);</span><br><span class="line">    email.set<span class="constructor">Charset(<span class="params">mailConfig</span>.<span class="params">getProperty</span>(<span class="string">"mail.charset"</span>)</span>);</span><br><span class="line">    email.set<span class="constructor">SSLOnConnect(<span class="params">true</span>)</span>;</span><br><span class="line">    email.set<span class="constructor">Authentication(<span class="params">mailConfig</span>.<span class="params">getProperty</span>(<span class="string">"mail.username"</span>)</span>, mailConfig.get<span class="constructor">Property(<span class="string">"mail.password"</span>)</span>);</span><br><span class="line">    email.set<span class="constructor">From(<span class="params">mailConfig</span>.<span class="params">getProperty</span>(<span class="string">"mail.from"</span>)</span>);</span><br><span class="line">    return email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，代码写完了，单元测试也没有问题，一般情况下，就认为这个功能完成了，那么就打包部署吧。我现在使用了<code>Thrift</code>作为RPC框架，没有想到部署到测试环境中发现使用<code>Thrift</code>客户端调用发送邮件服务却无法正常发送邮件。</p><h1 id="灵异状况"><a href="#灵异状况" class="headerlink" title="灵异状况"></a>灵异状况</h1><p>查看日志，却发现出现了下面的异常。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Caused by: javax.activation.UnsupportedDataTypeException: no object DCH for MIME <span class="keyword">type</span> multipart/mixed;</span><br><span class="line">boundary=<span class="string">"----=_Part_0_1434202756.1446193111088"</span></span><br><span class="line">at javax.activation.<span class="module-access"><span class="module"><span class="identifier">ObjectDataContentHandler</span>.</span></span>write<span class="constructor">To(DataHandler.<span class="params">java</span>:896)</span></span><br><span class="line">at javax.activation.<span class="module-access"><span class="module"><span class="identifier">DataHandler</span>.</span></span>write<span class="constructor">To(DataHandler.<span class="params">java</span>:317)</span></span><br><span class="line">at javax.mail.internet.<span class="module-access"><span class="module"><span class="identifier">MimeBodyPart</span>.</span></span>write<span class="constructor">To(MimeBodyPart.<span class="params">java</span>:1485)</span></span><br><span class="line">at javax.mail.internet.<span class="module-access"><span class="module"><span class="identifier">MimeMessage</span>.</span></span>write<span class="constructor">To(MimeMessage.<span class="params">java</span>:1773)</span></span><br><span class="line">at com.sun.mail.smtp.<span class="module-access"><span class="module"><span class="identifier">SMTPTransport</span>.</span></span>send<span class="constructor">Message(SMTPTransport.<span class="params">java</span>:1121)</span></span><br><span class="line"><span class="operator">... </span><span class="number">17</span> more</span><br></pre></td></tr></table></figure><p>当时的第一反应，是否是邮件服务器那边做了调整，出现新的状况？毕竟之前的单元测试也没有问题。</p><p>那重新写一个新的单元测试看看是怎么回事。</p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">testSendMails</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Recipient&gt; recipients = Lists.newArrayList(</span><br><span class="line">            <span class="keyword">new</span> Recipient(<span class="string">"tonydeng"</span>,<span class="string">"tonydeng@github.com"</span>,<span class="string">""</span>,<span class="string">""</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    notifyUtils.sendMails(recipients,<span class="string">"test"</span>,<span class="string">"content"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑了好几次，都可以正常发送邮件，那是怎么回事？难道是通过thrift之后，中间有些信息发生变化？</p><p>将代码通过maven打包成功可执行的jar，启动thrift server，在调用Agent项目的单元测试，果然出现<strong>“no object DCH for MIME type multipart/mixed;”</strong>的异常。</p><p>果然很灵异，一般来说，在邮件服务的单元测试跑通之后，这个功能就应该是没有问题了。</p><p>现在出现了在服务端写的单元测试可以跑通，客户端的单元测试却出现异常。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>翻墙通过Google查了一下，主要的原因都是因为<code>mailcap</code>配置的问题。解决方案有两个。</p><h2 id="一个是在代码中加上一段mailcap配置"><a href="#一个是在代码中加上一段mailcap配置" class="headerlink" title="一个是在代码中加上一段mailcap配置"></a>一个是在代码中加上一段mailcap配置</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">MailcapCommandMap mc = (MailcapCommandMap) <span class="module-access"><span class="module"><span class="identifier">CommandMap</span>.</span></span>get<span class="constructor">DefaultCommandMap()</span>;</span><br><span class="line">mc.add<span class="constructor">Mailcap(<span class="string">"text/html;; x-java-content-handler=com.sun.mail.handlers.text_html"</span>)</span>;</span><br><span class="line">mc.add<span class="constructor">Mailcap(<span class="string">"text/xml;; x-java-content-handler=com.sun.mail.handlers.text_xml"</span>)</span>;</span><br><span class="line">mc.add<span class="constructor">Mailcap(<span class="string">"text/plain;; x-java-content-handler=com.sun.mail.handlers.text_plain"</span>)</span>;</span><br><span class="line">mc.add<span class="constructor">Mailcap(<span class="string">"multipart/*;; x-java-content-handler=com.sun.mail.handlers.multipart_mixed"</span>)</span>;</span><br><span class="line">mc.add<span class="constructor">Mailcap(<span class="string">"message/rfc822;; x-java-content-handler=com.sun.mail.handlers.message_rfc822"</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">CommandMap</span>.</span></span>set<span class="constructor">DefaultCommandMap(<span class="params">mc</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="一个是将javax-mail下的mailcap相关文件复制到当前项目的META-INF目录下。"><a href="#一个是将javax-mail下的mailcap相关文件复制到当前项目的META-INF目录下。" class="headerlink" title="一个是将javax.mail下的mailcap相关文件复制到当前项目的META-INF目录下。"></a>一个是将javax.mail下的mailcap相关文件复制到当前项目的<code>META-INF</code>目录下。</h2><p>查看了一下<code>MailcapCommandMap</code>源码，在<code>META-INF</code>中加入<code>mailcap</code>配置文件，也应该能够和在代码中加入<code>mailcap</code>配置起到一样的作用。</p><p>附上<code>MailcapCommandMap</code>初始化方法：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="constructor">MailcapCommandMap()</span> &#123;</span><br><span class="line">        ArrayList dbv = <span class="keyword">new</span> <span class="constructor">ArrayList(5)</span>;</span><br><span class="line">        MailcapFile mf = null;</span><br><span class="line">        dbv.add((Object)null);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">LogSupport</span>.</span></span>log(<span class="string">"MailcapCommandMap: load HOME"</span>);</span><br><span class="line"></span><br><span class="line">        String ex;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ex = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Property(<span class="string">"user.home"</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(ex != null) &#123;</span><br><span class="line">                String path = ex + <span class="module-access"><span class="module"><span class="identifier">File</span>.</span></span>separator + <span class="string">".mailcap"</span>;</span><br><span class="line">                mf = this.load<span class="constructor">File(<span class="params">path</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span>(mf != null) &#123;</span><br><span class="line">                    dbv.add(mf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SecurityException var7) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">LogSupport</span>.</span></span>log(<span class="string">"MailcapCommandMap: load SYS"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ex = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Property(<span class="string">"java.home"</span>)</span> + <span class="module-access"><span class="module"><span class="identifier">File</span>.</span></span>separator + <span class="string">"lib"</span> + <span class="module-access"><span class="module"><span class="identifier">File</span>.</span></span>separator + <span class="string">"mailcap"</span>;</span><br><span class="line">            mf = this.load<span class="constructor">File(<span class="params">ex</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(mf != null) &#123;</span><br><span class="line">                dbv.add(mf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SecurityException var6) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">LogSupport</span>.</span></span>log(<span class="string">"MailcapCommandMap: load JAR"</span>);</span><br><span class="line">        this.load<span class="constructor">AllResources(<span class="params">dbv</span>, <span class="string">"META-INF/mailcap"</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">LogSupport</span>.</span></span>log(<span class="string">"MailcapCommandMap: load DEF"</span>);</span><br><span class="line">        synchronized(<span class="module-access"><span class="module"><span class="identifier">MailcapCommandMap</span>.</span></span><span class="keyword">class</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(defDB<span class="operator"> == </span>null) &#123;</span><br><span class="line">                defDB = this.load<span class="constructor">Resource(<span class="string">"/META-INF/mailcap.default"</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(defDB != null) &#123;</span><br><span class="line">            dbv.add(defDB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.DB = <span class="keyword">new</span> MailcapFile<span class="literal">[<span class="identifier">dbv</span>.<span class="identifier">size</span>()]</span>;</span><br><span class="line">        this.DB = (MailcapFile<span class="literal">[]</span>)((MailcapFile<span class="literal">[]</span>)dbv.<span class="keyword">to</span><span class="constructor">Array(<span class="params">this</span>.DB)</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>按照我的习惯，能够配置的就不要写在代码里了，看样子正解应该是在<code>META-INF</code>文件夹中加入<code>mailcap</code>配置文件了。</p><p>于是从<code>activation</code>包中将mailcap.default文件拷贝到<code>META-INF</code>中，并更新了maven打包的配置。</p><p>结果，还是不行？</p><p>难道还是要在代码中加入<code>mailcap</code>的配置？尝试了一下在代码中加入相关配置代码，的确可以正常发送邮件，但是这样的解决办法是在是太不爽了。</p><h1 id="那继续看看还有哪儿出问题了。"><a href="#那继续看看还有哪儿出问题了。" class="headerlink" title="那继续看看还有哪儿出问题了。"></a>那继续看看还有哪儿出问题了。</h1><p>于是我在发送邮件之前将当期的支持的mimetype都打印出来看看。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(log.is<span class="constructor">InfoEnabled()</span>)&#123;</span><br><span class="line">       MailcapCommandMap mc = (MailcapCommandMap) <span class="module-access"><span class="module"><span class="identifier">CommandMap</span>.</span></span>get<span class="constructor">DefaultCommandMap()</span>;</span><br><span class="line">       log.info(<span class="string">"mail mimetypes:'&#123;&#125;' multipart/mixed:'&#123;&#125;' "</span>, mc.get<span class="constructor">MimeTypes()</span>, mc.get<span class="constructor">AllCommands(<span class="string">"multipart/mixed"</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现在server端单元测试的输出和打包后的输出有很大的差异。</p><ul><li>单元测试的输出</li></ul><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">mail mimetypes:'[<span class="built_in">text</span>/html, message/rfc822, multipart/*, <span class="built_in">text</span>/xml, <span class="built_in">text</span>/plain, <span class="built_in">text</span>/*, image/jpeg, image/gif]' multipart/mixed:'[javax.activation.CommandInfo@<span class="number">349859e0</span>]'</span><br></pre></td></tr></table></figure><ul><li>打包后的输出</li></ul><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">mail <span class="string">mimetypes:</span><span class="string">'text/*'</span></span><br></pre></td></tr></table></figure><p>看样子应该是打包之后配置加载问题。</p><p>再重新check一下<code>MailcapCommandMap</code>的代码，看样子应该是这段代码的缘故。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(MailcapCommandMap<span class="class">.<span class="keyword">class</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span>(defDB == <span class="literal">null</span>) &#123;</span><br><span class="line">        defDB = <span class="keyword">this</span>.loadResource(<span class="string">"/META-INF/mailcap.default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看样子，应该是defDB中有<code>[text/*]</code>,所以，就没有走到读取<code>/META-INF/mailcap.default</code>文件</p><h1 id="最终解决办法"><a href="#最终解决办法" class="headerlink" title="最终解决办法"></a>最终解决办法</h1><p>其实也很简单，将<code>mailcap.default</code>重命名为<code>mailcap</code>就好了。<code>MailcapCommandMap</code>不管怎么样都会读取到<code>mailcap</code>文件了。</p><h2 id="MailcapCommandMap相关代码"><a href="#MailcapCommandMap相关代码" class="headerlink" title="MailcapCommandMap相关代码"></a>MailcapCommandMap相关代码</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">LogSupport</span>.</span></span>log(<span class="string">"MailcapCommandMap: load JAR"</span>);</span><br><span class="line">this.load<span class="constructor">AllResources(<span class="params">dbv</span>, <span class="string">"META-INF/mailcap"</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">LogSupport</span>.</span></span>log(<span class="string">"MailcapCommandMap: load DEF"</span>);</span><br><span class="line">synchronized(<span class="module-access"><span class="module"><span class="identifier">MailcapCommandMap</span>.</span></span><span class="keyword">class</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(defDB<span class="operator"> == </span>null) &#123;</span><br><span class="line">        defDB = this.load<span class="constructor">Resource(<span class="string">"/META-INF/mailcap.default"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mailcap配置"><a href="#mailcap配置" class="headerlink" title="mailcap配置"></a>mailcap配置</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Default mailcap file for the JavaMail System.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># JavaMail content-handlers:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">text/plain;;x-java-content-<span class="keyword">handler</span>=com.sun.mail.handlers.text_plain</span><br><span class="line"><span class="built_in">text</span>/html;;x-java-content-<span class="keyword">handler</span>=com.sun.mail.handlers.text_html</span><br><span class="line"><span class="built_in">text</span>/<span class="keyword">xml</span>;;x-java-content-<span class="keyword">handler</span>=com.sun.mail.handlers.text_xml</span><br><span class="line">multipart<span class="comment">/*;;x-java-content-handler=com.sun.mail.handlers.multipart_mixed; x-java-fallback-entry=true</span></span><br><span class="line"><span class="comment">message/rfc822;;x-java-content-handler=com.sun.mail.handlers.message_rfc822</span></span><br></pre></td></tr></table></figure><h2 id="Maven-assembly中mailcap相关配置"><a href="#Maven-assembly中mailcap相关配置" class="headerlink" title="Maven assembly中mailcap相关配置"></a>Maven assembly中mailcap相关配置</h2><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;file&gt;</span></span><br><span class="line">    <span class="params">&lt;source&gt;</span>src<span class="meta-keyword">/main/</span>resources/META-INF/mailcap<span class="params">&lt;/source&gt;</span></span><br><span class="line">    <span class="params">&lt;outputDirectory&gt;</span>META-INF<span class="params">&lt;/outputDirectory&gt;</span></span><br><span class="line"><span class="params">&lt;/file&gt;</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.jboss.org/thread/176802?_sscc=t" target="_blank" rel="noopener">https://developer.jboss.org/thread/176802?_sscc=t</a><br><a href="http://www.jguru.com/faq/view.jsp?EID=237257" target="_blank" rel="noopener">http://www.jguru.com/faq/view.jsp?EID=237257</a><br><a href="http://jimwayne.blogspot.jp/2013/02/no-object-dch-for-mime-type.html" target="_blank" rel="noopener">http://jimwayne.blogspot.jp/2013/02/no-object-dch-for-mime-type.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> engineered </tag>
            
            <tag> java </tag>
            
            <tag> mailcap </tag>
            
            <tag> email </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用“六顶思考帽”优化会议效率</title>
      <link href="2015/10/24/the-six-thinking-hats/"/>
      <url>2015/10/24/the-six-thinking-hats/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/the-six-thinking-hasts/hasts.jpg" alt="六顶思考帽"></p><h1 id="为何我们讨厌开会"><a href="#为何我们讨厌开会" class="headerlink" title="为何我们讨厌开会"></a>为何我们讨厌开会</h1><p>“哎！今天糟透了，开了一天的会却什么问题也没有解决。我的忍耐力已经到了极限了,这个该死的会议不仅不不能解决问题，而且还在破坏我的团队。我的工作已经不得不因为会议再次延迟了，我不明白会议到底是要解决问题而是要巩固某些人在公司的政治地位。他们到底何时才能明白，当一条大船即将沉没的时候，船员需要的发号施令的船长，而不是一天又一天的开会！”</p><p>上面的话，是曾经我的一个同事兼好友在很久之前的某一天在聊天时向我吐槽他们公司无效的会议给他带来的困扰。这段话我印象非常深刻，因为我有时候也有同样地想法。不知道大家看到上面的一段话，是否也于心有戚戚耶。</p><a id="more"></a><p>不过，作为一个已经踏入到管理职能的职场人来说，开会对于你日常的工作来说，这些都是必不可少的，甚至对于有些职能来说，会议基本上可能是他工作的全部或大部分。</p><p>那么，为什么我们还吐槽呢？</p><p><strong>其实我们吐槽的不是会议，而是无效的会议。</strong></p><h1 id="为什么我们要开会？"><a href="#为什么我们要开会？" class="headerlink" title="为什么我们要开会？"></a>为什么我们要开会？</h1><p>我们先来看看词典对<a href="http://cn.bing.com/knows/search?intlF=0&q=%E5%BC%80%E4%BC%9A&FORM=HDRSC7&mkt=zh-cn" target="_blank" rel="noopener">“开会”的解释</a></p><blockquote><p>开会：召集若干人议事；多人聚集于一定处所议事；举行会议或集会；有会议或集会。</p></blockquote><p>会议的意义是什么呢？</p><p>广义的会议就是让不同的人走到一起来交流，通过思想的碰撞，产生新的想法和创意。</p><p>从某种角度来说，会议可能是一个公司成本较高的一种行为,也是组织中不能缺少的一种工作方式。</p><p>因为，一般参加会议的人都会是属于这个组织中的管理者和核心员工，这些人的时间成本和经济成本在组织中都是非常高的。如果会议没有效率，那么对组织的影响和伤害是非常大的。</p><p>这些的问题，应该大部分的人都能够意识到，为什么我们还是会面临这样的状况呢？</p><blockquote><p>“争论中，争论双方都是对的，但是他们看到的知识事物的不同侧面”。– 爱德华·德·波诺</p></blockquote><p>很多时候，由于参加会议的人经历、见识、立场都各有不同，看同一事物的角度和方法都各有差异。如果各自都坚持自己的看法，那必须是一个争执不休的场景。就算是最擅长妥协和权限的政治家们，也会出现这样的如下的场景。</p><p><img src="/images/blog/the-six-thinking-hasts/parliament.png" alt="议会"></p><p>甚至有这样暴力+香艳的场面，<a href="http://news.163.com/08/0125/14/432G47RF0001121M.html" target="_blank" rel="noopener">世界议会暴力大观：日本女议员打架掉胸罩(组图)</a>，来自有态度的网易新闻，大家有兴趣，可以去自己点击链接去查看 ^_^</p><h1 id="会议无效率的原因"><a href="#会议无效率的原因" class="headerlink" title="会议无效率的原因"></a>会议无效率的原因</h1><p>我的理解中，会议对于一个组织来说，是<strong>一个能够快速沟通并达成一致结论的方式和工具</strong>。</p><p>但是现实工作中，我们在会议上花费了太多的时间，这些原本能够为公司产生生产力的时间，都浪费在冗长而低效的会议室上。这些会议通常洋溢着令人厌烦的气氛，大多数时候，我们都得到这样的结论–“会议在拖我们的后腿”。</p><p>仔细分析一下，一般“拖我们后腿的会议”都有如下几个特点：</p><ol><li>会议的主题不明确。</li><li>会议讨论的过程中太过发散，跳跃性过大，导致整个会议过程拖沓。</li><li>会议主持人控制力不够。</li><li>争执不休，无法决策。</li><li>会议结束后也没有具体的结论和方案。</li><li>……</li></ol><p>其实这些特点，总体来说，就是在<strong>会议过程中的某（zheng）个（ge）环节（主题、人、过程……）上缺乏聚焦</strong>。</p><p>另外，还有一个非常重要的问题，就是会后的执行，好多时候，会开完了就大家就开始“玩会儿了”。</p><h1 id="六顶思考帽介绍"><a href="#六顶思考帽介绍" class="headerlink" title="六顶思考帽介绍"></a>六顶思考帽介绍</h1><p>我们先看看<a href="https://wikipedia.org/" target="_blank" rel="noopener">维基百科</a>的<a href="https://zh.wikipedia.org/zh-cn/%E5%85%AD%E9%A1%B6%E6%80%9D%E8%80%83%E5%B8%BD%E5%AD%90" target="_blank" rel="noopener">六顶思考帽的定义</a>（如要翻墙，请自备梯子）：</p><blockquote><p>德·波诺帽子方法，或称为六顶帽思考方法，是一种将群体讨论和个体思考相结合的思考方法。这种思考方法是由<a href="https://zh.wikipedia.org/wiki/%E6%84%9B%E5%BE%B7%E8%8F%AF%C2%B7%E5%BE%B7%C2%B7%E6%B3%A2%E8%AB%BE" target="_blank" rel="noopener">爱德华·德·波诺</a>在其介绍思考方法的书籍<a href="http://book.douban.com/subject/3031961/" target="_blank" rel="noopener">六顶思考帽（Six Thinking hats）</a>中提出的，该书全球销量超过3000万册。</p></blockquote><h2 id="每顶帽子的定义"><a href="#每顶帽子的定义" class="headerlink" title="每顶帽子的定义"></a>每顶帽子的定义</h2><h3 id="白色思考帽："><a href="#白色思考帽：" class="headerlink" title="白色思考帽："></a>白色思考帽：</h3><blockquote><p>中立而客观。<br>白色思考帽代表客观的事实与数据。<br>我们需要得到什么资讯？</p></blockquote><h3 id="红色思考帽："><a href="#红色思考帽：" class="headerlink" title="红色思考帽："></a>红色思考帽：</h3><blockquote><p>暗示著愤怒与情感。<br>红色思考帽代表情绪上的感觉、直觉和预感。<br>现在你感觉这个怎么样？但你不必刻意去证明你的感觉。</p></blockquote><h3 id="黑色思考帽："><a href="#黑色思考帽：" class="headerlink" title="黑色思考帽："></a>黑色思考帽：</h3><blockquote><p>负面。<br>黑色思考帽也就是考虑事物的负面因素，它是对事物负面因素的注意、判断和评估。<br>这是真的吗？它会起作用吗？缺点是什么？它有什么问题？为什么不能做。</p></blockquote><h3 id="黄色思考帽："><a href="#黄色思考帽：" class="headerlink" title="黄色思考帽："></a>黄色思考帽：</h3><blockquote><p>耀眼、正面。<br>黄色思考帽代表乐观、希望与正面思想。<br>为什么这个值得做？为什么可以作这件事？它为什么会起作用？</p></blockquote><h3 id="绿色思考帽："><a href="#绿色思考帽：" class="headerlink" title="绿色思考帽："></a>绿色思考帽：</h3><blockquote><p>草地的颜色。<br>绿色思考帽代表创意与创造性新的想法。<br>有不同的想法？新的想法、建议和假设是什么？可能的解决办法和行动的过程是什么？其他可能的选择是什么？</p></blockquote><h3 id="蓝色思考帽："><a href="#蓝色思考帽：" class="headerlink" title="蓝色思考帽："></a>蓝色思考帽：</h3><blockquote><p>天空的颜色。<br>蓝色思考帽代表思维过程的控制与组织。<br>它可以控制其他思考帽的使用。</p></blockquote><p><img src="/images/blog/the-six-thinking-hasts/6K-by-xmind.png" alt="XMind提供的六顶思考帽模板"></p><blockquote><p><a href="http://www.xmind.net/" target="_blank" rel="noopener">XMind</a>也提供了<a href="http://www.xmind.net/m/6K7b/" target="_blank" rel="noopener">六顶思考帽的模板</a>，大家如果使用XMind的话，可以直接创建六顶思考帽的思维导图。</p></blockquote><h2 id="六个思考帽能够解决的问题"><a href="#六个思考帽能够解决的问题" class="headerlink" title="六个思考帽能够解决的问题"></a>六个思考帽能够解决的问题</h2><ol><li>聚焦并且改进想法的过程</li><li>鼓励创造性，平行和水平思考</li><li>改进沟通</li><li>加速做决定</li><li>避免辩论</li></ol><h1 id="利用六顶思考帽优化开会效率"><a href="#利用六顶思考帽优化开会效率" class="headerlink" title="利用六顶思考帽优化开会效率"></a>利用六顶思考帽优化开会效率</h1><p>那我们是否可以利用六个思考帽来优化开会效率呢？我们可以先看看之前总结的<a href="#%E4%BC%9A%E8%AE%AE%E6%97%A0%E6%95%88%E7%8E%87%E7%9A%84%E5%8E%9F%E5%9B%A0">会议无效率的原因</a>以及<a href="#%E5%85%AD%E4%B8%AA%E6%80%9D%E8%80%83%E5%B8%BD%E8%83%BD%E5%A4%9F%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">六个思考帽能够解决的问题</a>。那聪明人应该能够想到如何利用六个帽子来解决问题了吧。</p><blockquote><p>“六顶思考帽使我们的会议时间减少了80%，同时也改变了整个欧洲的企业文化。” – J.P.摩根国际投资银行。</p></blockquote><h2 id="单独使用某一顶帽子"><a href="#单独使用某一顶帽子" class="headerlink" title="单独使用某一顶帽子"></a>单独使用某一顶帽子</h2><p>如果，会议只是单一目的，比如收集看法、讨论做某件事物的价值等等，我们可以根据会议的目的来只使用某一顶帽子就能够解决问题了。</p><p><img src="/images/blog/the-six-thinking-hasts/one-hast.png" alt="使用单一帽子"></p><h2 id="组合使用帽子"><a href="#组合使用帽子" class="headerlink" title="组合使用帽子"></a>组合使用帽子</h2><p>一般来说，我们大部分的会议都不是只用单一帽子就能够达到目的的，那么我们就要尝试组合使用帽子的方式来进行会议的讨论和决策。</p><p><img src="/images/blog/the-six-thinking-hasts/combination-hasts.png" alt="组合使用帽子"></p><p>不过，要注意的是，<strong>六顶思考帽方法可能需要一定的训练与磨合才能发挥出它的真正效果。</strong></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>比如我就在前几天的项目Review的会议上使用了六个帽子来组织了一下这个会议。</p><ol><li>先让团队的每个人都在两张便签纸上分别写出，在本次项目中自己觉得“最爽”和“最不爽”的三点，写完后贴在白板上。 <strong>（黑色帽子 + 黄色帽子）</strong></li><li>每个人陈述自己觉得爽和不爽的原因，并举例子说明。<strong>（红色帽子）</strong></li><li>大家一起对所有人的“最爽”和“最不爽”进行归类，并且对归类后的条目进行计票。 <strong>（蓝色帽子）</strong></li><li>大家一起分析“最不爽”的现状。<strong>（白色帽子）</strong></li><li>每个人提出对“最不爽”的改进意见。 <strong>（绿色帽子）</strong></li><li>大家从改进意见中找出最可能执行成功的方案。 <strong>（蓝色帽子）</strong></li></ol><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>OK，这篇Blog也断断续续抽空的写了好几天，关于<strong>会议</strong>、<strong>效率</strong>以及<strong>六顶思考帽</strong>这些都是非常大的话题，并不是一篇短短的Blog能够描述清楚的。只是对于我来说，作为一个自己对这些事情和内容的思考和总结，同时希望能够对看到这篇Blog的人也有帮助。</p><p>另外，再说一点多余的话，虽然与这篇Blog主题关系不太大，不过，也是我为什么之前在项目Review会议中使用“六顶思考帽”的方式来组织会议的原因之一，先随便说说，要是哪天心血来潮，自己再刨个坑，一篇详细点的Blog在仔细说说。</p><p>现实中，作为团队管理者的我们有一项不容忽视的问题，就是团队建设（不仅仅是吃饭）。</p><p>比如我们要在团队内推行一个新的制度或方法。如果，硬性地作为团队的大方法论强制实施，或许能加快该制度或方法的推广速度。但是我认为，任何出自<strong>非团队意识</strong>的<strong>强迫</strong>的活动，都会让团队感觉到“他们在领导眼里不能自理，需要‘学生手册’来约束自己”，这无疑会打消团队的积极性。</p><p>团队成员可能以一种，沉默不抵抗的方式应对让他们头疼的流程。</p><p>因此，我建议，要么征求团队意见，集体达成一致；要么就作为你自己的思考方式，在团队中隐晦地加以利用。</p><p>就好比，我在项目Review会议上用的方法，所有的人都参与到整个改进方案的建设中，这样大家就更容易接受这些方案。你再后续的推行这些改进方案整个团队就更加容易接受了。</p><p>好了，不写了，洗洗睡觉去了。</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> management </tag>
            
            <tag> thinking </tag>
            
            <tag> the six thinking hasts </tag>
            
            <tag> 六顶思考帽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于用户体验的讨论和思考</title>
      <link href="2015/10/21/discussion-on-user-experience/"/>
      <url>2015/10/21/discussion-on-user-experience/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/user-experience/user-experience.png" alt="user experience"></p><p>昨天晚上媳妇跟我说，他们的产品负（jiao）责（shi）人（gun）说”交互设计就是UI，产品界面上什么按钮该放哪儿，页面该怎么跳转，这些都是<strong>用户体验</strong>“，转达了他们产品负责人的话之后，媳妇继续问：“我觉得她说的不对，我认为用户体验是UI（界面设计）+UE（交互设计）。”</p><p>媳妇的这个问题让我陷入了思考，现在互联网从业人员都在谈“用户体验”，包括传统行业的从业人员也在谈“互联网思维”，也谈“用户体验”。<strong>那么用户体验到底是一个什么东西？是否就是UI+UE？</strong>，也让我有了写这篇Blog的冲动。</p><a id="more"></a><h2 id="什么是用户体验"><a href="#什么是用户体验" class="headerlink" title="什么是用户体验"></a>什么是用户体验</h2><p>简略来说，用户体验是一种在用户<strong>使用</strong>一个产品（服务）的<strong>过程</strong>中建立起来的<strong>纯主观</strong>的<strong>心理感受</strong>。</p><p>而从系统上讲，用户体验是一个<strong>全方位的概念</strong>，在产品的<strong>不同阶段</strong>，<strong>不同渠道</strong>，每一个可能和产品、服务，以及企业本身<strong>接触的地方都能产生用户体验</strong>。</p><p>互联网产品的用户体验比其他任何产品都重要。因为它是一个“自助式”的产品，没有事先阅读的说明书，没有任何操作培训或讨论会，也没有客户服务代表来帮助用户了解这个产品如何使用。</p><p>不过，现在很多互联网公司也主要到了原来互联网产品在这块的问题，现在很多APP都添加了很多用户使用引导的功能，相信大家也都体会过，对自己实际使用这个产品的帮助并不是那么大，更多使用方式的都是靠自己摸索。</p><h2 id="影响用户体验的因素"><a href="#影响用户体验的因素" class="headerlink" title="影响用户体验的因素"></a>影响用户体验的因素</h2><p>我们来看看一张网络上的老图。</p><p><img src="/images/blog/user-experience/more-information.jpg" alt="more infomation"></p><p>虽然只是讲了建设一个网站的工作并不像表面看起来的那么简单，但是就像我们上面描述的那样，用户主观的心理感受不是仅仅只是表面的工作能够满足到的。所以，用户体验当然不仅仅是“UI+UE”。</p><p>有许多因素可以影响用户时间使用的体验，用户的个体差异也决定了每个用户的真实感受/体验是无法通过有效途径来完全模拟或再现的。不过，对于一个界定明确的用户群体来讲，其用户体验的共性是能够通过良好设计的测试/实验来认识到的。</p><p>我们来看相对全面的用户体验所涉及的领域：</p><p><img src="/images/blog/user-experience/user-experience-in-the-areas-of.jpg" alt="用户体验涉及的领域"></p><p>所以，谈到用户体验，作为提供产品（服务）的组织来说，其实涉及到该组织内每一个成员的贡献。</p><p>就拿互联网企业来说，产品功能设计（产品经理）、用户界面设计（UI）、用户交互设计（UE）、产品内容（运营、商务、BD）、产品稳定性和响应速度（技术）等方面对用户的体验都是有影响的。大家想一想看看是不是这样？</p><p>说到底，“用户体验”就是一切以用户为中心。国外有一句经典商业名言：“客户就是上帝”，古代的中国商人也用“衣食父母”来比喻客户对商家的重要性（虽然，最早的出处是关汉卿在《<a href="http://baike.baidu.com/subview/13964/5887709.htm" target="_blank" rel="noopener">窦娥冤</a>》中由昏官桃杌太守之口说出）。</p><p>所以，作为我们每一个互联网从业人员来说，用户体验应该是我们始终在脑海中绷紧的一根弦，并且要在实际工作付诸行动的行为准则之一（并不是喊喊口号而已，也不是某些人掩饰自己能力不足的借口）。在产品开发的每一个步骤中，都要把用户体验列入到考虑范围中。</p><h2 id="用户体验的要素"><a href="#用户体验的要素" class="headerlink" title="用户体验的要素"></a>用户体验的要素</h2><p>那什么样的用户体验才算是好呢？如何来验证呢？</p><p>其实，在2000年3月（15年前）就有人总结出了用户体验的要素。</p><p>我们来看看<a href="http://www.amazon.com/o/ASIN/0735712026/ref=nosim/jjgnet-20/" target="_blank" rel="noopener">《用户体验的要素》</a>的作者<a href="http://blog.jjg.net/" target="_blank" rel="noopener">Jesse James Garrett</a>是怎么来说的。</p><p><img src="/images/blog/user-experience/the-elements-of-user-expexrience-en.jpg" alt="用户体验的要素"></p><p>这张图是国人翻译的</p><p><img src="/images/blog/user-experience/the-elements-of-user-expexrience-zh.jpg" alt="用户体验的要素"></p><h2 id="附录：Jesse-James-Garrett关于用户体验要素的演讲"><a href="#附录：Jesse-James-Garrett关于用户体验要素的演讲" class="headerlink" title="附录：Jesse James Garrett关于用户体验要素的演讲"></a>附录：Jesse James Garrett关于用户体验要素的演讲</h2><p>我们来看看Jesse James Garrett再Adaptive path工作坊上的演讲《用户体验的要素》，这个PPT非常精彩，覆盖了整个团队内部分工、产品设计要素以及项目管理要点等各个方面，非常值得大家去仔细揣摩。</p><h3 id="用户体验的要素-1"><a href="#用户体验的要素-1" class="headerlink" title="用户体验的要素"></a>用户体验的要素</h3><p><img src="/images/blog/user-experience/ppt/00.png" alt="00"></p><h3 id="认识用户体验的要素"><a href="#认识用户体验的要素" class="headerlink" title="认识用户体验的要素"></a>认识用户体验的要素</h3><p><img src="/images/blog/user-experience/ppt/01.png" alt="01"></p><h3 id="史上最差的一些电影"><a href="#史上最差的一些电影" class="headerlink" title="史上最差的一些电影"></a>史上最差的一些电影</h3><p><img src="/images/blog/user-experience/ppt/02.png" alt="02"></p><h3 id="究竟谁应该受到指责呢？"><a href="#究竟谁应该受到指责呢？" class="headerlink" title="究竟谁应该受到指责呢？"></a>究竟谁应该受到指责呢？</h3><ul><li>用户可能会说：“我可能没有好好选择？”，“我一定是没有好好看说明书”，“或许我不够聪明”….</li><li>对于不优的产品，用户承担了不必要的责罚。</li></ul><p><img src="/images/blog/user-experience/ppt/03.png" alt="03"></p><h3 id="如果把产品也看做是人"><a href="#如果把产品也看做是人" class="headerlink" title="如果把产品也看做是人"></a>如果把产品也看做是人</h3><p><img src="/images/blog/user-experience/ppt/04.png" alt="04"></p><h3 id="以用户为中心的设计"><a href="#以用户为中心的设计" class="headerlink" title="以用户为中心的设计"></a>以用户为中心的设计</h3><ul><li>这是产品开发必须遵循的理念和态度</li><li>产品自身不是结束</li><li>产品是为了最终能提供满足用户优良的交互体验而生的一种手段</li><li>它是强调理解用户而不是技术的理论体系</li></ul><p><img src="/images/blog/user-experience/ppt/05.png" alt="05"></p><h3 id="用户体验关注什么？"><a href="#用户体验关注什么？" class="headerlink" title="用户体验关注什么？"></a>用户体验关注什么？</h3><ul><li>一个产品的行为是怎样的，在实际生活中如何应用</li><li>超越产品自身，关注它与人们生活的联结</li><li>它包含各个范畴的因素</li></ul><p><img src="/images/blog/user-experience/ppt/06.png" alt="06"></p><h3 id="外观层"><a href="#外观层" class="headerlink" title="外观层"></a>外观层</h3><p><img src="/images/blog/user-experience/ppt/07.png" alt="07"></p><h3 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h3><p><img src="/images/blog/user-experience/ppt/08.png" alt="08"></p><h3 id="结构层"><a href="#结构层" class="headerlink" title="结构层"></a>结构层</h3><p><img src="/images/blog/user-experience/ppt/09.png" alt="09"></p><h3 id="范围层"><a href="#范围层" class="headerlink" title="范围层"></a>范围层</h3><p><img src="/images/blog/user-experience/ppt/10.png" alt="10"></p><h3 id="战略层"><a href="#战略层" class="headerlink" title="战略层"></a>战略层</h3><p><img src="/images/blog/user-experience/ppt/11.png" alt="11"></p><h3 id="用户体验要素的五大层级"><a href="#用户体验要素的五大层级" class="headerlink" title="用户体验要素的五大层级"></a>用户体验要素的五大层级</h3><p><img src="/images/blog/user-experience/ppt/12.png" alt="12"></p><h3 id="扫除一些名词障碍"><a href="#扫除一些名词障碍" class="headerlink" title="扫除一些名词障碍"></a>扫除一些名词障碍</h3><p>信息设计、功能说明、交互设计、信息架构、界面设计、内容需求、导航设计</p><p><img src="/images/blog/user-experience/ppt/13.png" alt="13"></p><h3 id="网站的二元性：作为信息源的网站"><a href="#网站的二元性：作为信息源的网站" class="headerlink" title="网站的二元性：作为信息源的网站"></a>网站的二元性：作为信息源的网站</h3><p><img src="/images/blog/user-experience/ppt/14.png" alt="14"></p><h3 id="网站的二元性：作为软件应用的网站"><a href="#网站的二元性：作为软件应用的网站" class="headerlink" title="网站的二元性：作为软件应用的网站"></a>网站的二元性：作为软件应用的网站</h3><p><img src="/images/blog/user-experience/ppt/15.png" alt="15"></p><h3 id="网站基本的二元性"><a href="#网站基本的二元性" class="headerlink" title="网站基本的二元性"></a>网站基本的二元性</h3><p><img src="/images/blog/user-experience/ppt/16.png" alt="16"></p><p><img src="/images/blog/user-experience/ppt/17.png" alt="17"></p><h3 id="战略层-1"><a href="#战略层-1" class="headerlink" title="战略层"></a>战略层</h3><ul><li>用户需求：网站必须为使用它的人提供些什么</li><li>网站目的：网站必须为建立它的人做些什么</li></ul><p><img src="/images/blog/user-experience/ppt/18.png" alt="18"></p><h3 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h3><ul><li>一些基本原则——用户使用产品必须能够：<ul><li>工作</li><li>可操作使用</li><li>达到一些期望</li></ul></li><li>但是大部分时候需要根据实际使用对象和产品具体分析</li></ul><p><img src="/images/blog/user-experience/ppt/19.png" alt="19"></p><h3 id="用户调研"><a href="#用户调研" class="headerlink" title="用户调研"></a>用户调研</h3><ul><li>这是最好的方式来了解用户实际需求</li><li>很多方式方法：从快速、廉价到长期、昂贵的都有</li><li>推荐一本好书《Observing the User Experience》</li></ul><p><img src="/images/blog/user-experience/ppt/20.png" alt="20"></p><h3 id="用户细分"><a href="#用户细分" class="headerlink" title="用户细分"></a>用户细分</h3><ul><li>可以控制地识别用户需求</li><li>通过用户共性特征分类</li></ul><p><img src="/images/blog/user-experience/ppt/21.png" alt="21"></p><h3 id="用户模型"><a href="#用户模型" class="headerlink" title="用户模型"></a>用户模型</h3><ul><li>以用户调研为基础的特征描述</li><li>从一系列常规特征推论到具体事件</li></ul><p><img src="/images/blog/user-experience/ppt/22.png" alt="22"></p><h3 id="网站目的"><a href="#网站目的" class="headerlink" title="网站目的"></a>网站目的</h3><ul><li>经常与商业性有关</li><li>商业目的</li><li>商业驱动</li><li>商业需求</li><li>需要具体问题具体分析</li><li>独立于组织结构的其他行为</li></ul><p><img src="/images/blog/user-experience/ppt/23.png" alt="23"></p><h3 id="成功的度量流量"><a href="#成功的度量流量" class="headerlink" title="成功的度量流量"></a>成功的度量流量</h3><ul><li>唯一的方法用来获知改变网站设计有何不同</li><li>紧密地与站点目标连接</li><li>未来将会更广泛应用</li></ul><p><img src="/images/blog/user-experience/ppt/24.png" alt="24"></p><h3 id="范围层-1"><a href="#范围层-1" class="headerlink" title="范围层"></a>范围层</h3><ul><li>功能说明：网站应有的应用特色</li><li>内容需求：网站必须包含的基本内容</li></ul><p><img src="/images/blog/user-experience/ppt/25.png" alt="25"></p><h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><ul><li>什么样的特色应用是用户需要用来完成目标的？</li><li>聚焦在“它该做什么”<ul><li>而不是“它怎么工作”</li><li>也不是“它什么不能做”</li></ul></li><li>具体一些，但不要指使系统设计</li></ul><p><img src="/images/blog/user-experience/ppt/26.png" alt="26"></p><h3 id="内容需求"><a href="#内容需求" class="headerlink" title="内容需求"></a>内容需求</h3><ul><li>什么样的信息是用户需要的或想从网站获取的</li><li>它采用何种形式</li><li>它的来源是哪里</li><li>谁来负责？</li><li>根据目的定义要点</li></ul><p><img src="/images/blog/user-experience/ppt/27.png" alt="27"></p><h3 id="跟进文档"><a href="#跟进文档" class="headerlink" title="跟进文档"></a>跟进文档</h3><ul><li>文档是在浪费时间？<ul><li>没人看</li><li>它们从来不是最新的</li><li>维护起来很麻烦</li></ul></li><li>花在规划网站的时间是为制作网站的时候节约时间</li><li>把文档融进进程，而不是作为一个独立的步骤</li></ul><p><img src="/images/blog/user-experience/ppt/28.png" alt="28"></p><h3 id="结构层-1"><a href="#结构层-1" class="headerlink" title="结构层"></a>结构层</h3><ul><li>交互设计：用户如何在过程中从一步移到另一步</li><li>信息架构：用户如何从一个内容要素移到下一个</li></ul><p><img src="/images/blog/user-experience/ppt/29.png" alt="29"></p><h3 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h3><ul><li>交互行为<ul><li>一方面用户能够使用系统</li><li>另一方面系统能够反馈给用户信息</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/30.png" alt="30"></p><h3 id="信息架构"><a href="#信息架构" class="headerlink" title="信息架构"></a>信息架构</h3><ul><li>明确各内容要素间的概念关系</li><li>影响用户思考主题</li><li>常常是等级式的，但也不是一定的</li></ul><p><img src="/images/blog/user-experience/ppt/31.png" alt="31"></p><h3 id="自上而下-VS-自下而上"><a href="#自上而下-VS-自下而上" class="headerlink" title="自上而下 VS 自下而上"></a>自上而下 VS 自下而上</h3><ul><li>自上而下以分类开始，再对内容进行归类</li></ul><p><img src="/images/blog/user-experience/ppt/32.png" alt="32"></p><h3 id="自上而下-VS-自下而上-1"><a href="#自上而下-VS-自下而上-1" class="headerlink" title="自上而下 VS 自下而上"></a>自上而下 VS 自下而上</h3><ul><li>自下而上以内容开始，最后集结成几类</li></ul><p><img src="/images/blog/user-experience/ppt/33.png" alt="33"></p><h3 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h3><ul><li>可视化的表达更有效</li><li>根据需要，图表可繁可简</li><li>更多说明欢迎访问以下网址</li></ul><p><img src="/images/blog/user-experience/ppt/34.png" alt="34"></p><h3 id="框架层-1"><a href="#框架层-1" class="headerlink" title="框架层"></a>框架层</h3><ul><li>信息设计：帮助用户理解信息</li><li>界面设计：帮助用户输入，促进系统输出</li><li>导航设计：为用户提供更轻松便捷的移动操作</li></ul><p><img src="/images/blog/user-experience/ppt/35.png" alt="35"></p><h3 id="信息设计"><a href="#信息设计" class="headerlink" title="信息设计"></a>信息设计</h3><ul><li>我们如何表达信息使得人们理解并使用它</li><li>从不同信息中传达出相对重要的信息</li><li>引导用户从一条信息到另一条</li><li>提醒重要细节</li><li>传达各元素联系</li></ul><p><img src="/images/blog/user-experience/ppt/36.png" alt="36"></p><h3 id="Google-Maps的例子"><a href="#Google-Maps的例子" class="headerlink" title="Google Maps的例子"></a>Google Maps的例子</h3><p><img src="/images/blog/user-experience/ppt/37.png" alt="37"></p><h3 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h3><ul><li>为用户提供与应用程序功能交互的一种可视化方式</li></ul><p><img src="/images/blog/user-experience/ppt/38.png" alt="38"></p><h3 id="导航设计"><a href="#导航设计" class="headerlink" title="导航设计"></a>导航设计</h3><ul><li>表达出用户可以有哪些选择</li><li>使用户移动操作更便利</li><li>不同的设计有不同的效果</li></ul><p><img src="/images/blog/user-experience/ppt/39.png" alt="39"></p><h3 id="线框图"><a href="#线框图" class="headerlink" title="线框图"></a>线框图</h3><ul><li>将所有框架议题放到一个高度概括的“草图”里</li><li>图示表达页面元素相对优先级</li><li>建议页面布局的方式</li></ul><p><img src="/images/blog/user-experience/ppt/40.png" alt="40"></p><h3 id="外观层-1"><a href="#外观层-1" class="headerlink" title="外观层"></a>外观层</h3><ul><li>视觉设计：“外观和感觉”中的“外观”</li><li>经常会有部分人认为你在说“网页设计”</li><li>不仅是美学范畴</li></ul><p><img src="/images/blog/user-experience/ppt/41.png" alt="41"></p><h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p><img src="/images/blog/user-experience/ppt/42.png" alt="42"></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><img src="/images/blog/user-experience/ppt/43.png" alt="43"></p><h3 id="用户体验的要素-2"><a href="#用户体验的要素-2" class="headerlink" title="用户体验的要素"></a>用户体验的要素</h3><p><img src="/images/blog/user-experience/ppt/44.png" alt="44"></p><h3 id="要素的应用举例"><a href="#要素的应用举例" class="headerlink" title="要素的应用举例"></a>要素的应用举例</h3><p><img src="/images/blog/user-experience/ppt/45.png" alt="45"></p><h3 id="以搜索引擎为例"><a href="#以搜索引擎为例" class="headerlink" title="以搜索引擎为例"></a>以搜索引擎为例</h3><ul><li>几乎所有的网站都有</li><li>每个网站的方式都有差别</li></ul><p><img src="/images/blog/user-experience/ppt/46.png" alt="46"></p><h3 id="战略层-2"><a href="#战略层-2" class="headerlink" title="战略层"></a>战略层</h3><ul><li>用户需求<ul><li>用户需要搜索引擎吗？</li><li>是否限制了那些需要搜索功能的用户的需求？</li></ul></li><li>网站目的<ul><li>使用可操作搜索可以获取我们提供的信息么？</li><li>是否可操作搜索限制了网站所需要达成的目标？</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/47.png" alt="47"></p><h3 id="范围层-2"><a href="#范围层-2" class="headerlink" title="范围层"></a>范围层</h3><ul><li>产品功能说明书<ul><li>关键词输入</li><li>其他领域的特殊标准</li><li>缩小搜索结果范围的能力</li></ul></li><li>内容需求<ul><li>标记</li><li>结果数据</li><li>帮助文档</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/48.png" alt="48"></p><h3 id="结构层-2"><a href="#结构层-2" class="headerlink" title="结构层"></a>结构层</h3><ul><li>交互设计<ul><li>用户每一步可做的选择</li><li>多控制下的系统行为</li></ul></li><li>信息架构<ul><li>作为搜索标准的构架范围</li><li>元数据结构</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/49.png" alt="49"></p><h3 id="框架层-2"><a href="#框架层-2" class="headerlink" title="框架层"></a>框架层</h3><ul><li>信息设计<ul><li>搜索结果的布局</li><li>错误状态的表达</li></ul></li><li>界面设计<ul><li>用户输入的途径</li></ul></li><li>导航设计<ul><li>进入界面流和离开界面流</li><li>通过搜索结果移动浏览</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/50.png" alt="50"></p><h3 id="外观层-2"><a href="#外观层-2" class="headerlink" title="外观层"></a>外观层</h3><ul><li>视觉设计<ul><li>颜色</li><li>字体样式</li><li>布局</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/51.png" alt="51"></p><h3 id="提出正确的问题"><a href="#提出正确的问题" class="headerlink" title="提出正确的问题"></a>提出正确的问题</h3><ul><li>我们尝试解决哪些问题</li><li>我们针对问题提出哪些解决方法会导致什么样的结果？</li><li>解决办法是否促使我们重新思考其他问题？</li></ul><p><img src="/images/blog/user-experience/ppt/52.png" alt="52"></p><h3 id="马拉松和短距离冲刺"><a href="#马拉松和短距离冲刺" class="headerlink" title="马拉松和短距离冲刺"></a>马拉松和短距离冲刺</h3><ul><li>冲刺是短期竞速<ul><li>快速开始</li><li>尽快燃烧能量</li></ul></li><li>马拉松是长期赛跑<ul><li>自己控制速度</li><li>选择何时燃烧能量</li></ul></li><li>你打算尝试那种运动？</li><li>哪种运动你正在做？</li></ul><p><img src="/images/blog/user-experience/ppt/53.png" alt="53"></p><h3 id="回答出反对的理由"><a href="#回答出反对的理由" class="headerlink" title="回答出反对的理由"></a>回答出反对的理由</h3><ul><li>“市场调研可以告诉我们所有关于用户的事”<ul><li>人口数据可不是用户深入研究</li></ul></li><li>“我们就遵照网上找来的指导挨个来做”<ul><li>网上找的资料必定很普遍</li></ul></li><li>“界面是简单的——技术是复杂的”<ul><li>什么更复杂：机器还是人</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/54.png" alt="54"></p><h3 id="回答出反对的理由-1"><a href="#回答出反对的理由-1" class="headerlink" title="回答出反对的理由"></a>回答出反对的理由</h3><ul><li>“我们雇不起专家”<ul><li>任何事你都不需要专家</li></ul></li><li>“我们做的时候再弄明白”<ul><li>爵士乐可以即兴创作，设计可不行</li></ul></li><li>“我们做质量评估的时候再处理”<ul><li>那时候就晚了</li></ul></li><li>“时间表上没时间了”<ul><li>下次发布的时候节约时间吧</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/55.png" alt="55"></p><h3 id="该避免犯的错误"><a href="#该避免犯的错误" class="headerlink" title="该避免犯的错误"></a>该避免犯的错误</h3><ul><li><strong>弃权式设计：</strong>“我们应该做哪些容易完成的事”</li><li><strong>模仿式设计：</strong>“如果这对亚马逊网是足够好的，对我们也是”</li><li><strong>命令式设计：</strong>“因为我说过”</li></ul><p><img src="/images/blog/user-experience/ppt/56.png" alt="56"></p><h3 id="瀑布式是危险的"><a href="#瀑布式是危险的" class="headerlink" title="瀑布式是危险的"></a>瀑布式是危险的</h3><p><img src="/images/blog/user-experience/ppt/57.png" alt="57"></p><h3 id="迭代式发展"><a href="#迭代式发展" class="headerlink" title="迭代式发展"></a>迭代式发展</h3><ul><li>网站更新不会停止</li><li>做你现在要做的</li><li>总是前瞻性地计划下次发布</li></ul><p><img src="/images/blog/user-experience/ppt/58.png" alt="58"></p><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><ul><li>具体你选的哪项职责无关紧要——只要你把所有板块都覆盖住</li></ul><p><img src="/images/blog/user-experience/ppt/59.png" alt="59"></p><h3 id="九大支柱"><a href="#九大支柱" class="headerlink" title="九大支柱"></a>九大支柱</h3><ul><li>常见成功团队的核心能力</li><li>影响团队的：<ul><li>职责</li><li>进程</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/60.png" alt="60"></p><h3 id="用户调研-1"><a href="#用户调研-1" class="headerlink" title="用户调研"></a>用户调研</h3><ul><li>以用户为中心设计的基础</li><li>告知所有的战略决定</li><li>基本职责是认识用户需求</li><li>头衔：<ul><li>用户调研员</li><li>可用性分析师</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/61.png" alt="61"></p><h3 id="站点战略"><a href="#站点战略" class="headerlink" title="站点战略"></a>站点战略</h3><ul><li>基本职责是定义站点目的</li><li>决定优先级和成功的度量法</li><li>头衔：<ul><li>商业分析师</li><li>产品经理</li><li>执行监制</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/62.png" alt="62"></p><h3 id="技术战略"><a href="#技术战略" class="headerlink" title="技术战略"></a>技术战略</h3><ul><li>主要负责功能说明书</li><li>决定技术平台和采用标准</li><li>头衔：<ul><li>高级工程师</li><li>开发主管</li><li>技术领头人</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/63.png" alt="63"></p><h3 id="内容战略"><a href="#内容战略" class="headerlink" title="内容战略"></a>内容战略</h3><ul><li>主要负责内容需求</li><li>决定合适的版式和主题</li><li>头衔：<ul><li>内容策划人</li><li>内容编辑</li><li>主编</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/64.png" alt="64"></p><h3 id="抽象设计"><a href="#抽象设计" class="headerlink" title="抽象设计"></a>抽象设计</h3><ul><li>把战略转向设计概念</li><li>主要负责结构层</li><li>有时负责范围和框架层</li><li>头衔：<ul><li>信息架构师</li><li>交互设计师</li><li>界面专家</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/65.png" alt="65"></p><h3 id="技术执行"><a href="#技术执行" class="headerlink" title="技术执行"></a>技术执行</h3><ul><li>有策略地执行技术战略</li><li>可能要组合很多职能：从编码到整合到测试</li><li>头衔：<ul><li>软件工程师</li><li>HTML开发者</li><li>QA测试员</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/66.png" alt="66"></p><h3 id="内容制作"><a href="#内容制作" class="headerlink" title="内容制作"></a>内容制作</h3><ul><li>有策略地执行内容战略</li><li>搜集，编辑，生产和部署内容（不仅是文本）</li><li>头衔：<ul><li>内容制作人</li><li>作者</li><li>编辑</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/67.png" alt="67"></p><h3 id="视觉设计"><a href="#视觉设计" class="headerlink" title="视觉设计"></a>视觉设计</h3><ul><li>有策略地实现抽象设计</li><li>主要负责外观层</li><li>有时负责框架和结构层</li><li>头衔：<ul><li>界面设计师</li><li>视觉设计师</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/68.png" alt="68"></p><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><ul><li>将所有策略能力绑定</li><li>在小型组织里常常忽略</li><li>头衔：<ul><li>制作人</li><li>项目管理</li></ul></li></ul><p><img src="/images/blog/user-experience/ppt/69.png" alt="69"></p><h3 id="九大支柱-1"><a href="#九大支柱-1" class="headerlink" title="九大支柱"></a>九大支柱</h3><ul><li>不是一个九人小组</li><li>也不是一个九项步骤的过程</li><li>应该正确结合两者并深入进去研究</li></ul><p><img src="/images/blog/user-experience/ppt/70.png" alt="70">　</p><h3 id="以上这些都是关于什么呢？"><a href="#以上这些都是关于什么呢？" class="headerlink" title="以上这些都是关于什么呢？"></a>以上这些都是关于什么呢？</h3><ul><li>开发前要做计划</li><li>对于你所有选择要有清晰的理由</li><li>清楚明确地表达</li><li>做人们喜爱的东西</li></ul><p><img src="/images/blog/user-experience/ppt/71.png" alt="71">　　　</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p><img src="/images/blog/user-experience/ppt/72.png" alt="72">　</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://cuikai-wh.com/about" target="_blank" rel="noopener">@小轰同学</a>-<a href="http://cuikai-wh.com/wp-content/uploads/2011/01/elements-of-ue-v1.png" target="_blank" rel="noopener">用户体验的要素-1.0版思维导图整合版本</a></p><p><a href="http://www.adaptivepath.com/events/workshops/businessofux/elements0803.pdf" target="_blank" rel="noopener">Jesse James Garrett在adaptive path的演讲 – 用户体验的要素</a></p><p><a href="http://www.jjg.net/ia/visvocab/chinese.html" target="_blank" rel="noopener">描绘信息架构和交换设计的图示词汇表</a></p><p><a href="http://www.jjg.net/elements/pdf/elements.pdf" target="_blank" rel="noopener">The Elements of User Experience</a></p><p><a href="http://ww3.sinaimg.cn/large/64945e3dtw1djew0x37yng.gif" target="_blank" rel="noopener">产品设计-概念图</a></p><p><a href="http://ww3.sinaimg.cn/large/6694d7c8jw1duyly18i1mg.gif" target="_blank" rel="noopener">如何留住你的用户？设计你的用户体验流</a></p>]]></content>
      
      
      <categories>
          
          <category> 产品设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> product </tag>
            
            <tag> thinking </tag>
            
            <tag> user experience </tag>
            
            <tag> UE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8环境下的Maven javadoc插件的配置</title>
      <link href="2015/10/21/maven-Javadoc-plugin-in-java8-exception-resolution/"/>
      <url>2015/10/21/maven-Javadoc-plugin-in-java8-exception-resolution/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天用maven在release代码时，又出现新的问题了，生成javadoc出现异常，导致release失败。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Refer to the generated Javadoc files <span class="keyword">in</span> <span class="string">'./target/site/apidocs'</span> dir.</span><br><span class="line"></span><br><span class="line">org.apache.maven.reporting.MavenReportException:</span><br><span class="line">Exit code: 1 -./src/main/java/com/github/tonydeng/commons/utils/DigestUtils.java:30: 警告: input没有 @param</span><br><span class="line">public static String sha1ToHex(String input) &#123;</span><br><span class="line">                     ^</span><br><span class="line">./src/main/java/com/github/tonydeng/commons/utils/DigestUtils.java:30: 警告: 没有 @<span class="built_in">return</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>javadoc的插件配置是这样</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>之前这个配置工作都很正常，让我百思不得其解。</p><p>那怎么办？</p><p>嗯，先升级一下maven-javadoc-plugin看看，升级到最新的2.10.3。</p><p>还是不行，回退java版本到java7。</p><p>哦，这样就可以了。看来应该是java8加了对javadoc的新的特性，我没有关注到。</p><p>OK，找到线索了，那就查查看。</p><p>先看看<a href="http://openjdk.java.net/projects/jdk8/features" target="_blank" rel="noopener">Java8的特性列表</a>吧。果然，Java8添加了一个Javadoc注释内容检查的特性<a href="http://openjdk.java.net/jeps/172" target="_blank" rel="noopener">DocLint</a>。</p><p>DocLint提供了一种方法来检测Javadoc的注释中的错误，希望能够在开发周期的早期和容易链接回源代码的方式。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>如果想忽略DocLint的使用，可以在maven-javadoc-plugin的配置中加上对DocLint的忽略。</p><p>最后的配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">additionalOptions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">additionalOption</span>&gt;</span>-Xdoclint:none<span class="tag">&lt;/<span class="name">additionalOption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">additionalOptions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
            <tag> java8 </tag>
            
            <tag> DocLint </tag>
            
            <tag> javadoc </tag>
            
            <tag> javadoc-plugin </tag>
            
            <tag> maven-plugin </tag>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git中文件名大小写引起的错误处理</title>
      <link href="2015/10/21/capitalization-error-handing-in-git/"/>
      <url>2015/10/21/capitalization-error-handing-in-git/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/git-branching.png" alt="git branching"></p><p>在团队使用Git的时候，尤其是多人合作的项目，经常会出现一个问题，就是由于同一个文件名大小写不一致导致无法合并的问题。</p><p>那我们应该怎么来解决呢?</p><a id="more"></a><p>可以使用git rm –cached将冲突的文件从Git仓库的缓存中删除，然后改名后再加入到git中</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">mv &lt;old_filename&gt; &lt;<span class="keyword">new</span><span class="type">_filename</span>&gt;</span><br><span class="line"></span><br><span class="line">git add &lt;<span class="keyword">new</span><span class="type">_filename</span>&gt;</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'rename &lt;new_filename&gt;'</span> &lt;<span class="keyword">new</span><span class="type">_filename</span>&gt;</span><br></pre></td></tr></table></figure><p>当然，为了一劳永逸，我们可以让团队成员都更改配置git的大小写敏感，避免某些windows用户继续制造这样的问题。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git<span class="built_in"> config </span>core.ignorecase <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ETCD应用场景</title>
      <link href="2015/10/19/etcd-application-scenarios/"/>
      <url>2015/10/19/etcd-application-scenarios/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/etcd/etcd2-0.png" alt="etcd logo"></p><h1 id="etcd是什么？"><a href="#etcd是什么？" class="headerlink" title="etcd是什么？"></a>etcd是什么？</h1><p>很多人对这个问题的第一反应可能是，它是一个键值存储仓库，却没有重视官方定义的后半句，用于<strong>配置共享</strong>和<strong>服务发现</strong>。</p><blockquote><p>A highly-available key value store for shared configuration and service discovery.</p></blockquote><p>实际上，etcd作为一个受到Zookeeper和doozer启发而催生的项目，除了拥有与之类似的功能外，更具有以下4个特点。（<a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">引自etcd官方文档</a>）</p><ul><li>简单： 基于HTTP+JSON的API让你可以用CURL命令就可以轻松使用。</li><li>安全： 可以选择SSL客户认证机制。</li><li>快速： 每个实例每秒支持一千次写操作。</li><li>可信： 使用<a href="http://raftconsensus.github.io/" target="_blank" rel="noopener">Ralf</a>算法充分实现了分布式。</li></ul><a id="more"></a><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="场景一：-服务发现"><a href="#场景一：-服务发现" class="headerlink" title="场景一： 服务发现"></a>场景一： 服务发现</h2><p>服务发现（Service Discovery）要解决的是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务如何才能找到对方并建立连接。</p><p>从本质上说，服务发现就是要了解集群中是否有进程在监听upd或者tcp端口，并且通过名字就可以进行查找和链接。</p><p>要解决服务发现的问题，需要下面三大支柱，缺一不可。</p><ul><li>一个强一致性、高可用的服务存储目录。<ul><li> 基于Ralf算法的etcd天生就是这样一个强一致性、高可用的服务存储目录。</li></ul></li><li>一种注册服务和健康服务健康状况的机制。<ul><li>用户可以在etcd中注册服务，并且对注册的服务配置<code>key TTL</code>，定时保持服务的心跳以达到监控健康状态的效果。</li></ul></li><li>一种查找和连接服务的机制。<ul><li>通过在etcd指定的主题下注册的服务业能在对应的主题下查找到。</li><li>为了确保连接，我们可以在每个服务机器上都部署一个proxy模式的etcd，这样就可以确保访问etcd集群的服务都能够互相连接。</li></ul></li></ul><p><img src="/images/blog/etcd/service-discovery.jpg" alt="服务发现"></p><p>下面我们来看一下服务发现的具体应用场景</p><h3 id="微服务协同工作架构中，服务动态添加。"><a href="#微服务协同工作架构中，服务动态添加。" class="headerlink" title="微服务协同工作架构中，服务动态添加。"></a>微服务协同工作架构中，服务动态添加。</h3><p>随着Docker容器的流行，多种微服务共同协作，构成一个功能相对强大的架构的案例越来越多。透明化的动态添加这些服务的需求也日益强烈。通过服务发现机制，在etcd中注册某个服务名字的目录，在该目录下存储可用的服务节点的IP。在使用服务的过程中，只要从服务目录下查找可用的服务节点进行使用即可。</p><p>微服务协同工作如下图：</p><p><img src="/images/blog/etcd/micro-services.jpg" alt="微服务"></p><h3 id="PaaS平台中应用多实例与实例故障重启透明化"><a href="#PaaS平台中应用多实例与实例故障重启透明化" class="headerlink" title="PaaS平台中应用多实例与实例故障重启透明化"></a>PaaS平台中应用多实例与实例故障重启透明化</h3><p>PaaS平台中的应用一般都有多个实例，通过域名，不仅可以透明的对多个实例进行访问，而且还可以实现负载均衡。</p><p>但是应用的某个实例随时都有可能故障重启，这时就需要动态的配置域名解析（路由）中的信息。通过etcd的服务发现功能就可以轻松解决这个动态配置的问题。</p><p><img src="/images/blog/etcd/multiple-instances.jpg" alt="多实例透明化"></p><h2 id="场景二：-消息发布和订阅"><a href="#场景二：-消息发布和订阅" class="headerlink" title="场景二： 消息发布和订阅"></a>场景二： 消息发布和订阅</h2><p>在分布式系统中，最为适用的组件间通信的方式是消息发布和订阅机制。</p><p>具体而言，即配置一个配置共享中心，书籍提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦有关主题有消息发布，就会实时通知订阅者。通过这种方式可以实现发布式系统配种的集中式管理和实时动态更新。</p><h3 id="应用中的一些配置新存放在etcd上进行集中管理"><a href="#应用中的一些配置新存放在etcd上进行集中管理" class="headerlink" title="应用中的一些配置新存放在etcd上进行集中管理"></a>应用中的一些配置新存放在etcd上进行集中管理</h3><p>这类场景的使用方式通常是这样的：</p><p>应用在启动的适合主动从etc获取一次配置信息，同时，在etcd节点上注册一个<code>Watcher</code>并等待，以后每次配置有更新的适合，etcd都会实时通知订阅者，以此达到获取最新配置信息的目的。</p><h3 id="分布式日志收集系统"><a href="#分布式日志收集系统" class="headerlink" title="分布式日志收集系统"></a>分布式日志收集系统</h3><p>这个系统的核心工作是收集分布在不同机器上的日志。</p><p>收集器通常按应用（或主题）来分配收集任务单元，因此可以在etcd上创建一个以应用（或主题）名目的目录，并将这个应用（或主题）相关的所有机器IP以子目录的形式存储在目录下。然后设置一个递归的etcd Watcher，递归式的健康应用（或主题）目录下所有信息的变动。这样就实现了在机器IP（消息）发生变动时，能够实时接受收集器调整任务分配。</p><h3 id="系统中心需要动态自动获取与人工干预修改信息请求内容"><a href="#系统中心需要动态自动获取与人工干预修改信息请求内容" class="headerlink" title="系统中心需要动态自动获取与人工干预修改信息请求内容"></a>系统中心需要动态自动获取与人工干预修改信息请求内容</h3><p>通常的解决方案是对外保留接口，例如JMX接口，来获取一些运行时的信息或提交修改的请求。</p><p>而引入etcd后，只需要将这些信息存放在指定的etcd目录中，即可通过http接口直接被外部访问。</p><p><img src="/images/blog/etcd/msg-pub-sub.jpg" alt="消息发布与订阅"></p><h2 id="场景三：-负载均衡"><a href="#场景三：-负载均衡" class="headerlink" title="场景三： 负载均衡"></a>场景三： 负载均衡</h2><p>在<a href="#%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A_%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0">场景一</a>中也提到了负载均衡（即软件负载均衡）。</p><p>在分布式系统中，为了保证服务的高可用以及数据一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。</p><p>这样的实现谁让会导致一定程度上数据写入性能的下降，但是却能够实现数据访问时的负载均衡。因为每个对等服务节点上都存有完整的数据，所有用户的访问流量就可以分流道不同的机器上。</p><h3 id="etcd本身分布式架构存储的信息支持负载均衡"><a href="#etcd本身分布式架构存储的信息支持负载均衡" class="headerlink" title="etcd本身分布式架构存储的信息支持负载均衡"></a>etcd本身分布式架构存储的信息支持负载均衡</h3><p>etcd集群化以后，每个etcd的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到etcd是一个不错的选择。比如，业务系统中常用的二级代码表。</p><p>二级代码表的工作过程一般是这样，在表中存储代码，在etcd存储代码所代表的具体换衣，业务系统调用查表的过程，就需要查看表中代码的含义。所以如果把二级代码表中的小量数据存储到etcd中，不仅方便修改，也易于大量访问。</p><h3 id="利用etcd维护一个负载均衡节点表"><a href="#利用etcd维护一个负载均衡节点表" class="headerlink" title="利用etcd维护一个负载均衡节点表"></a>利用etcd维护一个负载均衡节点表</h3><p>etcd可以监控一个集群中多个节点的状态，当有一个请求发过来后，可以轮询式把请求转发给存活的多个节点。类似KafkaMQ，通过Zookeeper来维护生产者和消费者的负载均衡（也可以用etcd来做Zookeeper的工作）。</p><p><img src="/images/blog/etcd/load-balance.jpg" alt="负载均衡"></p><h2 id="场景四：-分布式通知与协调"><a href="#场景四：-分布式通知与协调" class="headerlink" title="场景四： 分布式通知与协调"></a>场景四： 分布式通知与协调</h2><p>这里讨论的分布式通知和协调，与消息发布和订阅有点相似。两者都使用了etcd的<code>Watcher</code>机制，通过注册与异步通知机制，实现分布式环境下的不同系统之间的通知与协调，从而对数据变更进行实时处理。</p><p>实现方式通常为：</p><p>不同系统都在etcd上对同一个目录进行注册，同事设置<code>Watcher</code>监控该目录的变化（如果对子目录的变化也有需求，可以设置成递归模式），当某个系统更新了etcd的目录，那么设置了<code>Watcher</code>的系统就会受到通知，并做出相应的通知，并作出相应处理。</p><h3 id="通过etcd进行低耦合的心跳检测"><a href="#通过etcd进行低耦合的心跳检测" class="headerlink" title="通过etcd进行低耦合的心跳检测"></a>通过etcd进行低耦合的心跳检测</h3><p>检测系统和被检测系统通过etcd上某个目录管理而非直接关联起来，这样可以大大减少系统的耦合性。</p><h3 id="通过etcd完成系统调度"><a href="#通过etcd完成系统调度" class="headerlink" title="通过etcd完成系统调度"></a>通过etcd完成系统调度</h3><p>某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台做的一些操作，实际上只需要修改etcd上某些目录节点的状态，而etcd就会自动把这些变化通知给注册了<code>Watcher</code>的推送系统客户端，推送系统再作出相应的推送任务。</p><h3 id="通过etcd完成工作汇报"><a href="#通过etcd完成工作汇报" class="headerlink" title="通过etcd完成工作汇报"></a>通过etcd完成工作汇报</h3><p>大部分类似的任务分发系统，子任务启动后，到etcd来注册一个临时工作目录，并且定时将自己的进度汇报（将进度写入到这个临时目录），这样任务管理者就能够实时知道任务进度。</p><p><img src="/images/blog/etcd/distributed-collaborative-work.jpg" alt="分布式协同工作"></p><h2 id="场景五：-分布式锁"><a href="#场景五：-分布式锁" class="headerlink" title="场景五： 分布式锁"></a>场景五： 分布式锁</h2><p>因为etcd使用<code>Raft</code>算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。</p><p>锁服务有两种使用方式，一是保持独占，二是控制时序。</p><h3 id="保持独占"><a href="#保持独占" class="headerlink" title="保持独占"></a>保持独占</h3><p>即所有试图获取锁的用户最终只有一个可以得到。</p><p>etcd为此提供了一套实现分布式锁原子操作CAS（<code>ComparaAndSwap</code>）的API。通过设置<code>prevExist</code>值，可以保证在多个节点同时创建某个目录时，只有一个成功，而该用户即可任务是获得了锁。</p><h3 id="控制时序"><a href="#控制时序" class="headerlink" title="控制时序"></a>控制时序</h3><p>即所有试图获取锁的用户都会进入等待队列，获得锁的顺序是全局唯一的，同时决定了队列执行顺序。</p><p>etcd为此也提供了一套API（自动创建有序键），对一个目录建值是指定为<code>POST</code>动作，这样etcd就会在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。</p><p>同时还可以使用API按顺序列出所有目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。</p><p><img src="/images/blog/etcd/distributed-lock.jpg" alt="分布式锁"></p><h2 id="场景六：-分布式队列"><a href="#场景六：-分布式队列" class="headerlink" title="场景六： 分布式队列"></a>场景六： 分布式队列</h2><p>分布式队列的常规用法与场景五中所描述的分布式锁的控制时序用法类似，即创建一个先进先出的队列，保证顺序。</p><p>另一种比较有意思的实现是<strong>在保证队列达到某个条件时再统一按顺序执行</strong>。这种方法的实现可以在<code>/queue</code>这个目录中另外再建立一个<code>/queue/condition</code>节点。</p><ol><li>condition可以表示队列大小。比如一个大的任务需要很多小任务就绪的情况下才能执行，每次有一个小任务就绪，就给这个condition数字加1，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。</li><li>condition可以表示某个任务不在队列。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其他任务。</li><li>condition还可以表示其它的一类开始执行任务的通知。可以由控制程序指定，当condition出现变化时，开始执行队列任务。</li></ol><p><img src="/images/blog/etcd/distributed-queue.jpg" alt="分布式队列"></p><h2 id="场景七：-集群监控与Leader竞选"><a href="#场景七：-集群监控与Leader竞选" class="headerlink" title="场景七： 集群监控与Leader竞选"></a>场景七： 集群监控与Leader竞选</h2><p>通过etcd来进行监控实现起来非常简单并且实时性强，用到了以下两点特性：</p><ol><li>前面几个场景已经提到了Watcher机制，当某个节点消失或由变动时，Watcher会第一时间发现并告知用户。</li><li>节点可以设置<code>TTL key</code>，比如每隔30s向etcd发送一次心跳使代表该节点依然存活，否则说明节点消失。</li></ol><p>这样就可以第一时间检测到各节点的健康状态，以完成集群的监控要求。</p><p>另外，使用分布式锁，可以完成Leader竞选。对于一些长时间CPU计算或使用IO操作，只需要由竞选出的Leader计算或处理一次，再把结果复制给其他Follower即可，从而避免重复劳动，节省计算资源。</p><p>Leader应用的经典场景是在<strong>搜索系统中建立全量索引</strong>。如果每个机器分别进行索引的建立，不仅耗时，而且不能保证索引的一致性。通过在etcd的CAS机制竞选Leader，由Leader进行索引计算，再降计算结果分发到其他节点。</p><p><img src="/images/blog/etcd/leader-election.jpg" alt="Leader竞选"></p><h2 id="场景八：-为什么使用etcd而不用Zookeeper？"><a href="#场景八：-为什么使用etcd而不用Zookeeper？" class="headerlink" title="场景八： 为什么使用etcd而不用Zookeeper？"></a>场景八： 为什么使用etcd而不用Zookeeper？</h2><p>阅读了“<a href="http://jm-blog.aliapp.com/?p=1232" target="_blank" rel="noopener">Zookeeper典型应用场景一览</a>”的同学可能会发现，etcd实现的这些功能，Zookeeper都能实现。那为什么要用etcd而非直接使用Zookeeper呢？</p><p>相比较之下，Zookeeper有如下缺点。</p><ol><li>复杂。 Zookeeper的部署维护复杂，管理员必须掌握一系列的知识和技能；而<a href="http://">Paxos</a>强一致性算法也是素来以复杂难懂而闻名于世；另外，Zookeeper的使用也比较复杂，需要安装客户端，官方只提供Java和C的两种语言的接口。</li><li>Java编写。这里不是对Java有偏见，而是Java本身就偏向重型应用，它会引入大量的依赖。而运维人员则普遍希望机器集群能尽可能的简单，维护起来也不容易出错。</li><li>发展缓慢。 Apache基金会项目特有的“<a href="http://www.infoworld.com/article/2612082/open-source-software/has-apache-lost-its-way-.html" target="_blank" rel="noopener">Apache Way</a>”在开源界也饱受争议，其中一大原因就是由于基金会庞大的结构和松散的管理导致项目发展缓慢。</li></ol><p>而etcd作为一个后起之秀，其优点也很明显。</p><ol><li>简单。 使用Go编写部署简单；使用HTTP作为接口使用简单；使用Raft算法保证强一致性让用户易于理解。</li><li>数据持久化。 etcd默认数据一更新就进行持久化。</li><li>安全。 etcd支持SSL客户端安全认证。</li></ol><p>最后，etcd作为一个年轻的项目，正在高速迭代和开发中，这既是一个优点，也是一个缺点。</p><p>优点是在于它的未来具有无限的可能性，缺点是版本的迭代导致其使用的可靠性无法保证，无法得到大项目长时间使用的校验。</p><p>然而，目前CoreOS、Kubernetes和Cloudfoundry等知名项目均在生产环境中使用了etcd，所以总的来说，etcd值得你去尝试。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">https://github.com/coreos/etcd</a></li><li><a href="http://jm-blog.aliapp.com/?p=1232" target="_blank" rel="noopener">http://jm-blog.aliapp.com/?p=1232</a></li><li><a href="http://progrium.com/blog/2014/07/29/understanding-modern-service-discovery-with-docker/" target="_blank" rel="noopener">http://progrium.com/blog/2014/07/29/understanding-modern-service-discovery-with-docker/</a></li><li><a href="http://devo.ps/blog/zookeeper-vs-doozer-vs-etcd" target="_blank" rel="noopener">http://devo.ps/blog/zookeeper-vs-doozer-vs-etcd</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> etcd </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty 5用户指南</title>
      <link href="2015/09/20/netty5-user-guide/"/>
      <url>2015/09/20/netty5-user-guide/</url>
      
        <content type="html"><![CDATA[<p>Netty是一个<code>NIO client/server</code>网络编程框架，可以快速且容易的开发基于协议（protocol）的网络客户端/服务端的程序，它极大简化了TCP和UDP socket编程，提供流水线化的操作。</p><p>“快速且容易”并不会导致应用难以维护和性能低下。Netty经过仔细设计，基于许多协议实现的经验如：<code>FTP</code>、<code>SMTP</code>、<code>HTTP</code>以及各种二进制和基于本文的老的协议，Netty成功的找到一种保证开发，稳定性，灵活性的方式，毋需折中。</p><p><img src="/images/blog/netty/components.png" alt="netty components"></p><a id="more"></a><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul><li>为各种传输类型提供统一的API，阻塞和非阻塞的socket</li><li>灵活和可扩展的事件模型，将关注点分离</li><li>高度可定制的线程模型-单线程，一种或多个线程池，如<a href="http://en.wikipedia.org/wiki/Staged_event-driven_architecture" target="_blank" rel="noopener">SEDA</a></li><li>真正无连接的数据报socket支持（since 3.1）</li></ul><h2 id="易用"><a href="#易用" class="headerlink" title="易用"></a>易用</h2><ul><li>提供Javadoc，用户指南和例子</li><li>JDK1.5以上版本不需要第三方库支持</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul><li>更好的吞吐率，低延迟</li><li>较少的资源占用</li><li>最小化不必要的内存拷贝</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li> 完整的SSL/TLS， StartTLS支持</li></ul><h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><ul><li>作者从2003就开始写类似的框架（<code>mina</code>），一直收集用户反馈。官方的<a href="http://netty.io/wiki/user-guide-for-5.x.html" target="_blank" rel="noopener">user guide</a>，中文翻译的<a href="http://www.getsetter.cn/2014/07/15/netty5/" target="_blank" rel="noopener">用户指南</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现如今我们使用通用的应用程序或者类库来实现系统之间的互相访问，比如，我们经常使用一个HTTP客户端来从web服务器上获取信息，或者通过web service来执行一个远程的调用。</p><p>然而，一个通用的协议和它的实现有时候并没用覆盖到一些场景。比如我们无法使用通用的http服务器来对庞大的文件和电子邮件进行交互，再比如我们无法处理那中准实时消息，比如财务信息和多人游戏数据。我们需要一个高效的协议实现用来处理一些特殊的场景。例如你可以实现一个基于AJAX的聊天应用，媒体流传输或者大文件传输的http服务器，你甚至可以想自己设计一个新的协议来准确定制你自己的需求。</p><p>另外，不可避免的事情是你不得不处理这些私有协议来确保和原有系统的互通。在这个例子中会告诉你实现一个对应该程序不损耗稳定性和性能的协议是多么的快。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="http://netty.io/" target="_blank" rel="noopener">Netty</a>是一个提供异步事件驱动的网络应用框架，可以为服务端和客户端提供一个快速迭代开发的高性能、高伸缩性的协议。</p><p>换句话说，Netty是一个能够快速简单地来开发网络应用程序的NIO框架比如客户端和服务端的协议，Netty大大简化了网络程序的开发过程比如TCP和UDP的 Socket的开发。</p><p>快速和简单并不等于一个应用会产生可维护性和性能的问题，Netty是一个被精心设计的框架，他从许多协议的实现中吸收了很多的经验比如FTP,SMTP,HTTP和许多二进制和基于文本的传统协议，Netty已经成功地找出了解决方案并且在不妥协开发效率、性能、稳定性、灵活性情况下。</p><p>有一些用户可能已经发现其他的一些网络框架声称自己也有同样的优势，所以你可能会问是Netty和他们有什么不一样。答案就是Netty的哲学设计理念。Netty从第一天开始就把API和实现设计成为你提供最舒适的使用体验。Netty的设计理念会使当你阅读本指南并且和Netty打交道的时候，让你的使用变得更加简单。</p><h1 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h1><p>这个章节会围绕Netty核心的结构并附上一些简单的例子让你快速的入门。当你读完本章节你马上就可以用Netty写出一个客户端和一个服务端。<br>如果你在学习某些东西的时候喜欢自顶向下的方法，你可能想要从第二个章节架构概述开始，然后再回到这里。</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>如果要运行本章节中的2个例子最低要求是：Netty的最新版本(Netty5)和JDK1.6及以上。最新的Netty版本在项目<a href="http://netty.io/downloads.html" target="_blank" rel="noopener">下载页面</a>。为了下载到正确的JDK版本，请到你偏爱的网站下载。<br>当你在读的过程中，你可能有很多关于本章节介绍的类相关的问题，每当你想知道他们的更多的信息那么请参考API说明文档。为了方便，所有文档中涉及到的类名字都会被关联到一个在线的API说明。当然如果有任何错误信息、语法错误或者你有任何好的建议来改进文档说明，那么请联系<a href="http://netty.io/community.html" target="_blank" rel="noopener">netty社区</a>。</p><h2 id="实现Discard服务器"><a href="#实现Discard服务器" class="headerlink" title="实现Discard服务器"></a>实现Discard服务器</h2><p>世界上最简单的协议不是”Hello,World!”，是<a href="http://tools.ietf.org/html/rfc863" target="_blank" rel="noopener">DISCARD</a>，他是一种丢弃所有接收的数据，并不做有任何响应的协议。<br>为了实现DISCARD协议，你唯一需要做的就是忽略所有收到的数据。让我们从处理器的实现开始，处理器是由Netty生成用来处理I/O事件的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.discard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles a server-side channel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123; <span class="comment">// (2)</span></span><br><span class="line">        <span class="comment">// Discard the received data silently.</span></span><br><span class="line">        ((ByteBuf) msg).release(); <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123; <span class="comment">// (4)</span></span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>DisCardServerHandler 继承自 <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" target="_blank" rel="noopener">ChannelHandlerAdapter</a>，这个类实现了<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>接口，ChannelHandler提供了许多事件处理的接口方法，然后你可以覆盖这些方法。现在仅仅只需要继承<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" target="_blank" rel="noopener">ChannelHandlerAdapter</a>类而不是你自己去实现接口方法。</p></li><li><p>这里我们覆盖了<code>chanelRead()</code>事件处理方法。每当从客户端收到新的数据时，这个方法会在收到消息时被调用，这个例子中，收到的消息的类型是<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a></p></li><li><p>为了实现DISCARD协议，处理器不得不忽略所有接受到的消息。<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a>是一个引用计数对象，这个对象必须显示地调用release()方法来释放。请记住处理器的职责是释放所有传递到处理器的引用计数对象。通常，channelRead()方法的实现就像下面的这段代码：</p></li></ul><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Do something with msg</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> <code>exceptionCaught()</code>事件处理方法是当出现Throwable对象才会被调用，即当Netty由于IO错误或者处理器在处理事件时抛出的异常时。在大部分情况下，捕获的异常应该被记录下来并且把关联的channel给关闭掉。然而这个方法的处理方式会在遇到不同异常的情况下有不同的实现，比如你可能想在关闭连接之前发送一个错误码的响应消息。</li></ul><p>到目前为止一切都还比较顺利，我们已经实现了DISCARD服务的一半功能，剩下的需要编写一个<code>main()</code>方法来启动服务端的DiscardServerHandler。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.discard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Discards any incoming data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// (1)</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// (2)</span></span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>) // (3)</span></span><br><span class="line"><span class="class">             .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123; <span class="comment">// (4)</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)          <span class="comment">// (5)</span></span><br><span class="line">             .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Bind and start to accept incoming connections.</span></span><br><span class="line">            ChannelFuture f = b.bind(port).sync(); <span class="comment">// (7)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            <span class="comment">// In this example, this does not happen, but you can do that to gracefully</span></span><br><span class="line">            <span class="comment">// shut down your server.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            port = <span class="number">8080</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> DiscardServer(port).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="noopener">NioEventLoopGroup</a> 是用来处理I/O操作的多线程事件循环器，Netty提供了许多不同的<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="noopener">EventLoopGroup</a>的实现用来处理不同传输协议。在这个例子中我们实现了一个服务端的应用，因此会有2个<a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="noopener">NioEventLoopGroup</a>会被使用。第一个经常被叫做‘<code>boss</code>’，用来接收进来的连接。第二个经常被叫做‘<code>worker</code>’，用来处理已经被接收的连接，一旦‘<code>boss</code>’接收到连接，就会把连接信息注册到‘<code>worker</code>’上。如何知道多少个线程已经被使用，如何映射到已经创建的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channels</a>上都需要依赖于<a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="noopener">EventLoopGroup</a>的实现，并且可以通过构造函数来配置他们的关系。</li><li><a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="noopener">ServerBootstrap</a> 是一个启动NIO服务的辅助启动类。你可以在这个服务中直接使用<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>，但是这会是一个复杂的处理过程，在很多情况下你并不需要这样做。</li><li>这里我们指定使用<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="noopener">NioServerSocketChannel</a>类来举例说明一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>如何接收进来的连接。</li><li>这里的事件处理类经常会被用来处理一个最近的已经接收的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>。<a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="noopener">ChannelInitializer</a>是一个特殊的处理类，他的目的是帮助使用者配置一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>。也许你想通过增加一些处理类比如DiscardServerHandle来配置一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>或者其对应的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="noopener">ChannelPipeline</a>来实现你的网络程序。当你的程序变的复杂时，可能你会增加更多的处理类到<code>pipline</code>上，然后提取这些匿名类到最顶层的类上。</li><li> 你可以设置这里指定的通道实现的配置参数。我们正在写一个TCP/IP的服务端，因此我们被允许设置socket的参数选项比如<code>tcpNoDelay</code>和<code>keepAlive</code>。请参考<a href="http://netty.io/5.0/api/io/netty/channel/ChannelOption.html" target="_blank" rel="noopener">ChannelOption</a>和详细的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelConfig.html" target="_blank" rel="noopener">ChannelConfig</a>实现的接口文档以此可以对<a href="http://netty.io/5.0/api/io/netty/channel/ChannelOption.html" target="_blank" rel="noopener">ChannelOptions</a>的有一个大概的认识。</li><li>你关注过<code>option()</code>和<code>childOption()</code>吗？<code>option()</code>是提供给<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="noopener">NioServerSocketChannel</a>用来接收进来的连接。childOption()是提供给由父管道<a href="http://netty.io/5.0/api/io/netty/channel/ServerChannel.html" target="_blank" rel="noopener">ServerChannel</a>接收到的连接，在这个例子中也是<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="noopener">NioServerSocketChannel</a>。</li><li>我们继续，剩下的就是绑定端口然后启动服务。这里我们在机器上绑定了机器所有网卡上的8080端口。当然现在你可以多次调用<code>bind()</code>方法(基于不同绑定地址)。</li></ul><p>恭喜！你已经完成熟练地完成了第一个基于NETTY的服务端程序。</p><h3 id="观察接收到的数据"><a href="#观察接收到的数据" class="headerlink" title="观察接收到的数据"></a>观察接收到的数据</h3><p>现在我们已经编写出我们第一个服务端，我们需要测试一下他是否真的可以运行。最简单的测试方法是用<code>telnet</code> 命令。例如，你可以在命令行上输入<code>telnet localhost 8080</code>或者其他类型参数。</p><p>然而我们能说这个服务端是正常运行了吗？事实上我们也不知道因为他是一个discard服务，你根本不可能得到任何的响应。为了证明他仍然是在工作的，让我们修改服务端的程序来打印出他到底接收到了什么。</p><p>我们已经知道<code>channelRead()</code>方法是在数据被接收的时候调用。让我们放一些代码到DiscardServerHandler类的<code>channelRead()</code>方法。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void channel<span class="constructor">Read(ChannelHandlerContext <span class="params">ctx</span>, Object <span class="params">msg</span>)</span> &#123;</span><br><span class="line">    ByteBuf <span class="keyword">in</span> = (ByteBuf) msg;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">in</span>.is<span class="constructor">Readable()</span>) &#123; <span class="comment">// (1)</span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print((<span class="built_in">char</span>) <span class="keyword">in</span>.read<span class="constructor">Byte()</span>);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.flush<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ReferenceCountUtil</span>.</span></span>release(msg); <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这个低效的循环事实上可以简化为:<code>System.out.println(in.toString(io.netty.util.CharsetUtil.US_ASCII))</code></p></li><li><p>或者，你可以在这里调用<code>in.release()</code>。</p></li></ul><p>如果你再次运行<code>telnet</code>命令，你将会看到服务端打印出了他所接收到的消息。</p><p>完整的discard server代码放在了<a href="http://netty.io/5.0/xref/io/netty/example/discard/package-summary.html" target="_blank" rel="noopener">io.netty.example.discard</a>包下面。</p><h2 id="ECHO服务（响应式协议）"><a href="#ECHO服务（响应式协议）" class="headerlink" title="ECHO服务（响应式协议）"></a>ECHO服务（响应式协议）</h2><p>到目前为止，我们虽然接收到了数据，但没有做任何的响应。然而一个服务端通常会对一个请求作出响应。让我们学习怎样在<a href="http://tools.ietf.org/html/rfc862" target="_blank" rel="noopener">ECHO</a>协议的实现下编写一个响应消息给客户端，这个协议针对任何接收的数据都会返回一个响应。</p><p>和discard server唯一不同的是把在此之前我们实现的<code>channelRead()</code>方法，返回所有的数据替代打印接收数据到控制台上的逻辑。因此，需要把<code>channelRead()</code>方法修改如下：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    ctx.<span class="built_in">write</span>(msg); <span class="comment">// (1)</span></span><br><span class="line">    ctx.<span class="built_in">flush</span>(); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerContext.html," target="_blank" rel="noopener">ChannelHandlerContext</a>对象提供了许多操作，使你能够触发各种各样的I/O事件和操作。这里我们调用了<code>write(Object)</code>方法来逐字地把接受到的消息写入。请注意不同于DISCARD的例子我们并没有释放接受到的消息，这是因为当写入的时候NETTY已经帮我们释放了。</li><li><code>ctx.write(Object)</code>方法不会使消息写入到通道上，他被缓冲在了内部，你需要调用<code>ctx.flush()</code>方法来把缓冲区中数据强行输出。或者你可以用更简洁的<code>cxt.writeAndFlush(msg)</code>以达到同样的目的。</li></ul><p>如果你再一次运行telnet命令，你会看到服务端会发回一个你已经发送的消息。<br>完整的echo服务的代码放在了<a href="http://netty.io/5.0/xref/io/netty/example/echo/package-summary.html" target="_blank" rel="noopener">io.netty.example.echo</a>包下面。</p><h2 id="TIME服务-时间协议的服务"><a href="#TIME服务-时间协议的服务" class="headerlink" title="TIME服务(时间协议的服务)"></a>TIME服务(时间协议的服务)</h2><p>在这个部分被实现的协议是<a href="http://tools.ietf.org/html/rfc868" target="_blank" rel="noopener">TIME</a>协议。和之前的例子不同的是在不接受任何请求时他会发送一个含32位的整数的消息，并且一旦消息发送就会立即关闭连接。在这个例子中，你会学习到如何构建和发送一个消息，然后在完成时主动关闭连接。</p><p>因为我们将会忽略任何接收到的数据，而只是在连接被创建发送一个消息，所以这次我们不能使用<code>channelRead()</code>方法了，代替他的是，我们需要覆盖<code>channelActive()</code>方法，下面的就是实现的内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx)</span> </span>&#123; <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">final</span> ByteBuf time = ctx.alloc().buffer(<span class="number">4</span>); <span class="comment">// (2)</span></span><br><span class="line">        time.writeInt((<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000L</span> + <span class="number">2208988800L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ChannelFuture f = ctx.writeAndFlush(time); <span class="comment">// (3)</span></span><br><span class="line">        f.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">assert</span> f == future;</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// (4)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>channelActive()</code>方法将会在连接被建立并且准备进行通信时被调用。因此让我们在这个方法里完成一个代表当前时间的32位整数消息的构建工作。</li><li>为了发送一个新的消息，我们需要分配一个包含这个消息的新的缓冲。因为我们需要写入一个32位的整数，因此我们需要一个至少有4个字节的<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a>。通过<code>ChannelHandlerContext.alloc()</code>得到一个当前的ByteBufAllocator，然后分配一个新的缓冲。</li><li>和往常一样我们需要编写一个构建好的消息。但是等一等，flip在哪？难道我们使用NIO发送消息时不是调用<code>java.nio.ByteBuffer.flip()</code>吗？ByteBuf之所以没有这个方法因为有两个指针，一个对应读操作一个对应写操作。当你向ByteBuf里写入数据的时候写指针的索引就会增加，同时读指针的索引没有变化。读指针索引和写指针索引分别代表了消息的开始和结束。</li></ul><p>比较起来，NIO缓冲并没有提供一种简洁的方式来计算出消息内容的开始和结尾，除非你调用<code>flip</code>方法。当你忘记调用flip方法而引起没有数据或者错误数据被发送时，你会陷入困境。这样的一个错误不会发生在Netty上，因为我们对于不同的操作类型有不同的指针。你会发现这样的使用方法会让你过程变得更加的容易，因为你已经习惯一种没有使用<code>flip</code>的方式。</p><p>另外一个点需要注意的是<code>ChannelHandlerContext.write()</code>(和<code>writeAndFlush()</code>)方法会返回一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="noopener">ChannelFuture</a>对象，一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="noopener">ChannelFuture</a>代表了一个还没有发生的I/O操作。这意味着任何一个请求操作都不会马上被执行，因为在Netty里所有的操作都是异步的。举个例子下面的代码中在消息被发送之前可能会先关闭连接。</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Channel ch = ...<span class="comment">;</span></span><br><span class="line">ch.writeAndFlush(message)<span class="comment">;</span></span><br><span class="line">ch.close()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>因此你需要在<code>write()</code>方法返回的ChannelFuture完成后调用<code>close()</code>方法，然后当他的写操作已经完成他会通知他的监听者。请注意,<code>close()</code>方法也可能不会立马关闭，他也会返回一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="noopener">ChannelFuture</a>。</p><ul><li>当一个写请求已经完成是如何通知到我们？这个只需要简单地在返回的ChannelFuture上增加一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html" target="_blank" rel="noopener">ChannelFutureListener</a>。这里我们构建了一个匿名的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html" target="_blank" rel="noopener">ChannelFutureListener</a>类用来在操作完成时关闭Channel。</li></ul><p>或者，你可以使用简单的预定义监听器代码:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">f</span><span class="selector-class">.addListener</span>(<span class="selector-tag">ChannelFutureListener</span><span class="selector-class">.CLOSE</span>);</span><br></pre></td></tr></table></figure><p>为了测试我们的time服务如我们期望的一样工作，你可以使用UNIX的<code>rdate</code>命令</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ rdate -o <span class="tag">&lt;<span class="name">port</span>&gt;</span> -p <span class="tag">&lt;<span class="name">host</span>&gt;</span></span><br></pre></td></tr></table></figure><p>port是你在<code>main()</code>函数中指定的端口，host使用locahost就可以了。</p><h2 id="Time客户端"><a href="#Time客户端" class="headerlink" title="Time客户端"></a>Time客户端</h2><p>不像DISCARD和ECHO的服务端，对于TIME协议我们需要一个客户端因为人们不能把一个32位的二进制数据翻译成一个日期或者日历。在这一部分，我们将会讨论如何确保服务端是正常工作的，并且学习怎样用NETTY编写一个客户端。</p><p>在Netty中,编写服务端和客户端最大的并且唯一不同的使用了不同的<a href="http://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="noopener">BootStrap</a>和<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">Channel</a>的实现。请看一下下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String host = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap(); <span class="comment">// (1)</span></span><br><span class="line">            b.group(workerGroup); <span class="comment">// (2)</span></span><br><span class="line">            b.channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// (3)</span></span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (4)</span></span><br><span class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the client.</span></span><br><span class="line">            ChannelFuture f = b.connect(host, port).sync(); <span class="comment">// (5)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the connection is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="http://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="noopener">BootStrap</a>和<a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="noopener">ServerBootstrap</a>类似,不过他是对非服务端的channel而言，比如客户端或者无连接传输模式的channel。</li><li>如果你只指定了一个<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="noopener">EventLoopGroup</a>，那他就会即作为一个‘<code>boss</code>’线程，也会作为一个‘<code>workder</code>’线程，尽管客户端不需要使用到‘<code>boss</code>’线程。</li><li>代替<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="noopener">NioServerSocketChannel</a>的是<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioSocketChannel.html" target="_blank" rel="noopener">NioSocketChannel</a>,这个类在客户端channel被创建时使用。</li><li>不像在使用ServerBootstrap时需要用<code>childOption()</code>方法，因为客户端的<a href="http://netty.io/5.0/api/io/netty/channel/socket/SocketChannel.html" target="_blank" rel="noopener">SocketChannel</a>没有父channel的概念。</li><li>我们用<code>connect()</code>方法代替了<code>bind()</code>方法。<br>正如你看到的，他和服务端的代码是不一样的。<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>是如何实现的?他应该从服务端接受一个32位的整数消息，把他翻译成人们能读懂的格式，并打印翻译好的时间，最后关闭连接:</li></ul><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Date</span>;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void channelRead(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg) &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> m = (<span class="type">ByteBuf</span>) msg; <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            long currentTimeMillis = (m.readUnsignedInt() - <span class="number">2208988800</span>L) * <span class="number">1000</span>L;</span><br><span class="line">            <span class="type">System</span>.out.println(<span class="keyword">new</span> <span class="type">Date</span>(currentTimeMillis));</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            m.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void exceptionCaught(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Throwable</span> cause) &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在TCP/IP中，NETTY会把读到的数据放到ByteBuf的数据结构中。</li></ul><p>这样看起来非常简单，并且和服务端的那个例子的代码也相差不多。然而，处理器有时候会因为抛出<code>IndexOutOfBoundsException</code>而拒绝工作。在下个部分我们会讨论为什么会发生这种情况。</p><h1 id="流数据的传输处理"><a href="#流数据的传输处理" class="headerlink" title="流数据的传输处理"></a>流数据的传输处理</h1><h2 id="一个小的Socket-Buffer问题"><a href="#一个小的Socket-Buffer问题" class="headerlink" title="一个小的Socket Buffer问题"></a>一个小的Socket Buffer问题</h2><p>在基于流的传输里比如TCP/IP，接收到的数据会先被存储到一个socket接收缓冲里。不幸的是，基于流的传输并不是一个数据包队列，而是一个字节队列。即使你发送了2个独立的数据包，操作系统也不会作为2个消息处理而仅仅是作为一连串的字节而言。因此这是不能保证你远程写入的数据就会准确地读取。举个例子，让我们假设操作系统的TCP/TP协议栈已经接收了3个数据包：</p><p><img src="/images/blog/netty/netty5_1.png" alt="netty socket buffer"></p><p>由于基于流传输的协议的这种普通的性质，在你的应用程序里读取数据的时候会有很高的可能性被分成下面的片段。</p><p><img src="/images/blog/netty/netty5_2.png" alt="netty socket buffer"></p><p>因此，一个接收方不管他是客户端还是服务端，都应该把接收到的数据整理成一个或者多个更有意思并且能够让程序的业务逻辑更好理解的数据。在上面的例子中，接收到的数据应该被构造成下面的格式：</p><p><img src="/images/blog/netty/netty5_3.png" alt="netty socket buffer"></p><h3 id="第一个解决方案"><a href="#第一个解决方案" class="headerlink" title="第一个解决方案"></a>第一个解决方案</h3><p>现在让我们回到TIME客户端的例子上。这里我们遇到了同样的问题，一个32字节数据是非常小的数据量，他并不见得会被经常拆分到到不同的数据段内。然而，问题是他确实可能会被拆分到不同的数据段内，并且拆分的可能性会随着通信量的增加而增加。</p><p>最简单的方案是构造一个内部的可积累的缓冲，直到4个字节全部接收到了内部缓冲。下面的代码修改了TimeClientHandler的实现类修复了这个问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ByteBuf buf;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        buf = ctx.alloc().buffer(<span class="number">4</span>); <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        buf.release(); <span class="comment">// (1)</span></span><br><span class="line">        buf = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf m = (ByteBuf) msg;</span><br><span class="line">        buf.writeBytes(m); <span class="comment">// (2)</span></span><br><span class="line">        m.release();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf.readableBytes() &gt;= <span class="number">4</span>) &#123; <span class="comment">// (3)</span></span><br><span class="line">            <span class="keyword">long</span> currentTimeMillis = (buf.readInt() - <span class="number">2208988800L</span>) * <span class="number">1000L</span>;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date(currentTimeMillis));</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>有2个生命周期的监听方法：handlerAdded()和handlerRemoved()。你可以完成任意初始化任务只要他不会被阻塞很长的时间。</li><li>首先，所有接收的数据都应该被累积在buf变量里。</li><li>然后，处理器必须检查buf变量是否有足够的数据，在这个例子中是4个字节，然后处理实际的业务逻辑。否则，Netty会重复调用channelRead()当有更多数据到达直到4个字节的数据被积累。</li></ul><h3 id="第二个解决方案"><a href="#第二个解决方案" class="headerlink" title="第二个解决方案"></a>第二个解决方案</h3><p>尽管第一个解决方案已经解决了Time客户端的问题了，但是修改后的处理器看起来不那么的简洁，想象一下如果由多个字段比如可变长度的字段组成的更为复杂的协议时，你的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>的实现将很快地变得难以维护。</p><p>正如你所知的，你可以增加多个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="noopener">ChannelPipeline</a> ,因此你可以把一整个ChannelHandler拆分成多个模块以减少应用的复杂程度，比如你可以把TimeClientHandler拆分成2个处理器：</p><ul><li>TimeDecoder处理数据拆分的问题</li><li>TimeClientHandler原始版本的实现</li></ul><p>幸运地是，Netty提供了一个可扩展的类，帮你完成TimeDecoder的开发。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void decode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> in, <span class="type">List</span>&lt;<span class="type">Object</span>&gt; out) &#123; <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// (3)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.add(in.readBytes(<span class="number">4</span>)); <span class="comment">// (4)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="noopener">ByteToMessageDecoder</a>是<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>的一个实现类，他可以在处理数据拆分的问题上变得很简单。</li><li>每当有新数据接收的时候，<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="noopener">ByteToMessageDecoder</a>都会调用decode()方法来处理内部的那个累积缓冲。</li><li><code>Decode()</code>方法可以决定当累积缓冲里没有足够数据时可以往out对象里放任意数据。当有更多的数据被接收了<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="noopener">ByteToMessageDecoder</a>会再一次调用<code>decode()</code>方法。</li><li>如果在<code>decode()</code>方法里增加了一个对象到out对象里，这意味着解码器解码消息成功。<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="noopener">ByteToMessageDecoder</a>将会丢弃在累积缓冲里已经被读过的数据。请记得你不需要对多条消息调用<code>decode()</code>，<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="noopener">ByteToMessageDecoder</a>会持续调用<code>decode()</code>直到不放任何数据到out里。</li></ul><p>现在我们有另外一个处理器插入到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="noopener">ChannelPipeline</a>里，我们应该在TimeClient里修改<a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="noopener">ChannelInitializer</a> 的实现：</p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">b.<span class="keyword">handler</span>(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> TimeDecoder(), <span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你是一个大胆的人，你可能会尝试使用更简单的解码类<a href="http://netty.io/5.0/api/io/netty/handler/codec/ReplayingDecoder.html" target="_blank" rel="noopener">ReplayingDecoder</a>。不过你还是需要参考一下API文档来获取更多的信息。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void decode(</span><br><span class="line">        <span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> in, <span class="type">List</span> out) &#123;</span><br><span class="line">        out.add(in.readBytes(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Netty还提供了更多可以直接拿来用的解码器使你可以更简单地实现更多的协议，帮助你避免开发一个难以维护的处理器实现。请参考下面的包以获取更多更详细的例子：</p><ul><li>对于二进制协议请看<a href="http://netty.io/5.0/xref/io/netty/example/factorial/package-summary.html" target="_blank" rel="noopener">io.netty.example.factorial</a></li><li>对于基于文本协议请看<a href="http://netty.io/5.0/xref/io/netty/example/telnet/package-summary.html" target="_blank" rel="noopener">io.netty.example.telnet</a></li></ul><h2 id="用POJO代替ByteBuf"><a href="#用POJO代替ByteBuf" class="headerlink" title="用POJO代替ByteBuf"></a>用POJO代替ByteBuf</h2><p>我们已经讨论了所有的例子，到目前为止一个消息的消息都是使用<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a>作为一个基本的数据结构。在这一部分，我们会改进TIME协议的客户端和服务端的例子，用POJO替代<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a>。</p><p>在你的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandlerS</a>中使用POJO优势是比较明显的。通过从<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>中提取出ByteBuf的代码，将会使<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="noopener">ChannelHandler</a>的实现变得更加可维护和可重用。在TIME客户端和服务端的例子中，我们读取的仅仅是一个32位的整形数据，直接使用ByteBuf不会是一个主要的问题。然后，你会发现当你需要实现一个真实的协议，分离代码变得非常的必要。</p><p>首先，让我们定义一个新的类型叫做UnixTime。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">package io.netty.example.time;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnixTime</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnixTime</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>((<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000L</span> + <span class="number">2208988800L</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnixTime</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date((<span class="keyword">value</span>() - <span class="number">2208988800L</span>) * <span class="number">1000L</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以修改下TimeDecoder类，返回一个UnixTime，以替代<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a></p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span>(<span class="params">ChannelHandlerContext ctx, ByteBuf <span class="keyword">in</span>, List&lt;Object&gt; <span class="keyword">out</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">in</span>.readableBytes() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">out</span>.<span class="keyword">add</span>(<span class="keyword">new</span> UnixTime(<span class="keyword">in</span>.readInt()));</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>下面是修改后的解码器，TimeClientHandler不再有任何的<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="noopener">ByteBuf</a>代码了。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> channelRead(ChannelHandlerContext ctx, <span class="keyword">Object</span> msg) &#123;</span><br><span class="line">    UnixTime m = (UnixTime) msg;</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(m);</span><br><span class="line">    ctx.<span class="keyword">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是变得更加简单和优雅了？相同的技术可以被运用到服务端。让我们修改一下TimeServerHandler的代码。</p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    ChannelFuture f = ctx.writeAndFlush(<span class="keyword">new</span> UnixTime());</span><br><span class="line">    f.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，仅仅需要修改的是ChannelHandler的实现，这里需要把UnixTime对象重新转化为一个ByteBuf。不过这已经是非常简单了，因为当你对一个消息编码的时候，你不需要再处理拆包和组装的过程。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void write(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg, <span class="type">ChannelPromise</span> promise) &#123;</span><br><span class="line">        <span class="type">UnixTime</span> m = (<span class="type">UnixTime</span>) msg;</span><br><span class="line">        <span class="type">ByteBuf</span> encoded = ctx.alloc().buffer(<span class="number">4</span>);</span><br><span class="line">        encoded.writeInt(m.value());</span><br><span class="line">        ctx.write(encoded, promise); <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这几行代码里还有几个重要的事情。</p><ul><li>第一， 通过ChannelPromise，当编码后的数据被写到了通道上Netty可以通过这个对象标记是成功还是失败。</li><li>第二， 我们不需要调用<code>cxt.flush()</code>。因为处理器已经单独分离出了一个方法<code>void flush(ChannelHandlerContext cxt)</code>,如果像自己实现<code>flush</code>方法内容可以自行覆盖这个方法。</li></ul><p>进一步简化操作，你可以使用<a href="http://netty.io/5.0/api/io/netty/handler/codec/MessageToByteEncoder.html" target="_blank" rel="noopener">MessageToByteEncode</a>:</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder&lt;UnixTime&gt;</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void encode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">UnixTime</span> msg, <span class="type">ByteBuf</span> out) &#123;</span><br><span class="line">        out.writeInt(msg.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的任务就是在TimeServerHandler之前把TimeEncoder插入到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="noopener">ChannelPipeline</a>。但这是不那么重要的工作。</p><h2 id="关闭你的应用"><a href="#关闭你的应用" class="headerlink" title="关闭你的应用"></a>关闭你的应用</h2><p>关闭一个Netty应用往往只需要简单地通过<code>shutdownGracefully()</code>方法来关闭你构建的所有的<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="noopener">NioEventLoopGroup</a>S.当<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="noopener">EventLoopGroup</a>被完全地终止,并且对应的所有channels都已经被关闭时，Netty会返回一个<a href="http://netty.io/5.0/api/io/netty/util/concurrent/Future.html" target="_blank" rel="noopener">Future</a>对象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一章节中，我们会快速地回顾下如果在熟练掌握Netty的情况下编写出一个健壮能运行的网络应用程序。<br>在Netty接下去的章节中还会有更多更相信的信息。我们也鼓励你去重新复习下在<a href="https://github.com/netty/netty/tree/master/example/src/main/java/io/netty/example" target="_blank" rel="noopener">io.netty.example</a>包下的例子。<br>请注意<a href="http://netty.io/community.html" target="_blank" rel="noopener">社区</a>一直在等待你的问题和想法以帮助Netty的持续改进，Netty的文档也是基于你们的快速反馈上。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Maven使用artchetype:create创建工程失败的问题</title>
      <link href="2015/09/18/maven-generate-project/"/>
      <url>2015/09/18/maven-generate-project/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/maven/maven-jee.png" alt="maven java"></p><p>Maven是我一直用来管理Java项目生命周期的工具，从2006年开始使用，到现在快十年了。没想到今天碰到一个新的问题，就是使用 <code>mvn artchetype:create</code> 来创建项目时失败了。</p><a id="more"></a><p>问题如下：</p><p>Maven命令如下：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn archetype:create \</span><br><span class="line">    <span class="attribute">-DgroupId</span>=com.github.tonydeng.bluebrid \</span><br><span class="line">    <span class="attribute">-DartifactId</span>=bluebrid</span><br></pre></td></tr></table></figure><p>错误提示如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[ERROR] Failed to <span class="keyword">execute</span> goal org.apache.maven.plugins:maven-archetype-<span class="keyword">plugin</span>:<span class="number">2.4</span>:<span class="keyword">create</span> (<span class="keyword">default</span>-cli) <span class="keyword">on</span> <span class="keyword">project</span> bluebrid: Unable <span class="keyword">to</span> <span class="keyword">parse</span> configuration <span class="keyword">of</span> mojo org.apache.maven.plugins:maven-archetype-<span class="keyword">plugin</span>:<span class="number">2.4</span>:<span class="keyword">create</span> <span class="keyword">for</span> parameter <span class="comment">#: Cannot create instance of interface org.apache.maven.artifact.repository.ArtifactRepository: org.apache.maven.artifact.repository.ArtifactRepository.&lt;init&gt;() -&gt; [Help 1]</span></span><br><span class="line">[<span class="keyword">ERROR</span>]</span><br><span class="line">[<span class="keyword">ERROR</span>] <span class="keyword">To</span> see the <span class="keyword">full</span> stack <span class="keyword">trace</span> <span class="keyword">of</span> the <span class="keyword">errors</span>, re-run Maven <span class="keyword">with</span> the -e switch.</span><br><span class="line">[<span class="keyword">ERROR</span>] Re-run Maven <span class="keyword">using</span> the -X <span class="keyword">switch</span> <span class="keyword">to</span> <span class="keyword">enable</span> <span class="keyword">full</span> debug logging.</span><br><span class="line">[<span class="keyword">ERROR</span>]</span><br><span class="line">[<span class="keyword">ERROR</span>] <span class="keyword">For</span> more information about the <span class="keyword">errors</span> <span class="keyword">and</span> possible solutions, please <span class="keyword">read</span> the <span class="keyword">following</span> articles:</span><br><span class="line">[<span class="keyword">ERROR</span>] [<span class="keyword">Help</span> <span class="number">1</span>] <span class="keyword">http</span>://cwiki.apache.org/confluence/display/MAVEN/PluginConfigurationException</span><br></pre></td></tr></table></figure><p>从错误提示来看，应该是<code>maven-archetype-plugin-2.4</code>这个版本的插件没有<code>create</code>这个参数了。</p><p>去<a href="http://maven.apache.org/" target="_blank" rel="noopener">Maven的官网</a>的<a href="http://maven.apache.org/plugins/index.html" target="_blank" rel="noopener">plugin list</a>中查看，原来archetype这个插件在2015年8月9号更新到2.4的版本，那再继续看看<a href="http://maven.apache.org/archetype/maven-archetype-plugin/" target="_blank" rel="noopener">archetype插件</a>有了什么新的变化。</p><p>原来artchetype已经没有create这个方法了，现在推荐方式是先建立自己的Example project，然后通过这个example project为例子，再创建实际你要用的项目。</p><p>基本的流程就像这幅图中描述的。</p><p><img src="/images/blog/maven/archetype-overview.png" alt="maven archetype plugin flow"></p><p>OK，那我们就按照官方的指示来操作一次看看。</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">$ mvn arche<span class="keyword">type</span>:create-from-project</span><br><span class="line">$ cd target/generated-sources/arche<span class="keyword">type</span>/</span><br><span class="line">$ mvn install</span><br><span class="line">$ cd /tmp/arche<span class="keyword">type</span></span><br><span class="line">$ mvn arche<span class="keyword">type</span>:generate -<span class="type">DarcheypteCatalog</span>=local</span><br></pre></td></tr></table></figure><p>那还有没有别的简单的方法来创建，就像之前使用archetype:create一样呢？</p><p>你可以使用下面的命令来进行创建项目。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">    <span class="attribute">-DarchetypeGroupId</span>=org.apache.maven.archetypes \</span><br><span class="line">    <span class="attribute">-DgroupId</span>=com.github.tonydeng.bluebrid \</span><br><span class="line">    <span class="attribute">-DartifactId</span>=bluebrid \</span><br><span class="line">    -T20</span><br></pre></td></tr></table></figure><p>不过，这样创建项目，你会发现在如下两个点要等N长的时间，这个N长的时间可能要以几十分钟来计算。</p><blockquote><p>[INFO] Generating project in Interactive mode</p></blockquote><blockquote><p>[INFO] Generating project in Batch mode</p></blockquote><p>其实你可以再加上两个参数  <code>-DinteractiveMode=false -DarchetypeCatalog=internal</code> 可以让你快速秒建项目。</p><p>这两个参数的意义分别如下：</p><blockquote><p>-DinteractiveMode=false  指定不使用交互模式</p><p>-DarchetypeCatalog=internal 指定不从远程服务器上取catalog，</p></blockquote><p>完整的命令如下：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">    <span class="attribute">-DarchetypeGroupId</span>=org.apache.maven.archetypes \</span><br><span class="line">    <span class="attribute">-DinteractiveMode</span>=<span class="literal">false</span> \</span><br><span class="line">    <span class="attribute">-DarchetypeCatalog</span>=internal \</span><br><span class="line">    <span class="attribute">-DgroupId</span>=com.github.tonydeng.bluebrid \</span><br><span class="line">    <span class="attribute">-DartifactId</span>=bluebrid \</span><br><span class="line">    -T20</span><br></pre></td></tr></table></figure><p>创建webapp项目命令如下：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">    <span class="attribute">-DarchetypeGroupId</span>=org.apache.maven.archetypes \</span><br><span class="line">    <span class="attribute">-DinteractiveMode</span>=<span class="literal">false</span> \</span><br><span class="line">    <span class="attribute">-DarchetypeCatalog</span>=internal \</span><br><span class="line">    <span class="attribute">-DgroupId</span>=com.github.tonydeng.bluebrid \</span><br><span class="line">    <span class="attribute">-DartifactId</span>=bluebrid-webapp \</span><br><span class="line">    <span class="attribute">-DarchetypeArtifactId</span>=maven-archetype-webapp \</span><br><span class="line">    -T20</span><br></pre></td></tr></table></figure><p>遇到同样问题的同学们，你们可以试试我的方法，应该能够快速的解决你们的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL vs SQL By Alphabet高可用架构微信群</title>
      <link href="2015/08/20/nosql-vs-sql/"/>
      <url>2015/08/20/nosql-vs-sql/</url>
      
        <content type="html"><![CDATA[<p>本文所有内容来自Alphabet高可用架构微信群内部分享，分享是阿里巴巴的沈询老师。</p><p>今天想介绍的东西是NoSQL到SQL。我之所以选择这个题目，其实就是因为看到了一张图。</p><p><img src="/images/blog/nosql_vs_sql/a_history_of_databases_in_no-tation.jpg" alt="A history of databases in No-tation"></p><p>看完以后我真的噗嗤就笑了，黑的漂亮。</p><a id="more"></a><p>作为一个对数据库历史有点了解的人来说，这图真的反应了我们在数据库存储领域螺旋上升一样的发展历程的最佳代表，这哥们真的是天赋异禀。</p><p>那么，为什么我会笑呢？今天习武我做完这次分享，大家也能够跟我一样笑一下~</p><p>那么我们先来第一章：</p><h2 id="1970-We-have-no-SQL"><a href="#1970-We-have-no-SQL" class="headerlink" title="1970:We have no SQL"></a>1970:We have no SQL</h2><p>嗯，我们没有SQL</p><p>要介绍这个问题，我们要先来看看，什么叫数据库，以及数据库这个东西是怎么来的。</p><p>相信，大家都是程序员，而程序员，一定会碰到这样一个需求：“我要用计算机表示一辆车子”。</p><p>这辆车呢，有一个外壳，四善玻璃，四个轮子。</p><p>我应该如何用程序来表述它呢？</p><p>第一个能够想到的，一定是使用结构体（Java中class）。</p><p>但，当我们发现这个车子的抽象不够用了，比如，我需要在车子上面装一对反光镜。该怎么办呢？</p><p>我们只能往里面增加一个新的属性，来表述这个反光镜。</p><p>如果这种需求越来越多，越来越多，我们就会发现，每次都要改一下这个结构体，编译，发布，是一个非常麻烦的事情啊……于是，就有了这种非常纯粹的需求，我有没有可能把他弄成动态的？</p><p>这时候，我们最常用的一个数据结构，就是“映射”。</p><p>如果我是一个Java程序员的话，那么映射就是一个Map&lt;Object,Object&gt;</p><p>一般来说Map有两类实现，第一类是Hash，第二类是有序树。</p><p>有了这个随需应变的集合，我们就可以把事情变成这样：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"轮子"</span>,轮子对象);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"镜子"</span>,镜子对象);</span><br></pre></td></tr></table></figure><p>我们有些时候，又会担心数据丢失对不对？</p><p>所以，还要想办法把这个对象以非常高兴的方式持久化下来，放到磁盘上，这样就不容易丢失了。</p><p>如果大家了解一点点的磁盘知识的画，就立刻会发现一个问题，<code>map.put/get</code> 操作，其实都是有一次寻找的过程。而这个寻找的过程，对于磁盘来说，就会转变为一次随机的寻道过程。</p><p>这里有很多种方式，能够用磁盘结构来存储类似Map这样的概念，我今天只介绍一种，就是B-tree。</p><p>不知道大家对这个词儿是不是熟悉啊 ，反正我面试基本都会问问……</p><p>需要先提的一件事是B树==B-树。所谓B-树，并不是B减树的意思，希望大家不要跟我一样土鳖……</p><p><img src="/images/blog/nosql_vs_sql/b-tree.jpg" alt="B Tree"></p><p>这就是一个最简单的B树，我们观察一下就会发现，其实B树的出发点很简单，既然磁盘寻道时间很多，那就减少它~~ 一次寻道就能够从磁盘取更多的数据就行了。</p><p>所以，它是以“数组”为单位，存储数据的，而数组，其实就是一片连续并且有界的空间。</p><p>数组本身很难扩展，而维护数组内有序，其实也是有一定代价的。而数组满了以后怎么办？这就是B树会做的事儿-<strong>分裂</strong></p><p>如果这里大家能够联想到另外一个东西，那就算学明白了~~ HBase其实就是一颗巨大的、分布式的B树。</p><p>其他容我最后吐槽~~</p><p>好了，我们稍微绕出去一点，分享一下B树是什么，主要目的实际上就是让大家回忆一下数据结构，这有有利于我们继续讲其他东西。</p><p>回到数据库，详细很多人都听过一个名词“层次数据库”，似乎这东西就是在上古时代的神器，现在则不见了踪影。</p><p>那么，这“层次数据库”到底是什么玩意儿呢？</p><p>我们来看一张图</p><p><img src="/images/blog/nosql_vs_sql/hierarchiacl_database.jpg" alt="Hierarchiacl Database"></p><p>抽象来看，层次模型其实就是这样的东西。</p><p>我再用小汽车来表述一下：一个小车由四扇玻璃，四个轮子，两个反光镜组成。</p><p>车有自己的属性，轮子有自己的属性，反光镜有自己的属性。</p><p>给大家举两个例子，相信大家应该可以立刻就明白，所谓的层次模型如果用Java代码来写的话，应该是什么样的。</p><p>Map套Map，每一个Map有一些固定的属性，比如这个Map的名字是什么？这个Map的属性是什么？</p><p>而这就是我们最开始用的数据库了。</p><p>非常简单，一个Map结构搞定所有需求。看起来世界大同了。</p><h2 id="下面，我们就来到1980年：-Know-SQL。知道SQL了。"><a href="#下面，我们就来到1980年：-Know-SQL。知道SQL了。" class="headerlink" title="下面，我们就来到1980年： Know SQL。知道SQL了。"></a>下面，我们就来到1980年： Know SQL。知道SQL了。</h2><p>为什么这么写？其实就是关系数据库是上世纪70年代发明的，而到了80年代，第一代全功能的关系数控System R由IBM发布。</p><p>所以，在80年代，我们才正式进入关系数据库模型。</p><p>相信，很多人都觉得自己了解关系模型，似乎每个人提到它，都说“对对对”绝对对。</p><p>因为这是有数学支持的，所以不应该怀疑。</p><p>可选，实际上如果大家了解科学发现的历史，我们就会发现，自从爱因斯坦把牛顿那又完美数学报纸的自洽理论踢出了神坛，数学自洽就再也不是一个真理的标准了。</p><p>而真理只有一个，哪个用户多，就是哪个~~~</p><p>那么，为什么关系模型最终赢得了比赛，而层次模型死掉了呢？</p><p>很简单，因为人类都是蠢蛋和傻瓜啊……哪个简单，容易用，就是哪个赢。</p><p>下面，我们就以一个例子俩看看，关系模型易用在哪里。</p><p>还是以车子为例。如果我要做这样一个查询：把厂里生产的所有汽车里面，左轮子供应商是DRDS的轮胎都找出来。</p><p>对于层次模型，我们的代码是：</p><p>遍历每一辆车（从车对象中找到左面的轮子，查看轮子的属性，是DRDS的留下，不是的丢弃）。</p><p>而如果是关系模型呢？ <code>select * from 轮子表 where 轮子位置 = &#39;左&#39; and 轮子供应商 = &#39;DRDS&#39;</code> ,就完成了。</p><p>我看了都觉得是个世界性的创举，不知道您是什么感觉？</p><p>好，那么下一步，我们来看看，关系模型将会怎么处理这条SQL。</p><p><img src="/images/blog/nosql_vs_sql/DRDS.jpg" alt="关系模型组织形式"></p><p>其实，用这一张图就可以表示一个最简单的关系模型了，基本上所有的数据库，都是这个组织形式。</p><p>最上面的额用户API就是执行的SQL和事务命令；中间的就是关系代数转换层和事务处理层；最后，最底层，是个KV存储。</p><p>啊？KV这不是NoSQL的概念么，你凭什么盗用它？</p><p>呵呵，谁盗用谁呢？还不一定呢。</p><p>先从最底层下看来，KV存储是什么？其实就是我们一开始说的“映射”结构。对应内存，可能有Hash和有序树结构，对应磁盘主要是btree树系和LSM树系。</p><p>我这里不展开说了，因为每个数据结构都有自己好玩的属性，讲起了太多。我们直接来聊聊关系代数引擎。这是数据库最关键的部分之一。</p><p>但其实从功能目标来说，并不是很复杂。</p><p><img src="/images/blog/nosql_vs_sql/relational_algebra_engines.jpg" alt="关系代数引擎"></p><p>这张图就是整个关系代数引擎所经过的步骤。</p><p>最原始的是SQL字符串。类似 <code>select * from tab where id = 1</code> ,它经过的过程叫做SQL解析，会生成一个AST抽象语法树。</p><p><img src="/images/blog/nosql_vs_sql/abstract_syntax_tree.jpg" alt="抽象语法树"></p><p>select被拆解为fromList/WhereClause等细碎的字串。</p><p>这个过程的主要作用是，作为计算机编写代码而言，我们更容易识别这种结构化的数据，而文档属于非结构化数据。有了这棵树，我们还需要再做一件事情，就是执行优化。它的入参是AST树+索引源信息。</p><p>索引源信息又是什么鬼？</p><p>要讲明白这个，得先看看关系模型和Map是怎么对应起来的。我用几张PPT来讲解一下。</p><p><img src="/images/blog/nosql_vs_sql/sql_step_by_step_1.jpg" alt="如何按照key找到对应的数据"></p><p>第一个SQL是 select * from tab where id = ? ，上面的那个则是一个表格。</p><p>如果我们用map来表示，可以表示成这样：</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">M<span class="function"><span class="title">ap</span>: key -&gt;</span> <span class="function"><span class="title">primaryKey</span>, value -&gt;</span> [pk,user_id,Name]</span><br></pre></td></tr></table></figure><p>也就是，以PK值作为Map的key，以一个包含了pk,user_id,Name的值的结构作为Map的value。（当然也可以只包含user_id,Name）。也OK~</p><p>有了这个map，我们只需要从AST里面取出id=？，得知id=0（假设），然后 map.get(0)，就可以拿到对应的user_id和Name数据了，加上输入的id=0这个数据，就可以返回了。</p><p>再来看另一个需求。</p><p>这里面，我们的查询条件发生了变化，不是id了，而是user_id。</p><p>而我们刚才只有一个Map : Map: key -&gt; primaryKey, value -&gt; [user_id,Name] ，我应该如何利用这个Map去找到所有符合要求的结果呢？</p><p>我能想到的第一种方式是，遍历Map里面的每一个Entry，取出每一个Entry以后，看看user_id == 我想要的值？如果不等于，丢弃，如果等于，返回。即可。</p><p>然而，这中方式带来的问题就是，如果我有1亿条记录，我就要做这件事情1亿次。明显O(N)效率太慢了。</p><p>怎么加快一下？</p><p>有需求就有人相应，于是，我们可以用一个空间换时间的法子。</p><p><img src="/images/blog/nosql_vs_sql/sql_step_by_step_2.jpg" alt="如何按照key找到对应的数据-二级索引"></p><p>看看上面的图，里面有增加了一个新的Map。 Map: key -&gt; user_id ,value -&gt; [id]</p><p>这个Map以user_id作为key，于是我们又可以愉快而高兴的用户第二个Map的get接口来获取所有符合要求的id列表。然后再根据这个符合要求的id列表，去查第一个Map，获得对应的数据了。</p><p>刚才介绍的这块，其实就是关系模型如何映射到Map（也就是KV模型）的关键方法了。</p><p>当然，还会有很多扩展性的方式和方法，不过这就不是今天的主题了。</p><p>这个数据比较小，只有三列，一个索引。如果我有十几个，甚至几十个索引的适合，我们会面对另一问题。</p><p><img src="/images/blog/nosql_vs_sql/sql_step_by_step_2.jpg" alt="如何按照key找到对应的数据-二级索引-name"></p><p>如果我有一个user_id的二级索引，又有一个Name的二级索引。我该选择哪一个作为查询用的索引呢？是不是我需要一种机制，来选择那个最“便宜”的索引？</p><p>这就是索引选择的过程，我们进行索引选择，就必然的需要知道每一个索引的区分高还是低（说白了，就是一个key对应的plist.size()少还是多）……</p><p>而这个索引的区分度高/低，就是所谓索引源信息的最简单模式。在真实的数据库中，还会有很多其他信息，也是索引的源信息，不过为了方便大家理解，简化一下。</p><p>有了索引源信息和AST树，我们就可以生成执行计划了。</p><p><img src="/images/blog/nosql_vs_sql/mysql_explain.jpg" alt="mysql explain"></p><p>这时候，再尝试看看这个，相信大家就大概能够猜到这里的东西所表示的含义了。</p><p>所以，很多事情呢不用去背，了解背后的原理，优化就是随手拈来的事儿了……</p><p>这里，我省略了事务步骤，这个更复杂。</p><h2 id="NO-SQL"><a href="#NO-SQL" class="headerlink" title="NO SQL!"></a>NO SQL!</h2><p>卧槽，豪言壮语，SQL数据库has gone，新时代来临了！</p><p>似乎一夜之间，这个世界就翻了天，facebook开源了cassandra，Hadoop、HBase横空出世，似乎这就是未来啊。</p><p>我们来看看知乎的问题</p><p><a href="http://www.zhihu.com/question/21288175" target="_blank" rel="noopener">互联网领域，传统的sql很力不从心，一些更具有针对性的nosql会越来与火，以后会不会出来各种强力nosql？</a></p><p>反正最雷我的一个问题大概是： 我们是一个新业务，想用NoSQL来提升开发效率，不知道cassandra和hbase应该选哪个？</p><p>看完以后，我真的觉得没办法好好做朋友了。</p><p>Digg采用Cassandra遭遇失败，工程副总裁离职，希望大家不是这个人。</p><p>No SQL！怎么来的？</p><p>这还是得从事物开说起来。</p><p>从第一代产品化的数据库在上世纪80年代开发完成以后，我们的数据库主要演进模型里面只有几个有限的里程碑，我目前能够记住的就这么积极事情。</p><ol><li>mvcc多版本并发控制</li><li>存储过程</li><li>各类OLAP的分析类引擎</li></ol><p>而，实际上大家心里都知道有一件事情它一定会发生，只是不知道什么时候会发生。这就是，分布式系统。</p><p>分布式系统，能够具有无限的扩张能力，按需伸缩，只要有钱，我们的系统就不会down，不会死。这种能力其实在上世纪80年代就深入人心了。还记得SUN公司提出的口号吗？</p><p>“网络就是计算机”</p><p>傻瓜都知道，未来一定是分布式系统的天下，单机系统还有什么玩头？</p><p>单机系统不应该是那待宰的羔羊吗？等着DRDS异军突起不就好了吗？</p><p>但是等啊等啊，30年过去了，还没有等等自己寿终正寝的那一天，反而似乎活的越来越好了。这是为什么？</p><p>理由很简单，技术没突破……</p><p>如果一个分布式系统做的跟单机系统一样方便，又能扩展，性能又好，那这个世界上早就没有单机系统了。而且，从上世纪80年代到21世界的前几年，我们实际上都不需要分布式系统。大部分的系统都是所谓“图书馆管理系统”，“客户关系管理系统”等等企业内部管理系统。</p><p>我们不需要很高并发，只需要容易操作就行乐。</p><p>那么，单机的关系数据库系统自然最容易操作。所以单机系统大行其道。</p><p>然而，云计算和互联网的时代到来了。我们服务的对象， 从顶天了几千人，一下子就变成了十几亿人，计算机要管理的数据量呈指数级别的飞速上涨，而我们却完全无法对用户数据做出准确预估。</p><p>这时候，扩展性，性能的要求就变得更为重要了，不开展业务挂了和开发难度少量上升，两个事情做权衡，想想大家都能like知道哪个更重要。</p><p>所以，我们要扩展！</p><p>然而，数据库却无法提供这样的扩展性，当年的淘宝也是用Oracle的，配置算不错的，也算是有小黑柜子……</p><p>然而，今天不火的网站，明天就有可能突然就火了，我们的用户数在一年内就会突破这个柜子的容量，折旧都来不及。</p><p>很明显，时代变了。</p><p>传统关系数据库，哪怕是RAC都不能满足我们队数据库扩展性的追求了。</p><p>这时候，肯定有人在想，这个有问题，我们就解决它啊。</p><p>这类技术就是Oracle Rac啊，mysql cluter啊这类玩具，他们希望能够不改变用户行为来实现扩展性。然而，做了好多年，发现玩不转。</p><p>为了支持更大的访问量和数据量，我们必然需要分布式数据库系统，而分布式系统有必然会面临对强一致性带来的延迟提高的问题，因为网络通信本身比单机内通信代价高很多，这种通信的代价就会直接增加系统单次提交的延迟。延迟提高会导致数据库锁持有时间变长，使得高冲突条件下分布式事务的性能不升反降（这个具体可以了解一下Amdahl定律），甚至性能距离单机数据库都还有明显的差距。</p><p>从上面的说明，我们可以发现，问题的关键并不是分布式事务做不出来，而是做出来了却没什么卵用。 数据库领域的高手们努力了40年，但至今还没有人能够很好解决这个问题，Goolge Spanner的开发负责人就经常在他的Blog上谈论延迟的问题，相信也是饱受这个问题的困扰。</p><p>这就是主要问题。</p><p>于是，有一群人认为，强一致性这就是看起不怎么靠谱，那彻底绕开这个问题是不是个更好的选择？他们发现确实有那么一些场景是不需要强一致性事务的，甚至连SQL都可以不要，最典型的就是日志流水的记录和分析这类的场景，而去掉了事务和SQQL，接口简单了，性能就更容易得到提升，扩展性也更容易实现，这就是NoSQL的起源。</p><p>他们喊出非常响亮的口号“No SQL！”，来标志着他们的时代到来。</p><h2 id="2005：-Not-only-SQL。不仅仅是SQL"><a href="#2005：-Not-only-SQL。不仅仅是SQL" class="headerlink" title="2005： Not only SQL。不仅仅是SQL"></a>2005： Not only SQL。不仅仅是SQL</h2><p>好吧，经过5年的忽悠，有很多人愿意相信NoSQL似乎确有其事，于是有一批先行者就开始探索各种玩法。</p><p><a href="http://www.lampchina.net/mod-news_do-show_id-8272.html" target="_blank" rel="noopener">Digg采用Cassandra遭遇失败，工程副总裁离职</a></p><p><img src="/images/blog/nosql_vs_sql/digg.jpg" alt="Digg副总裁离职"></p><p>点个蜡</p><p>玩着玩着，大家发现还是不靠谱，这样不行啊</p><p>这东西不就是让我们每个业务都把关系数据库重新实现一把么？让我们退回层次模型上去啊。</p><p>对于人类这种懒惰而笨拙的动物，开历史的倒车明显是不受待见的。</p><p>于是，有一批人站出来，说No什么SQL，还是得有数据库。</p><p>但是NoSQL开发者已经忽悠了那么多投资人的前，总得要有一个交代吧。所以，既然没有办法颠覆，咱们就共存吧。</p><p>什么NoSQL和SQL，大家一家人，各种发展就好了。这就是Not only SQL的来源。</p><p>NoSQL有哪些明确的场景呢？</p><p>比如HDFS比较火，于是就有人发现，哎，我们如果学google，也弄一个分布式的KV是不是也能火？我想，这就是某base最大的价值。</p><p>不过，在这个平缓期，还是能看到一些创新性的想法的。他们帮助数据库领域往前走了不大的一步。MongoDB是个不错的思路（我个人觉得）。</p><p>json代替了臃肿的xml成为一个小的标准。而且，这个上面做了很多索引，也是很聪明的做饭。借鉴了数据库的核心思路，这也算是共存了。其他的NoSQL也在往SQL上努力。比如Cassandra的cql，HBase的各类SQL引擎，其实都是对关系数据模型的一种妥协。</p><p>毕竟，NoSQL还没有好到能够颠覆整个生态。</p><h2 id="2013-No-SQL"><a href="#2013-No-SQL" class="headerlink" title="2013 No, SQL!"></a>2013 No, SQL!</h2><p>不，我们还是要关系数据库。</p><p>这就是我们现在的感觉。</p><p>经过了10年的折腾，我们还是发现，关系模型目前来说是最方便表达数据存储的语言。比其他都要方便的多。所以，还是妥协吧，于是，所有的NoSQL都想办法尝试支持关系数据库。</p><p>然而，回到初始，我们不就是因为关系数据库不能满足要求，所以才要做NoSQL的么？难道NoSQL弄个关系代数引擎，就能够做出魔法末？</p><p>其实，也不行。</p><p>模型上能够规避和腾挪的空间并不是很大。</p><p>最终，大家殊途同归，还是回到如何能够让关系数据库更具有扩展性，性能更好，这条道路上来，条条大路通罗马嘛~和气生财。</p><p>这就是NewSQL的来源。</p><p>DRDS也是NewSQL的一员，其实说实话，我挺有感触的，作为这么多年一直坚守在分布式数据库这个领域的人来说，能够坚持下来真的不容易，太多诱惑都在外面，最火的时候，连DBA都去学了各种NoSQL的运维技术。</p><p>然而，我们能够坚守，其实是因为我们懂得历史，也看得到现在。我们深刻的知道，科学就是承认自己并非无所不能。然后不断的往那无所不能的地方努力的一种精神。</p><p>一直以来，我们都尽可能的协助用户保留关系数据库的方便性，然后想办法告知用户，哪些地方目前还缺少技术突破，应该使用哪些工具来替代。</p><p>所以也算是积累了非常多的经验和工具。同时，我们也努力追求数据库领域的那个圣杯。更快的存取数据，可以按需扩缩以承载更大的访问量和更大的数据量，开发容易，硬件成本低。这些是大家梦寐以求在追求的动向，也是我们在追求的。虽不能至，吾心向往之。</p><p>最后，来聊聊阿里的技术选择。</p><p>其实，所有大公司似乎都在释放各种信号，xxx在用了什么系统了，xxx在用了什么系统了……</p><p>阿里可能不大一样，从内部来说，它也是一个生态系统，用户选择什么实际上主要都是由用户自己决定的。所以，阿里能够出现任何一种选择，只要能够解决问题即可。</p><p>他们就是工作不饱和和啥都试一试。</p><p>TDDL DRDS这套体系，只能说是目前用的最广的一套。原因也很简单，改变行为习惯少。</p><p>双11对DRDS这套体系来说，其实没有什么压力。我前几年的双十一虽然都在核心作战室，不过我一般的做法都是到了那里：“您辛苦了，您也是，大家辛苦了”，然后吃吃吃……</p><p>因为确实没有什么好担心的啊，没有不平稳的理由。</p><p>DRDS的能力更多体系在双十一开始和双十一结束。我们需要在那之前机器扩容，以及在那之后的机器缩容。这些才是DRDS的的核心能力。</p><p>上上次我的确很是紧张……因为新接了一个消息系统。这种削峰填谷的系统才是亚历山大啊……</p><p>其余的生活基本上就没啥了……更多是跟大家一样，也都是普通的功能开发而已。</p><p>好了，我的故事将完了。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p>问题1. 能说说DRDS和RDS的关系吗？</p><pre><code>一个偏重分布式，一个偏重单机</code></pre><p>问题2. 请问阿里的DRDS如何实现join sql语句来执行多表关联查询的？如何兼容单机存储的SQL？需要注意哪些坑？</p><pre><code>方案很多，其实如果大家对join有所了解，也就那么几种，hash/index nest loop/sort merge，没有什么魔法。http://coding-geek.com/how-databases-work/ 这个不错，我比较推荐。</code></pre><p>问题3. 请问schema less/free你怎么看？</p><pre><code>这俩似乎没见过拼一起哈，我分开。但是本质是同一个东西，我个人觉得有市场。不过能有多大，不知道。优势：业务模型更灵活。劣势：额外的空间占用。技术债也一定要还的......我清楚的记得当年我维护的一个cms系统，所有数据都是map。结果最后有一些诡异的数据不知道什么时候被塞到里面，然后最后也没有人知道是在哪里塞的，debug都很难找到。所以，一般来说，结合会更好一些。目前pg/mysql都开始支持json了，这东西其实只是工作量的问题，没有什么技术上的难度。</code></pre><p>问题4. 最近很多声音说不要在用户mongodb了，如何来看？</p><pre><code>这个就纯属于个人意见了啊...... 我个人不喜欢mongodb那帮人的嘴脸......[MongoDB核心贡献者：不是MongoDB不行，而是你不懂！](http://www.cnblogs.com/shanyou/archive/2012/11/17/2774344.html)然而，为什么会这样？还不是某些人为了骗分，默认配置特别激进...... 而开发者不会告诉你，如果改成安全配置，他们的性能没比MySQL强哪里去。一个存储引擎，至少10年才能稳定。前两天刚碰到一个游戏客户说某nosql数据文件损坏无法恢复，问我们有没有办法，我说，下次选择谨慎点......性能不是唯一的。这次请节哀。</code></pre><p>问题5. 海量，低延时（毫秒级），高并发（十万以上），目前关系型数据库是否有并存的方案？</p><pre><code>10w并发不算很高了，DRDS是你最好的选择。</code></pre><p>问题6. 非结构化数据，如文本，树图等，这些sql无法处理的，是否是用nosql更合理？</p><pre><code>非结构化数据也是一个重要的门类，一直都存在，以后也会存在，但是nosql为了宣传，把所有的东西都拉到自己阵营，这其实与其初衷已经违背了。twtter的图数据库其实也是依托mysql做的......你给我钱给我人，给我时间，我能汇编写任何东西。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> rdb </tag>
            
            <tag> nosql </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于LinkedHashMap的LRUCache实现</title>
      <link href="2015/07/16/linkedhashmap-based-lrucache-implementation/"/>
      <url>2015/07/16/linkedhashmap-based-lrucache-implementation/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/lru/lru-cache.png" alt="LRU Cache"></p><p>让面试者描述一下缓存算法，以及经典的缓存算法LRU的实现，是我在面试过程中经常会问到的题目。</p><p>能够当场说出LRU算法实现思路的人基本没有，甚至不少人都无法说清楚LRU是一个实现什么功能的算法。（现在肯专心研究数据结构和算法的人不多了）</p><a id="more"></a><p>那我们今天就说一下LRU算法，分两点来说一下。</p><ol><li>LRU算法是要做什么？</li><li>我们有没有什么简单的方法来实现LRU算法？</li></ol><h4 id="先说说第一点，LRU算法是要做什么？"><a href="#先说说第一点，LRU算法是要做什么？" class="headerlink" title="先说说第一点，LRU算法是要做什么？"></a>先说说第一点，LRU算法是要做什么？</h4><p>其实解释起来很简单，LRU就是<strong>Least Recently Used</strong>的缩写，翻译过来就是<strong>“最近最少使用”</strong>。也就是说LRU算法会将最近最少用的缓存移除，让给最新使用的缓存。而往往最常读取的，也就是读取次数最多的，所以利用好LRU算法，我们能够提供对热点数据的缓存效率，能够提高缓存服务的内存使用率。</p><h4 id="那如何来实现呢？"><a href="#那如何来实现呢？" class="headerlink" title="那如何来实现呢？"></a>那如何来实现呢？</h4><p>我们先来梳理一下，需要实现几个什么功能？</p><ol><li>限制缓存大小</li><li>查询出最近最晚用的缓存</li><li>给最近最少用的缓存做一个标识</li></ol><p>其实，实现的思路非常简单，就像下面这张图种描述的一样。</p><p><img src="/images/blog/lru/lru.png" alt="LRU"></p><p>今天我就利用<code>Java</code>的<code>LinkedHashMap</code>用非常简单的代码来实现基于LRU算法的Cache功能。</p><p>实现代码如下，加上<code>import</code>语句、注释和空行，也才不到20行的代码，就能够实现一个LRU算法的Cache：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单用LinkedHashMap来实现的LRU算法的缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, (<span class="keyword">float</span>) <span class="number">0.75</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Ignore;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LRUCacheTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LRUCache&lt;String, Integer&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cache.put(<span class="string">"k"</span> + i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String key = <span class="string">"k"</span> + RandomUtil.getNum(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"all cache :'&#123;&#125;'"</span>,cache);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="string">"k"</span> + <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"After running the LRU algorithm cache :'&#123;&#125;'"</span>, cache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> cache </tag>
            
            <tag> lru </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新安装Homebrew</title>
      <link href="2015/07/11/brew-reinstall/"/>
      <url>2015/07/11/brew-reinstall/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/homebrew.png" alt="Homebrew"></p><p>Mac Book用了几年之后，基本上其他的笔记本都已经看不上了，这个看不上不仅仅是设计感、硬件性价比等原因，更多是对工作效率的提高（尤其对于一个多年的互联网工作者），工作效率极有可能会成为一个公司成功或失败的一个不可忽视的原因。<a href="http://brew.sh/" target="_blank" rel="noopener">Homebrew</a>是我在Mac下一直使用的包管理系统，而且我觉得<a href="http://brew.sh/" target="_blank" rel="noopener">Homebrew</a>是提高工作效率的非常重要的组成部分。</p><a id="more"></a><p>前段时间给<a href="http://janehao.github.io/" target="_blank" rel="noopener">媳妇</a>也买了一台13寸的Mac Book Pro，当天就配置好了<a href="http://brew.sh/" target="_blank" rel="noopener">Homebrew</a>环境，但是不知怎么回事，今天在使用brew时，提示下面的错误信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsh: <span class="built_in">command</span> not found: brew</span><br></pre></td></tr></table></figure><p>进入brew的工作目录<code>/usr/local</code>一看，原来<code>/usr/local/bin</code>都没有了，难怪系统找不到brew这个命令。</p><p>那么怎么办？最简单的办法就是重新安装<a href="http://bash.sh/" target="_blank" rel="noopener">Homebrew</a>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><p>但是执行安装命令之后，发现提示brew已经安装了。</p><p>查看<code>/usr/local</code>目录发现，原来还有一个关键目录还在，就是<code>.git</code>目录。用过Git的同学都应知道，<code>.git</code>目录是你本地仓库的，存储了所有该仓库的信息和历史。安装脚本检测到有brew之前的信息，当然会提示你brew已经安装了。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ ls -al /usr/local/</span><br><span class="line">drwxrwxr-x  <span class="number">15</span> root      admin   <span class="number">510</span>B  <span class="number">7</span> <span class="number">11</span> <span class="number">23</span>:<span class="number">50</span> .</span><br><span class="line">drwxr-xr-<span class="symbol">x@</span> <span class="number">12</span> root      wheel   <span class="number">408</span>B  <span class="number">3</span>  <span class="number">7</span> <span class="number">22</span>:<span class="number">59</span> ..</span><br><span class="line">drwxr-xr-x  <span class="number">14</span> tonydeng  admin   <span class="number">476</span>B  <span class="number">7</span> <span class="number">12</span> <span class="number">00</span>:<span class="number">17</span> .git</span><br><span class="line">-rw-r--r--   <span class="number">1</span> tonydeng  admin   <span class="number">301</span>B  <span class="number">7</span> <span class="number">11</span> <span class="number">23</span>:<span class="number">50</span> .gitignore</span><br><span class="line">-rw-r--r--   <span class="number">1</span> tonydeng  admin   <span class="number">261</span>B  <span class="number">7</span> <span class="number">11</span> <span class="number">23</span>:<span class="number">50</span> .yardopts</span><br><span class="line">drwxr-xr-x   <span class="number">4</span> tonydeng  admin   <span class="number">136</span>B  <span class="number">7</span> <span class="number">11</span> <span class="number">23</span>:<span class="number">50</span> share</span><br></pre></td></tr></table></figure><p>好吧，找到问题关键了，那么我们就解决问题吧。</p><p>执行下面的命令，brew就回来了，又可以愉快的玩耍了~~</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">rm -rf <span class="regexp">/usr/</span>local<span class="regexp">/.git &amp;&amp; ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/install)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mac OSX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> brew </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPie:超爽的HTTP命令行客户端</title>
      <link href="2015/07/10/httpie-howto/"/>
      <url>2015/07/10/httpie-howto/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/httpie/httpie-logo.png" alt="HTTPie Logo"></p><p>之前在命令行下进行HTTP服务的调试和信息查看都是使用经典的<a href="http://curl.haxx.se/" target="_blank" rel="noopener">cURL</a>，不过前段时间发现一个交互更加友好的工具，就是<a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="noopener">HTTPie</a>。</p><a id="more"></a><p>先放一个HTTPie官方的一个HTTPie VS cURL的图给大家看看。</p><p><img src="/images/blog/httpie/httpie-vs-curl.png" alt="HTTPie VS cURL"></p><p>如果你经常需要用终端以非交互模式访问网络服务器（比如，下载文件、测试REST服务），可能你会选择的工具是wget或curl，通过大量的选项，这两种工具也都可以处理很多非交互网络访问的情况（比如，<a href="http://xmodulo.com/how-to-download-multiple-files-with-wget.html" target="_blank" rel="noopener">如何通过wget下载多个文件</a>，<a href="http://xmodulo.com/how-to-use-custom-http-headers-with-wget.html" target="_blank" rel="noopener">如何在wget中设置自定义的http头</a>，<a href="https://linux.cn/article-4957-1.html" target="_blank" rel="noopener">如何在curl中设置自定义的HTTP头</a>）。然而，除非你很精通这些繁复的语法细节，这些工具对于你来说，不过是简单的下载工具而已。</p><p>“Its goal is to make CLI interaction with web services as <strong>human-friendly</strong> as possible. It provides a simple http command that allows for sending arbitrary HTTP requests using <strong>a simple and natural syntax</strong>, and <strong>displays colorized output</strong>. “</p><p>HTTPie则在使用时的表现力、人性化做得比wget、curl好得多，就像在官网上宣传的那样，它追求的是人性化、简单自然的语法，以及彩色的输出。而且HTTPie还有一些不错的优点，比如对JSON的良好支撑、持久性会话等特性。</p><p>上面说了那么多，咱们废话少说，先来了解并展示一下<a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="noopener">HTTPie</a>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h5 id="Linux上安装"><a href="#Linux上安装" class="headerlink" title="Linux上安装"></a>Linux上安装</h5><p>Debian, Ubuntu或Linux Mint</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install httpie</span><br></pre></td></tr></table></figure><p>Fedora，CentOS/RHEL</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install httpie</span><br></pre></td></tr></table></figure><p>或者使用python的方式来安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  pip install --upgrade httpie</span><br></pre></td></tr></table></figure><h5 id="Mac-OSX"><a href="#Mac-OSX" class="headerlink" title="Mac OSX"></a>Mac OSX</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install httpie</span><br></pre></td></tr></table></figure><h3 id="安装开发版本"><a href="#安装开发版本" class="headerlink" title="安装开发版本"></a>安装开发版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mac OSX</span></span><br><span class="line">brew install httpie --HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python安装方式</span></span><br><span class="line">pip install --upgrade https://github.com/jkbrzt/httpie/tarball/master</span><br></pre></td></tr></table></figure><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><h4 id="定制头部"><a href="#定制头部" class="headerlink" title="定制头部"></a>定制头部</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http tonydeng.github.io/blog/2015/07/10/httpie-howto/ User-Agent:Xmodlo/1.0 Referer:http://tonydeng.github.io</span><br></pre></td></tr></table></figure><p>这个HTTP请求看起是这样。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/blog/2015/07/10/httpie-howto/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Host</span>: tonydeng.github.io</span><br><span class="line"><span class="attribute">Referer</span>: http://tonydeng.github.io</span><br><span class="line"><span class="attribute">User-Agent</span>: Xmodlo/1.0</span><br></pre></td></tr></table></figure><h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><p>你也可以把HTTPie作为文件下载器来使用。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">http tonydeng.github.io/blog/<span class="number">2015</span>/<span class="number">07</span>/<span class="number">10</span>/httpie-howto/ &gt; httpie-howto.html</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">http --download tonydeng.github.io/blog/<span class="number">2015</span>/<span class="number">07</span>/<span class="number">10</span>/httpie-howto/</span><br></pre></td></tr></table></figure><h4 id="使用其他HTTP方法"><a href="#使用其他HTTP方法" class="headerlink" title="使用其他HTTP方法"></a>使用其他HTTP方法</h4><p>除了默认的GET方法，你还可以使用其他方法（比如PUT、POST、DELETE、HEAD）</p><h5 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http</span> PUT tonydeng.github.io name=<span class="string">'Tony Deng'</span> email=<span class="string">'tonydeng<span class="variable">@email</span>.com'</span></span><br></pre></td></tr></table></figure><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http</span> -f POST tonydeng.github.io name=<span class="string">'Tony Deng'</span> email=<span class="string">'tonydeng<span class="variable">@email</span>.com'</span></span><br></pre></td></tr></table></figure><p><code>-f</code> 选项使http命令序列化数据字段，并将<code>Content-Type</code>设置为<code>application/x-www-form-urlencoded;charset=utf-8</code></p><p>这个HTTP POST请求看起这样：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span>: 41</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded; charset=utf-8</span><br><span class="line"><span class="attribute">Host</span>: tonydeng.github.io</span><br><span class="line"><span class="attribute">User-Agent</span>: HTTPie/0.9.2</span><br><span class="line"></span><br><span class="line">name=Tony+Deng&amp;email=tonydeng%40email.com</span><br></pre></td></tr></table></figure><h5 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">http</span> <span class="selector-tag">HEAD</span> <span class="selector-tag">tonydeng</span><span class="selector-class">.github</span><span class="selector-class">.io</span></span><br></pre></td></tr></table></figure><p><code>HEAD</code>这个方法只会让服务器返回<code>http response headers</code>。</p><p>这个命令结果如下：</p><h6 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h6><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Host</span>: tonydeng.github.io</span><br><span class="line"><span class="attribute">User-Agent</span>: HTTPie/0.9.2</span><br></pre></td></tr></table></figure><h6 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Accept-Ranges:</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">Access-Control-Allow-Origin:</span> <span class="string">*</span></span><br><span class="line"><span class="attr">Age:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">Cache-Control:</span> <span class="string">max-age=600</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">keep-alive</span></span><br><span class="line"><span class="attr">Content-Encoding:</span> <span class="string">gzip</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">36794</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/html;</span> <span class="string">charset=utf-8</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Wed,</span> <span class="number">15</span> <span class="string">Jul</span> <span class="number">2015</span> <span class="number">09</span><span class="string">:26:22</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">Expires:</span> <span class="string">Wed,</span> <span class="number">15</span> <span class="string">Jul</span> <span class="number">2015</span> <span class="number">09</span><span class="string">:36:22</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">Last-Modified:</span> <span class="string">Sun,</span> <span class="number">12</span> <span class="string">Jul</span> <span class="number">2015</span> <span class="number">11</span><span class="string">:32:15</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">GitHub.com</span></span><br><span class="line"><span class="attr">Vary:</span> <span class="string">Accept-Encoding</span></span><br><span class="line"><span class="attr">Via:</span> <span class="number">1.1</span> <span class="string">varnish</span></span><br><span class="line"><span class="attr">X-Cache:</span> <span class="string">MISS</span></span><br><span class="line"><span class="attr">X-Cache-Hits:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">X-Served-By:</span> <span class="string">cache-fra1227-FRA</span></span><br><span class="line"><span class="attr">X-Timer:</span> <span class="string">S1436952382.011631,VS0,VE99</span></span><br></pre></td></tr></table></figure><h4 id="JSON支持"><a href="#JSON支持" class="headerlink" title="JSON支持"></a>JSON支持</h4><p>HTTPie内置JSON的支持。事实上HTTPie默认使用的<code>Content-Type</code>就是<code>application/json</code>。因此，当你不指定<code>Content-Type</code>发送请求参数时，它们就会自动序列化为JSON对象。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http</span> POST tonydeng.github.io name=<span class="string">'Tony Deng'</span> email=<span class="string">'tonydeng<span class="variable">@email</span>.com'</span></span><br></pre></td></tr></table></figure><p>这个请求看起来就是这样：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span>: 52</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Host</span>: tonydeng.github.io</span><br><span class="line"><span class="attribute">User-Agent</span>: HTTPie/0.9.2</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "email": "tonydeng@email.com",</span><br><span class="line">    "name": "Tony Deng"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><p>HTTPie的另外一个友好特性就是输入重定向，你可以使用缓冲数据提供HTTP请求内容。例如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">http</span> <span class="selector-tag">POST</span> <span class="selector-tag">tonydeng</span><span class="selector-class">.github</span><span class="selector-class">.io</span> &lt; <span class="selector-tag">my_info</span><span class="selector-class">.json</span></span><br></pre></td></tr></table></figure><p>或:</p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">echo '&#123;<span class="string">"name"</span>: <span class="string">"Tony Deng"</span>,<span class="string">"email"</span>: <span class="string">"tonydeng@email.com"</span>&#125;' | <span class="type">http</span> POST tonydeng.github.io</span><br></pre></td></tr></table></figure><p>好了，暂时演示这么多吧，估计大家对HTTPie也有了一个基本的了解。如果大家想看看更多的HTTPie的特性和功能，可以看看<a href="https://github.com/jkbrzt/httpie/blob/master/README.rst" target="_blank" rel="noopener">HTTPie的README</a>，并且自己安装一个尝试使用一下。估计到时候你也和我一样对其爱不释手，立马抛弃了wget和curl。</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> http </tag>
            
            <tag> httpie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的各种Undo技巧</title>
      <link href="2015/07/08/how-to-undo-almost-anything-with-git/"/>
      <url>2015/07/08/how-to-undo-almost-anything-with-git/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/git-undo/git-undo.jpg" alt="git undo"></p><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>的<a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="noopener">How to undo (almost) anything with Git</a>这篇文章介绍了<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>使用中的各种Undo技巧。</p><p>任何版本控制系统中最有用的功能之一就是能够**”撤销（undo）”<strong>你之前的错误。在Git中</strong>“undo”**功能可能因为场景的不同而有些许的差异。</p><p>当你进行一个新的提交时，Git会保存你在这个特定时间点的快照到本地的仓库中，之后，你可以通过Git来回到你早期的某个版本。</p><p>我们来先看看一些需要你“撤销”的常见场景，你可以尝试使用Git来用最佳的方式来解决它。</p><a id="more"></a><h2 id="撤销已经推送到远程的变更"><a href="#撤销已经推送到远程的变更" class="headerlink" title="撤销已经推送到远程的变更"></a>撤销已经推送到远程的变更</h2><h4 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h4><p>你已经执行<strong>git push</strong>,把你的修改推送到远程的仓库，现在你意识到之前推送的<strong>commit</strong>中有一个有些错误，想要撤销该commit。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">revert </span>&lt;SHA&gt;</span><br></pre></td></tr></table></figure><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p><strong>git revert</strong> 会创建一个新的<strong>commit</strong>，它和指定SHA对应的<strong>commit</strong>是相反的（或者说是反转的）。如果原型的commit是“物质”，那么新的<strong>commit</strong>就是“反物质”。</p><p>任何从原来的commit里删除的内容都会再新的<strong>commit</strong>里被加回去，任何原来的<strong>commit</strong>中加入的内容都会在新的commit里被删除。</p><p>这是Git中最安全、最基本的撤销场景，因为它并不会改变历史。所以你现在可以<strong>git push</strong>新的<strong>“反转”commit</strong>来抵消你错误提交的commit。</p><h2 id="修正最后一个commit的消息"><a href="#修正最后一个commit的消息" class="headerlink" title="修正最后一个commit的消息"></a>修正最后一个commit的消息</h2><h4 id="场景：-1"><a href="#场景：-1" class="headerlink" title="场景："></a>场景：</h4><p>你在最后一条commit消息里有一个笔误，已经执行了 <strong>git commit -m ‘Fixes bug #42’</strong> ,但是在git push之前你意识到这个消息应该是**”Fix bug #43”**。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>你可以使用下面的命令：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">git </span><span class="string">commit </span><span class="built_in">--amend</span> -m <span class="string">'Fixes bug #43'</span></span><br></pre></td></tr></table></figure><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p><strong>git commit –amend</strong> 会用一个新的commit更新并替换最近的<strong>commit</strong>，这个新的<strong>commit</strong>会把任何修改内容和上一个<strong>commit</strong>的内容结合起来。如果当前没有提出任何修改，这个操作就只会把上次的<strong>commit</strong>重写一遍。</p><h2 id="撤销“本地的”修改"><a href="#撤销“本地的”修改" class="headerlink" title="撤销“本地的”修改"></a>撤销“本地的”修改</h2><h4 id="场景：-2"><a href="#场景：-2" class="headerlink" title="场景："></a>场景：</h4><p>一只喵从键盘上走过（在我们家就是儿子小手在键盘上划拉），无意中保存了修改，然后破坏了编辑器。不过，你还没有<strong>commit</strong>这些修改。你想要恢复被修改文件里的所有内容–就像上次<strong>commit</strong>的时候一模一样。</p><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">-- &lt;bad filename&gt;</span></span><br></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><code>git checkout</code>会把工作目录中的文件修改到Git之前记录的某个状态。你可以提供你想返回的分支或者特定的SHA，或者在缺省情况下，GIt会认为你希望checkout的是<strong>HEAD</strong>，当前checkout分支的<strong>最后一次commit</strong>。</p><p>记住： <strong>你用这种方法“撤销”的任何修改真的会完全消失</strong>。因为它们从来没有被提交过，所以之后Git也无法帮助我们恢复它们。你一定要确保自己了解在这个操作中丢掉的东西是什么？（也行可以利用<code>git diff</code>先确认一下）</p><h2 id="重置“本地的”修改"><a href="#重置“本地的”修改" class="headerlink" title="重置“本地的”修改"></a>重置“本地的”修改</h2><h4 id="场景：-3"><a href="#场景：-3" class="headerlink" title="场景："></a>场景：</h4><p>你在本地提交了一下东西（还没有push），但是所有这些东西都很糟糕，你希望撤销前面的三次提交（就像它们从来没有发生过一样）。</p><h4 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> &lt;<span class="keyword">last</span> good <span class="keyword">SHA</span>&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">reset</span> --hard &lt;<span class="built_in">last</span> good SHA&gt;</span><br></pre></td></tr></table></figure><h4 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h4><p><code>git reset</code>会把你的代码库历史返回到指定的SHA状态。这样就像是这些提交从来没有发生过。缺省情况下，<code>git reset</code>会保留工作目录。这样，提交是没有了，但是修改内容还在磁盘上。这是一种安全的选择，但通常我们会希望一步就“撤销”提交已经修改内容(这就是<code>--hard</code>选项的功能)。</p><h2 id="在撤销“本地修改”之后再恢复"><a href="#在撤销“本地修改”之后再恢复" class="headerlink" title="在撤销“本地修改”之后再恢复"></a>在撤销“本地修改”之后再恢复</h2><h4 id="场景：-4"><a href="#场景：-4" class="headerlink" title="场景："></a>场景：</h4><p>你提交了几个commit，然后用<code>git reset --hard</code>撤销了这些修改（见上一段），接着你又意识到：你希望还原这些修改！</p><h4 id="方法：-2"><a href="#方法：-2" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">ref</span>log</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git reset</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git checkout</span></span><br></pre></td></tr></table></figure><h4 id="原理：-3"><a href="#原理：-3" class="headerlink" title="原理："></a>原理：</h4><p><code>git reflog</code>对于恢复项目历史是一个超棒的方式。你可以恢复几乎任何（commit过的）东西。</p><p>你可以能熟悉<code>git log</code>命令，它会显示commit的列表。 git reflog也是类似的，不过它显示的是一个HEAD发生改变的时间列表。</p><p>一些注意事项：</p><ul><li>它涉及的只是HEAD的改变。在你切换分支、用git commit进行提交、以及用git reset撤销commit时，HEAD会发生改变，但当你使用<code>git checkout -- &lt;bad filename&gt;</code>撤销时，HEAD并不会发生改变。就像我们在上面说的，这些修改从来没有被提交过，因此reflog也无法帮助我们恢复它们。</li><li><code>git reflog</code>不会永远保持。Git会定期清理那些“用不到的”对象。不要指望几个月前的提交还一直躺着那里。</li><li>你的reflog就是你的，只是你的，你不能用<code>git reflog</code>来恢复另外一个开发者没有push过的commit。</li></ul><p><img src="/images/blog/git-undo/reflog.png" alt="git reflog"></p><p>那么…你如何来利用reflog来“恢复”之前“撤销”的commit呢？它取决于你想做到的到底是什么。</p><ul><li>如果你希望准确的恢复项目的历史到某个时间点，用<code>git reset --hard &lt;SHA&gt;</code></li><li>如果你希望重建工作目录里的一个或多个文件，让它们恢复到某个时间点的状态，用<code>git checkout &lt;SHA&gt; -- &lt;filename&gt;</code></li><li>如果你希望把这些commit里的某个重新提交到你的代码库里，用<code>git cherry-pick &lt;SHA&gt;</code></li></ul><h2 id="利用分支的另一种做法"><a href="#利用分支的另一种做法" class="headerlink" title="利用分支的另一种做法"></a>利用分支的另一种做法</h2><h4 id="场景：-5"><a href="#场景：-5" class="headerlink" title="场景："></a>场景：</h4><p>你进行了一些提交，然后意识到你开始checkout的是master分支。希望这些提交进入到另外一个特性（feature）分支。</p><h4 id="方法：-3"><a href="#方法：-3" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git branch <span class="built_in">feature</span></span><br><span class="line">git <span class="built_in">reset</span> --hard <span class="built_in">origin</span>/master</span><br><span class="line">git checkout <span class="built_in">feature</span></span><br></pre></td></tr></table></figure><h4 id="原理：-4"><a href="#原理：-4" class="headerlink" title="原理："></a>原理：</h4><p>你可能习惯用 <code>git checkout -b &lt;name&gt; </code>创建一个新的分支（这是创建新分支并马上checkout的流行捷径），但是你不希望马上切换分支。这里，<code>git branch feature</code>创建了一个叫做feature的新分支，并指向你最近的commit，但是还是让你checkout在master分支上。</p><p>下一步，在提交任何新的commit之前，用<code>git reset --hard</code> 把master分支倒回origin/master。不过别担心，那些commit还在feature分支里。</p><p>最后，用<code>git checkout </code>切换到新的feature分支，并让你最近所有的工作成果都完好无损。</p><h2 id="及时分支，省去繁琐"><a href="#及时分支，省去繁琐" class="headerlink" title="及时分支，省去繁琐"></a>及时分支，省去繁琐</h2><h4 id="场景：-6"><a href="#场景：-6" class="headerlink" title="场景："></a>场景：</h4><p>你在master分支的基础上创建一个feature分支，但是master分支已经滞后于origin/master很多。现在master分支已经和origin/master同步，你希望在feature上的提交从现在开始，而不是从滞后很多的地方开始。</p><h4 id="方法：-4"><a href="#方法：-4" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git checkout feature</span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git rebase <span class="literal">master</span></span><br></pre></td></tr></table></figure><h4 id="原理：-5"><a href="#原理：-5" class="headerlink" title="原理："></a>原理：</h4><p>要达到这个效果，你本来可以通过<code>git reset</code>（不加<code>--hard</code>，这样可以再磁盘上保留修改）和<code>git checkout -b &lt;new branch name&gt;</code>然后再重新提交修改，不过这样做的话，你就失去提交历史。我们有更好的办法。</p><p><code>git rebase master</code>会做下面的这些事情：</p><ol><li>首先它会找到你当前checkout的分支和master分支的共同祖先。</li><li>然后它reset当前checkout的分支到那个共同祖先 ，在一个临时保存区存放所有之前的提交。</li><li>然后它把当前checkout的分支提到master的末尾部分，并从临时保存区重新把存放的commit提交到master分支的最后 一个commit之后。</li></ol><h2 id="大量的撤销-恢复"><a href="#大量的撤销-恢复" class="headerlink" title="大量的撤销/恢复"></a>大量的撤销/恢复</h2><h4 id="场景：-7"><a href="#场景：-7" class="headerlink" title="场景："></a>场景：</h4><p>你向某个方向开始实现一个特性，但是你半路意识到另一个方案更好。你已经进行了十几次的提交，但是你现在只需要其中的一部分。你希望其他不需要的提交统统消失。</p><h4 id="方案：-1"><a href="#方案：-1" class="headerlink" title="方案："></a>方案：</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git rebase -i <span class="tag">&lt;<span class="name">carlier</span> <span class="attr">SHA</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="原理：-6"><a href="#原理：-6" class="headerlink" title="原理："></a>原理：</h4><p><code>-i</code> 参数会让rebase进入“交互模式”。它开始类似于签名讨论的rebase，但在重新进行任何提交之前，它会暂停下来并允许你详细的修改每一个提交。</p><p><code>rebase -i</code> 会打开你缺省的文本编辑器，里面列出候选的提交。</p><p><img src="/images/blog/git-undo/rebase_1.png" alt="rebase -i"></p><p>前面两列是键： 第一个是选定的命令，对应第二列里的SHA确定的commit。缺省情况下，<code>rebase -i</code>假定每个commit都要通过pick命令被运行。</p><p>要丢弃一个commit，只要在编辑器中删除那一行就行了。如果你不再需要项目里面的那几个错误的提交， 删除你想删除的几行。</p><p>如果你需要暴漏commit的内容，而是对commit消息进行编辑，你可以使用reword命令，将第一列的pick替换成reword（或者直接使用r）。有人会觉得再这里直接重写commit消息就行了，但是这样是不管用的（rebase -i会忽略SHA列前面的任何东西，它后面的文本只是用来帮助我们记住那一串SHA代表什么）。当你完成rebase -i的操作之后，你会被提示输入需要编写的任何commit消息。</p><p>如果你需要把两个commit合并在一起，你可以使用squash或者fixup命令。</p><p><img src="/images/blog/git-undo/rebase_edit.png" alt="rebase -i"></p><p>squash和fixup会“向上”合并（带有这两个命令的commit会被合并到他的签一个commit里）。上面的这个例子里，<code>0835fe2</code>和<code>6943e85</code>会合并成一个commit，<code>38f5c4c</code>和<code>af67f82</code>会被合并成另一个。</p><p>如果你选择了squash，Git会提示我们给新合并的commit一个新的commit消息； fixup则会把合并清单里的第一个commit的消息直接给新合并的commit。</p><p>在你保存并推出编辑器的时候，Git会按从顶部到底部的顺序运用你的commit。你可以通过在保存前修改commit顺序来改变运用的顺序。如果你愿意，你也可以同如下安排把<code>af67f82</code>和<code>0835fe2</code>合并到一起。</p><p><img src="/images/blog/git-undo/rebase_fixup.png" alt="rebase -i"></p><h2 id="修复更早期的commit"><a href="#修复更早期的commit" class="headerlink" title="修复更早期的commit"></a>修复更早期的commit</h2><h4 id="场景：-8"><a href="#场景：-8" class="headerlink" title="场景："></a>场景：</h4><p>你在一个更早期的commit里忘记了加入一个文件，如果更早的commit能包含这个忘记的文件就太棒了。你还没有push，但这个commit不是最近的，所以你还没法用commit –amend</p><h4 id="方法：-5"><a href="#方法：-5" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="comment">--squash &lt;SHA of the earlier commit&gt;</span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git rebase <span class="comment">--autosquash -i &lt;even earlier SHA&gt;</span></span><br></pre></td></tr></table></figure><h4 id="原理：-7"><a href="#原理：-7" class="headerlink" title="原理："></a>原理：</h4><p><code>git commit --squash </code>会创建一个新的commit，它带有一个commit消息，类似于squash! Earlier commit。(你也可以手工创建一个带有类似commit消息的commit，但是 commit –squash 可以帮你省下输入的工作)</p><p>如果你不想被提示为新合并的commit输入一条新的commit消息，你也可以利用 <code>git commit --fixup </code>。在这个情况下，你很有可能会用<code>commit --fixup</code>，因为你只是希望在rebase的适合，使用早期commit的commit消息。</p><p><code>rebase --autosquash -i</code> 会激活一个交互式的rebase编辑器，但是编辑器打开的适合，在commit清单里任何squash!和fixup！的commit都已经配对到目标commit上了。</p><p><img src="/images/blog/git-undo/rebase_autosquash.png" alt="rebase --autosquash -i"></p><p>在使用 <code>--squash</code> 和 <code>--fixup</code>的适合，你可能不记得想要修正的commit的SHA了（只是记得它是前面的第1个或者第5个commit）。你会发现Git的<code>^</code>和<code>~</code>操作符特别好用。<code>HEAD~</code>是HEAD的前一个commit。<code>HEAD~4</code>是HEAD往前第4个（或者一起算，倒数第5个commit）。</p><h2 id="停止追踪一个文件"><a href="#停止追踪一个文件" class="headerlink" title="停止追踪一个文件"></a>停止追踪一个文件</h2><h4 id="场景：-9"><a href="#场景：-9" class="headerlink" title="场景："></a>场景：</h4><p>你偶然把application.log加到代码库里了，现在每次你运行应用，Git都会报告在application.log里有未提交的修改。你把 *.log放到了.gitignore文件里，可文件还是在代码库里，你怎样才能让Git“撤销”对这个文件的追踪呢？</p><h4 id="方法：-6"><a href="#方法：-6" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">rm</span> --cached application.<span class="keyword">log</span></span><br></pre></td></tr></table></figure><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h4><p>虽然.gitignore会阻止Git追踪文件的修改，甚至不关注文件是否存在，但这只是针对那些以前从来没有追踪过的文件。一旦有个文件被加入并提交了，Git就会持续关注改文件的改变。类似地，如果你利用<code>git add -f</code>来强制或覆盖了.gitignore，Git还会持续追踪改变的情况。之后你就不必用-f来添加这个文件了。</p><p>如果你希望从Git的追踪对象中删除那个本应忽略的文件，<code>git rm --cached</code>会从追踪对象中删除它，但让文件在磁盘上保持原封不动。因为现在它已经被忽略了，你在<code>git status</code>里就不会再看见这个文件，也不回再偶然提交该文件的修改了。</p><p>这就是如何在Git里撤销任何操作的方法。要了解更多关于本文中用到的Git命令，请查看下面的相关文档。</p><ul><li><a href="http://git-scm.com/docs/git-checkout" target="_blank" rel="noopener">checkout</a></li><li><a href="http://git-scm.com/docs/git-commit" target="_blank" rel="noopener">commit</a></li><li><a href="http://git-scm.com/docs/git-rebase" target="_blank" rel="noopener">rebase</a></li><li><a href="http://git-scm.com/docs/git-reflog" target="_blank" rel="noopener">reflog</a></li><li><a href="http://git-scm.com/docs/git-reset" target="_blank" rel="noopener">reset</a></li><li><a href="http://git-scm.com/docs/git-revert" target="_blank" rel="noopener">revert</a></li><li><a href="http://git-scm.com/docs/git-rm" target="_blank" rel="noopener">rm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> undo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux TCP/IP调优</title>
      <link href="2015/05/25/linux-tcpip-tuning/"/>
      <url>2015/05/25/linux-tcpip-tuning/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/tcpip.png" alt="tcp/ip"></p><p>根据 <a href="http://yangrong.blog.51cto.com/6945369/1321594" target="_blank" rel="noopener">杨云1028的Blog</a> 整理的参数的说明：</p><a id="more"></a><h2 id="Linux内核参数注释"><a href="#Linux内核参数注释" class="headerlink" title="Linux内核参数注释"></a>Linux内核参数注释</h2><h3 id="固定文件的内核参数"><a href="#固定文件的内核参数" class="headerlink" title="固定文件的内核参数"></a>固定文件的内核参数</h3><h4 id="下列文件所在目录："><a href="#下列文件所在目录：" class="headerlink" title="下列文件所在目录："></a>下列文件所在目录：</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/proc/</span>sys<span class="regexp">/net/i</span>pv4<span class="regexp">/</span></span><br></pre></td></tr></table></figure><p>| 名称 | 默认值 | 建议值 |描述 |<br>|–|–|–|–|–|<br>|<strong>tcpsyn_retries</strong>|5|1|<strong>对于一个新建连接，内核要发送多少个SYN连接请求才决定放弃</strong>。不应该大于255,默认值是5，对应于180毫秒左右时间。（对于大负载而物理通信良好的网络来说，这个值偏高，可以修改为2。这个值仅仅是针对对外的连接，对进来的连接，是由<strong>tcp_retries1</strong>决定）|<br>|<strong>tcp_synack_retries</strong>|5|1|<strong>对于远端的连接请求SYN，内核会发送SYN+ACK数据包，以确认收到上一个SYN连接请求包</strong>。这是所谓的三次握手机制的第二个步骤。这里决定内核再放弃之前所发送出的SYN+ACK数目。不应该大于255，默认值是5，对应于180秒左右时间。|<br>|<strong>tcp_keepalive_time</strong>|7200|600|<strong>TCP发送keepalive探测消息的间隔时间（秒）</strong>，用于确认TCP连接是否有效。防止两边建立连接但不发送数据的攻击。|<br>|<strong>tcp_keepalive_probes</strong>|9|3|T<strong>CP发送keepalive探测消息的间隔时间（秒）</strong>，用于确认TCP连接是否有效。|<br>|<strong>tcp_keepalive_intvl</strong>|74|15|<strong>探测消息未获得响应时，重发该消息的间隔时间（秒）</strong>。默认值为75秒。 (对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)|<br>|<strong>tcp_retries1</strong>|3|3|<strong>放弃回应一个TCP连接请求前﹐需要进行多少次重试</strong>。RFC 规定最低的数值是3|<br>|<strong>tcp_retries2</strong>|15|5|<strong>在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试</strong>。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)|<br>|<strong>tcp_orphan_retries</strong>|7|3|<strong>在近端丢弃TCP连接之前﹐要进行多少次重试。</strong>默认值是7个﹐相当于 50秒 - 16分钟﹐视 RTO 而定。如果您的系统是负载很大的web服务器﹐那么也许需要降低该值﹐这类 sockets 可能会耗费大量的资源。另外参的考tcp_max_orphans。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3)|<br>|<strong>tcp_fin_timeout</strong>|60|2|<strong>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间</strong>。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒|<br>|<strong>tcp_max_tw_buckets</strong>|180000|36000|<strong>系统在同时所处理的最大 timewait sockets 数目</strong>。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐不过﹐如果网络条件需要比默认值更多﹐则可以提高它(或许还要增加内存)。(事实上做NAT的时候最好可以适当地增加该值)|<br>|<strong>tcp_tw_recycle</strong>|0|1|<strong>打开快速 TIME-WAIT sockets 回收</strong>。除非得到技术专家的建议或要求﹐请不要随意修改这个值。(做NAT的时候，建议打开它)|<br>|<strong>tcp_tw_reuse</strong>|0|1|<strong>表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接</strong>(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)|<br>|<strong>tcp_max_orphans</strong>|8192|32768|<strong>系统所能处理不属于任何进程的TCP sockets最大数量</strong>。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制。如果内存大更应该增加这个值。(这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000)|<br>|<strong>tcp_abort_on_overflow</strong>|0|0|<strong>当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false</strong>。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)|<br>|<strong>tcp_synookies</strong>|0|1|<strong>只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用</strong>。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。|<br>|<strong>tcp_stdurg</strong>|0|0|<strong>使用 TCP urg pointer 字段中的主机请求解释功能</strong>。大部份的主机都使用老旧的 BSD解释，因此如果您在 Linux 打开它﹐或会导致不能和它们正确沟通。|<br>|<strong>tcp_max_syn_backlog</strong>|1024|16384|<strong>对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目</strong>。对于超过 128Mb 内存的系统﹐默认值是 1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。警告﹗假如您将此值设为大于 1024﹐最好修改include/net/tcp.h里面的TCP_SYNQ_HSIZE﹐以保持TCP_SYNQ_HSIZE<em>16(SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲(而不是解决)这种攻击，是用一个基本队列处理正常的完全连接应用(Connect()和Accept() )，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施(例如Syn-Cookies/Caches)联合应用时，能够比较有效的缓解小规模的SYN Flood攻击(事实证明)|<br>|<strong>tcp_window_scaling</strong>|1|1|<strong>该文件表示设置tcp/ip会话的滑动窗口大小是否可变</strong>。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp/ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp/ip滑动窗口大小增大数个数量级，从而提高数据传输的能力(RFC 1323)。（对普通地百M网络而言，关闭会降低开销，所以如果不是高速网络，可以考虑设置为0）|<br>|<strong>tcp_timestamps</strong>|1|1|<strong>Timestamps 用在其它一些东西中﹐可以防范那些伪造的 sequence 号码</strong>。一条1G的宽带线路或许会重遇到带 out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 ‘旧封包’。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。)|<br>|<strong>tcp_sack</strong>|1|1|<strong>使用 Selective ACK﹐它可以用来查找特定的遗失的数据报— 因此有助于快速恢复状态</strong>。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。)|<br>|<strong>tcp_fack</strong>|1|1|<strong>打开FACK拥塞避免和快速重传功能</strong>。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效)[<strong>这个是TCP连接靠谱的核心功能</strong>]|<br>|<strong>tcp_dsack</strong>|1|1|<strong>允许TCP发送”两个完全相同”的SACK</strong>。|<br>|<strong>tcp_ecn</strong>|0|0|<strong>TCP的直接拥塞通告功能</strong>。|<br>|<strong>tcp_reordering</strong>|3|6|<strong>TCP流中重排序的数据报最大数量</strong>。 (一般有看到推荐把这个数值略微调整大一些,比如5)|<br>|<strong>tcp_retans_collapse</strong>|1|0|<strong>对于某些有bug的打印机提供针对其bug的兼容性</strong>。(一般不需要这个支持,可以关闭它)|<br>|<strong>tcp_wmem：mindefaultmax</strong>| 4096 16384 131072 | 8192 131072 16777216 |<strong>发送缓存设置</strong>。 <strong>min</strong>：为TCP socket预留用于发送缓冲的内存最小值。每个tcp socket都可以在建议以后都可以使用它。默认值为4096(4K)。 <strong>default</strong>：为TCP socket预留用于发送缓冲的内存数量，默认情况下该值会影响其它协议使用的net.core.wmem_default 值，一般要低于net.core.wmem_default的值。默认值为16384(16K)。 <strong>max</strong>: 用于TCP socket发送缓冲的内存最大值。该值不会影响net.core.wmem_max，”静态”选择参数SO_SNDBUF则不受该值影响。默认值为131072(128K)。（对于服务器而言，增加这个参数的值对于发送数据很有帮助,在我的网络环境中,修改为了51200 131072 204800）|<br>|<strong>tcprmem：mindefaultmax</strong>| 4096 87380 174760 | 32768 131072 16777216 |<strong>接收缓存设置</strong>。同tcp_wmem|<br>|<strong>tcp_mem：mindefaultmax</strong>|根据内存计算| 786432 1048576 1572864 |<strong>low</strong>：当TCP使用了低于该值的内存页面数时，TCP不会考虑释放内存。即低于此值没有内存压力。(理想情况下，这个值应与指定给 tcp_wmem 的第 2 个值相匹配 - 这第 2 个值表明，最大页面大小乘以最大并发请求数除以页大小 (131072 300 / 4096)。 ) <strong>pressure</strong>：当TCP使用了超过该值的内存页面数量时，TCP试图稳定其内存使用，进入pressure模式，当内存消耗低于low值时则退出pressure状态。(理想情况下这个值应该是 TCP 可以使用的总缓冲区大小的最大值 (204800 300 / 4096)。 ) <strong>high</strong>：允许所有tcp sockets用于排队缓冲数据报的页面量。(如果超过这个值，TCP 连接将被拒绝，这就是为什么不要令其过于保守 (512000 * 300 / 4096) 的原因了。 在这种情况下，提供的价值很大，它能处理很多连接，是所预期的 2.5 倍；或者使现有连接能够传输 2.5 倍的数据。 我的网络里为192000 300000 732000) *</em>一般情况下这些值是在系统启动时根据系统内存数量计算得到的<strong>。|<br>|**tcp_app_win</strong>|31|31|<strong>保留max(window/2^tcp_app_win, mss)数量的窗口由于应用缓冲</strong>。当为0时表示不需要缓冲。|<br>|<strong>tcp_adv_win_scale</strong>|2|2|<strong>计算缓冲开销</strong>。 bytes/2^tcp_adv_win_scale(如果tcp_adv_win_scale &gt; 0)或者bytes-bytes/2^(-tcp_adv_win_scale)(如果tcp_adv_win_scale BOOLEAN&gt;0)|<br>|<strong>tcp_low_latency</strong>|0|0|<strong>允许 TCP/IP 栈适应在高吞吐量情况下低延时的情况；这个选项一般情形是的禁用</strong>。(但在构建Beowulf 集群的时候,打开它很有帮助)|<br>|<strong>tcp_westwood</strong>|0|0|<strong>启用发送者端的拥塞控制算法，它可以维护对吞吐量的评估，并试图对带宽的整体利用情况进行优化；对于 WAN 通信来说应该启用这个选项</strong>。|<br>|<strong>tcp_bic</strong>|0|0|<strong>为快速长距离网络启用 Binary Increase Congestion</strong>；这样可以更好地利用以 GB 速度进行操作的链接；对于 WAN 通信应该启用这个选项。|<br>|<strong>ip_forward</strong>|0|1|<strong>NAT必须开启IP转发支持，把该值写1</strong>|<br>|<strong>ip_local_port_range:minmax</strong>| 32768 61000 | 1024 65000 |<strong>表示用于向外连接的端口范围</strong>，默认比较小，这个范围同样会间接用于NAT表规模。|<br>|<strong>ip_conntrack_max</strong>|65535|65535|<strong>系统支持的最大ipv4连接数，默认65536（事实上这也是理论最大值）</strong>，同时这个值和你的内存大小有关，如果内存128M，这个值最大8192，1G以上内存这个值都是默认65536|</p><h4 id="下列文件所在目录：-1"><a href="#下列文件所在目录：-1" class="headerlink" title="下列文件所在目录："></a>下列文件所在目录：</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/proc/</span>sys<span class="regexp">/net/i</span>pv4<span class="regexp">/netfilter/</span></span><br></pre></td></tr></table></figure><p>|名称|默认值|建议值|描述|<br>|–|–|–|–|–|<br>|<strong>ip_conntrack_max</strong>|65535|65535|<strong>系统支持的最大ipv4连接数，默认65536</strong>（事实上这也是理论最大值），同时这个值和你的内存大小有关，如果内存128M，这个值最大8192，1G以上内存这个值都是默认65536,这个值受/proc/sys/net/ipv4/ip_conntrack_max限制|<br>|<strong>ip_conntrack_tcp_timeout_established</strong>|432000|180|<strong>已建立的tcp连接的超时时间，默认432000，也就是5天</strong>。影响：这个值过大将导致一些可能已经不用的连接常驻于内存中，占用大量链接资源，从而可能导致NAT ip_conntrack: table full的问题。建议：对于NAT负载相对本机的 NAT表大小很紧张的时候，可能需要考虑缩小这个值，以尽早清除连接，保证有可用的连接资源；如果不紧张，不必修改|<br>|<strong>ip_conntrack_tcp_timeout_time_wait</strong>|120|120|<strong>time_wait状态超时时间，超过该时间就清除该连接</strong>|<br>|<strong>ip_conntrack_tcp_timeout_close_wait</strong>|60|60|<strong>close_wait状态超时时间，超过该时间就清除该连接</strong>|<br>|<strong>ip_conntrack_tcp_timeout_fin_wait</strong>|120|120|<strong>fin_wait状态超时时间，超过该时间就清除该连接</strong>|</p><h4 id="下列文件所在目录：-2"><a href="#下列文件所在目录：-2" class="headerlink" title="下列文件所在目录："></a>下列文件所在目录：</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/proc/</span>sys<span class="regexp">/net/</span>core<span class="regexp">/</span></span><br></pre></td></tr></table></figure><p>|名称|默认值|建议值|描述|<br>|–|–|–|–|–|<br>|<strong>netdev_max_backlog</strong>|1024|16384|<strong>每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目</strong>，对重负载服务器而言，该值需要调高一点。|<br>|<strong>somaxconn</strong>|128|16384**|用来限制监听(LISTEN)队列最大数据包的数量，超过这个数量就会导致链接超时或者触发重传机制<strong>。web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。对繁忙的服务器,增加该值有助于网络性能|<br>|**wmem_default</strong>|129024|129024|<strong>默认的发送窗口大小</strong>（以字节为单位）|<br>|<strong>rmem_default</strong>|129024|129024|<strong>默认的接收窗口大小</strong>（以字节为单位）|<br>|<strong>rmem_max</strong>|129024|873200|<strong>最大的TCP数据接收缓冲</strong>|<br>|<strong>wmem_max</strong>|129024|873200|<strong>最大的TCP数据发送缓冲</strong>|</p><h3 id="修改内核参数的方法"><a href="#修改内核参数的方法" class="headerlink" title="修改内核参数的方法"></a>修改内核参数的方法</h3><ol><li>使用 <code>echo value</code> 方式直接追加到文件中。 如 <code> echo &quot;1&quot; &gt; /proc/sys/net/ipv4/tcp_syn_retries</code> ，但是这种方式设备重启后，会恢复成默认值。</li><li>把参数添加到 <code> /etc/sysctl.conf</code> 中，然后执行 <code>sysctl -p</code> 使参数生效。这种方式是永久有效的。</li></ol><h3 id="生产环境常用的参数"><a href="#生产环境常用的参数" class="headerlink" title="生产环境常用的参数"></a>生产环境常用的参数</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">net.ipv4.tcp_syn_retries</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_synack_retries</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_keepalive_time</span> = <span class="number">600</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_keepalive_probes</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_keepalive_intvl</span> =<span class="number">15</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_retries2</span> = <span class="number">5</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_fin_timeout</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_max_tw_buckets</span> = <span class="number">36000</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_tw_recycle</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_tw_reuse</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_max_orphans</span> = <span class="number">32768</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_syncookies</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_max_syn_backlog</span> = <span class="number">16384</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_wmem</span> = <span class="number">8192</span> <span class="number">131072</span> <span class="number">16777216</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_rmem</span> = <span class="number">32768</span> <span class="number">131072</span> <span class="number">16777216</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_mem</span> = <span class="number">786432</span> <span class="number">1048576</span> <span class="number">1572864</span></span><br><span class="line"><span class="attr">net.ipv4.ip_local_port_range</span> = <span class="number">1024</span> <span class="number">65000</span></span><br><span class="line"><span class="attr">net.ipv4.ip_conntrack_max</span> = <span class="number">65536</span></span><br><span class="line"><span class="attr">net.ipv4.netfilter.ip_conntrack_max</span>=<span class="number">65536</span></span><br><span class="line"><span class="attr">net.ipv4.netfilter.ip_conntrack_tcp_timeout_established</span>=<span class="number">180</span></span><br><span class="line"><span class="attr">net.core.somaxconn</span> = <span class="number">16384</span></span><br><span class="line"><span class="attr">net.core.netdev_max_backlog</span> = <span class="number">16384</span></span><br></pre></td></tr></table></figure><p>不同的生产环境需要优化的参数基本差不多，只是值有相应的变化。 具体的优化值要参考应用场景，这儿所列出的只是常用的优化参数，是否适合可以参考上面的参数说明描述。</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p><a href="http://www.sudops.com/linux-kernel-tcp-ip-sysctl-optimize.html" target="_blank" rel="noopener">sudops网站提供的优化例子</a>：</p><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">net.core.netdev_max_backlog = <span class="number">400000</span></span><br><span class="line"><span class="meta">#该参数决定了，网络设备接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</span></span><br><span class="line"></span><br><span class="line">net.core.optmem_max = <span class="number">10000000</span></span><br><span class="line"><span class="meta">#该参数指定了每个套接字所允许的最大缓冲区的大小</span></span><br><span class="line"></span><br><span class="line">net.core.rmem_default = <span class="number">10000000</span></span><br><span class="line"><span class="meta">#指定了接收套接字缓冲区大小的缺省值（以字节为单位）。</span></span><br><span class="line"></span><br><span class="line">net.core.rmem_max = <span class="number">10000000</span></span><br><span class="line"><span class="meta">#指定了接收套接字缓冲区大小的最大值（以字节为单位）。</span></span><br><span class="line"></span><br><span class="line">net.core.somaxconn = <span class="number">100000</span></span><br><span class="line"><span class="meta">#Linux kernel参数，表示socket监听的backlog(监听队列)上限</span></span><br><span class="line"></span><br><span class="line">net.core.wmem_default = <span class="number">11059200</span></span><br><span class="line"><span class="meta">#定义默认的发送窗口大小；对于更大的 BDP 来说，这个大小也应该更大。</span></span><br><span class="line"></span><br><span class="line">net.core.wmem_max = <span class="number">11059200</span></span><br><span class="line"><span class="meta">#定义发送窗口的最大大小；对于更大的 BDP 来说，这个大小也应该更大。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.conf.all.rp_filter = <span class="number">1</span></span><br><span class="line">net.ipv4.conf.<span class="keyword">default</span>.rp_filter = <span class="number">1</span></span><br><span class="line"><span class="meta">#严谨模式 1 (推荐)</span></span><br><span class="line"><span class="meta">#松散模式 0</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_congestion_control = bic</span><br><span class="line"><span class="meta">#默认推荐设置是 htcp</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_window_scaling = <span class="number">0</span></span><br><span class="line"><span class="meta">#关闭tcp_window_scaling</span></span><br><span class="line"><span class="meta">#启用 RFC 1323 定义的 window scaling；要支持超过 64KB 的窗口，必须启用该值。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_ecn = <span class="number">0</span></span><br><span class="line"><span class="meta">#把TCP的直接拥塞通告(tcp_ecn)关掉</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_sack = <span class="number">1</span></span><br><span class="line"><span class="meta">#关闭tcp_sack</span></span><br><span class="line"><span class="meta">#启用有选择的应答（Selective Acknowledgment），</span></span><br><span class="line"><span class="meta">#这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）；</span></span><br><span class="line"><span class="meta">#（对于广域网通信来说）这个选项应该启用，但是这会增加对 CPU 的占用。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = <span class="number">10000</span></span><br><span class="line"><span class="meta">#表示系统同时保持TIME_WAIT套接字的最大数量</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = <span class="number">8192</span></span><br><span class="line"><span class="meta">#表示SYN队列长度，默认1024，改成8192，可以容纳更多等待连接的网络连接数。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span></span><br><span class="line"><span class="meta">#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_timestamps = <span class="number">1</span></span><br><span class="line"><span class="meta">#开启TCP时间戳</span></span><br><span class="line"><span class="meta">#以一种比重发超时更精确的方法（请参阅 RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span></span><br><span class="line"><span class="meta">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span></span><br><span class="line"><span class="meta">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">10</span></span><br><span class="line"><span class="meta">#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_time = <span class="number">1800</span></span><br><span class="line"><span class="meta">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为30分钟。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_probes = <span class="number">3</span></span><br><span class="line"><span class="meta">#如果对方不予应答，探测包的发送次数</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_intvl = <span class="number">15</span></span><br><span class="line"><span class="meta">#keepalive探测包的发送间隔</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_mem</span><br><span class="line"><span class="meta">#确定 TCP 栈应该如何反映内存使用；每个值的单位都是内存页（通常是 4KB）。</span></span><br><span class="line"><span class="meta">#第一个值是内存使用的下限。</span></span><br><span class="line"><span class="meta">#第二个值是内存压力模式开始对缓冲区使用应用压力的上限。</span></span><br><span class="line"><span class="meta">#第三个值是内存上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的 BDP 可以增大这些值（但是要记住，其单位是内存页，而不是字节）。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_rmem</span><br><span class="line"><span class="meta">#与 tcp_wmem 类似，不过它表示的是为自动调优所使用的接收缓冲区的值。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_wmem = <span class="number">30000000</span> <span class="number">30000000</span> <span class="number">30000000</span></span><br><span class="line"><span class="meta">#为自动调优定义每个 socket 使用的内存。</span></span><br><span class="line"><span class="meta">#第一个值是为 socket 的发送缓冲区分配的最少字节数。</span></span><br><span class="line"><span class="meta">#第二个值是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值。</span></span><br><span class="line"><span class="meta">#第三个值是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.ip_local_port_range = <span class="number">1024</span> <span class="number">65000</span></span><br><span class="line"><span class="meta">#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_max=<span class="number">204800</span></span><br><span class="line"><span class="meta">#设置系统对最大跟踪的TCP连接数的限制</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_slow_start_after_idle = <span class="number">0</span></span><br><span class="line"><span class="meta">#关闭tcp的连接传输的慢启动，即先休止一段时间，再初始化拥塞窗口。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.route.gc_timeout = <span class="number">100</span></span><br><span class="line"><span class="meta">#路由缓存刷新频率，当一个路由失败后多长时间跳到另一个路由，默认是300。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syn_retries = <span class="number">1</span></span><br><span class="line"><span class="meta">#在内核放弃建立连接之前发送SYN包的数量。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = <span class="number">1</span></span><br><span class="line"><span class="meta"># 避免放大攻击</span></span><br><span class="line"></span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = <span class="number">1</span></span><br><span class="line"><span class="meta"># 开启恶意icmp错误消息保护</span></span><br><span class="line"></span><br><span class="line">net.inet.udp.checksum=<span class="number">1</span></span><br><span class="line"><span class="meta">#防止不正确的udp包的攻击</span></span><br><span class="line"></span><br><span class="line">net.ipv4.conf.<span class="keyword">default</span>.accept_source_route = <span class="number">0</span></span><br><span class="line"><span class="meta">#是否接受含有源路由信息的ip包。参数值为布尔值，1表示接受，0表示不接受。</span></span><br><span class="line"><span class="meta">#在充当网关的linux主机上缺省值为1，在一般的linux主机上缺省值为0。</span></span><br><span class="line"><span class="meta">#从安全性角度出发，建议你关闭该功能。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tcp/ip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CP命令不为人知的特殊使用</title>
      <link href="2015/05/14/cp-usage/"/>
      <url>2015/05/14/cp-usage/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/linux-command.jpg" alt="linux command"></p><p>就算如司空见惯的 <strong>cp</strong> 命令，某些用法我们或许也不了解。</p><a id="more"></a><h2 id="快速复制"><a href="#快速复制" class="headerlink" title="快速复制"></a>快速复制</h2><p>说是快速复制，实则只是少打几个字而已。该复制利用 <strong>Shell</strong> 的花括号展开特性。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp file&#123;1,2&#125;</span><br></pre></td></tr></table></figure><h2 id="保留文件属性"><a href="#保留文件属性" class="headerlink" title="保留文件属性"></a>保留文件属性</h2><p>在复制时，可以保留源文件的时间戳、模式、所有权等属性。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp --preserve=timestamps file file1 <span class="comment"># 保留时间戳</span></span><br><span class="line">cp --preserve=mode file file1       <span class="comment"># 保留模式</span></span><br><span class="line">cp --preserve=ownership file file1  <span class="comment"># 保留所有权</span></span><br><span class="line">cp -p file file1                    <span class="comment"># 包括上述三者</span></span><br></pre></td></tr></table></figure><h2 id="创建软-硬链接"><a href="#创建软-硬链接" class="headerlink" title="创建软/硬链接"></a>创建软/硬链接</h2><p>在 <strong>Linux</strong> 下，创建软/硬链接本是 <strong>ln</strong> 的专职，但 <strong>cp</strong> 却可以代劳。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp -l file file1 <span class="comment"># 创建硬链</span></span><br><span class="line">cp -s file file1 <span class="comment"># 创建软链接</span></span><br></pre></td></tr></table></figure><h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><p>仅当源文件比目标文件更新时才复制。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp -u file1 file2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSX下编译Tengine+SSL错误的解决办法</title>
      <link href="2015/03/09/tengine-ssl-osx-make-error/"/>
      <url>2015/03/09/tengine-ssl-osx-make-error/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/nginx-ssl.jpg" alt="Nginx+SSL"></p><p><a href="http://tengine.taobao.org/" target="_blank" rel="noopener">Tengine</a>（Tengine是由淘宝基于<a href="http://nginx.org/" target="_blank" rel="noopener">Nignx</a>开发的Web服务器）是一个非常要用的Web服务器，我基本上在测试及生产环境中都使用它来代替Nginx。不过之前都是在Linux下来编译和安装，这几天由于要调试之前已经离职的工程师的PHP项目，需要在自己的Mac配置一个可以使用的PHP开发调试环境。于是开始了OSX下的PHP+Nginx之旅。</p><a id="more"></a><p>由于我不太希望用<strong>brew</strong>来安装PHP和Tengine，还是使用最原始的编译安装的方式。安装PHP时基本上没有遇到任何问题，在安装Tengine时却碰到这样的错误。</p><p>原来的编译的参数</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./configure</span> <span class="params">--prefix=/usr/local/tengine-2</span>.1.0 <span class="params">--with-http_ssl_module</span></span><br></pre></td></tr></table></figure><p>configure阶段没有任何问题，但是在进行make编译的时候，却报了下面的错误。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">src<span class="regexp">/core/</span>ngx_crypt.<span class="string">c:</span><span class="number">82</span>:<span class="number">5</span>: <span class="string">error:</span> <span class="string">'MD5_Init'</span> is <span class="string">deprecated:</span> first deprecated <span class="keyword">in</span> OS X <span class="number">10.7</span> [-Werror,-Wdeprecated-declarations]</span><br><span class="line">    ngx_md5_init(&amp;md5);</span><br><span class="line">    ^</span><br></pre></td></tr></table></figure><p>MD5的其他函数，比如<strong>MD5_Update</strong>,<strong>MD5_Final</strong>也在其中。</p><p>万能的google大神告知了错误的原因及解决方案，由于之前在编译参数中加入对ssl的支持，需要使用MD5算法，但是由于Nginx和OpenSSL的兼容性问题，某些api已经被建议废弃了，编译时不停的报警告并最终错误，无法编译完成。</p><p>其实解决办法也挺简单的，在编译时加上<code>--with-cc-opt=&quot;-Wno-deprecated-declarations&quot;</code>参数即可。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./configure</span> <span class="params">--prefix=/usr/local/tengine-2</span>.1.0 <span class="params">--with-http_ssl_module</span> <span class="params">--with-cc-opt=</span><span class="string">"-Wno-deprecated-declarations"</span></span><br></pre></td></tr></table></figure><p>错误的原因及解决办法参见：</p><p><a href="http://trac.nginx.org/nginx/ticket/587" target="_blank" rel="noopener">http://trac.nginx.org/nginx/ticket/587</a></p><p><a href="https://www.ruby-forum.com/topic/2193556#1012378" target="_blank" rel="noopener">https://www.ruby-forum.com/topic/2193556#1012378</a></p>]]></content>
      
      
      <categories>
          
          <category> Mac OSX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> osx </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go项目的目录结构</title>
      <link href="2015/02/10/golang-project-directory-structure/"/>
      <url>2015/02/10/golang-project-directory-structure/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/GoLangKulani.jpg" alt="Golang"></p><p>项目结构如何来组织，一般的开发语言都没有在语言层面上做规定，基本上都是在项目生命周期管理工具上对项目结构来做规定。不过<code>Go</code>在这方面做了相应地规定，这样可以在<code>Go</code>的开发者中保持一致。</p><a id="more"></a><h2 id="一个Go项目在GOPATH下，会有如下三个目录"><a href="#一个Go项目在GOPATH下，会有如下三个目录" class="headerlink" title="一个Go项目在GOPATH下，会有如下三个目录"></a>一个Go项目在GOPATH下，会有如下三个目录</h2><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./bin</span></span><br><span class="line"><span class="string">./pkg</span></span><br><span class="line"><span class="string">./src</span></span><br></pre></td></tr></table></figure><p>其中，<code>bin</code>存放编译后的可执行文件；<code>pkg</code>存放编译后的包文件；<code>src</code>存放项目源文件。</p><p>一般，<code>bin</code>和<code>pkg</code>目录可以不创建，<code>go</code>命令会自动创建(如 <code>go install</code>)，只需要创建<code>src</code>目录即可。</p><p>对于<code>pkg</code>目录，曾有人问：“我把<code>Go</code>中的包放入<code>pkg</code>下面，怎么不行啊？“，他时直接将Go包得源文件放入<code>pkg</code>中，这显然是不对的。<code>pkg</code>中的文件是<code>Go</code>编译生成的，而不是手动放进去的。（一般文件后缀名为<code>.a</code>）。</p><p>对于<code>src</code>目录，存放源文件，<code>Go</code>中的源文件以包（<code>package</code>）的形式组织。通常，新建一个包就在<code>src</code>目录中新建一个文件夹。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>比如：我新建一个项目<code>test</code>，开始的目录结构如下：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">test/</span><br><span class="line"><span class="string">|-- src/</span></span><br></pre></td></tr></table></figure><p>为了编译方便，我在其中加入了一个<code>install</code>文件，目录结构如下：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">test/</span><br><span class="line">|<span class="comment">-- install</span></span><br><span class="line">`<span class="comment">-- src/</span></span><br></pre></td></tr></table></figure><p>其中<code>install</code>的内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -f install ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'install must be run within its container folder'</span> 1&gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">CURDIR=`<span class="built_in">pwd</span>`</span><br><span class="line">OLDGOPATH=<span class="string">"<span class="variable">$GOPATH</span>"</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="string">"<span class="variable">$CURDIR</span>"</span></span><br><span class="line"></span><br><span class="line">gofmt -w src</span><br><span class="line"></span><br><span class="line">go install <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="string">"<span class="variable">$OLDGOPATH</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'finished'</span></span><br></pre></td></tr></table></figure><p>之所以加上这个<code>install</code>，而不用配置<code>GOPATH</code>（避免新增一个<code>GO</code>项目就要往<code>GOPATH</code>中添加一个路径）</p><p>接下来，增加一个包： <code>config</code>和<code>main</code>程序。目录结构如下：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">test/</span><br><span class="line">|-- install</span><br><span class="line">`-- src/</span><br><span class="line">    |-- config</span><br><span class="line">    |   `-- config.go</span><br><span class="line">    `-- test</span><br><span class="line">        `-- main.go</span><br></pre></td></tr></table></figure><p>注意，<code>config.go</code>中的<code>package</code>名称最好和目录<code>config</code>一致，而文件名可以随意。<code>main.go</code>表示**<code>main</code>包**，文件名建议为<code>main.go</code>。（注：不一致时，生成的<code>.a</code>文件和目录名一致，这样，在<code>import</code>时，应该是目录名，而引用包时，需要包名。例如：目录为<code>myconfig</code>，包名为<code>config</code>，则生成的静态包文件是<code>myconfig.a</code>，引用该包:<code>import &quot;myconfg&quot;</code>,使用包中成员：<code>config.LoadConfig()</code>）</p><p><code>config.go</code>和<code>main.go</code>的代码如下：</p><h3 id="config-go代码："><a href="#config-go代码：" class="headerlink" title="config.go代码："></a><code>config.go</code>代码：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-go代码："><a href="#main-go代码：" class="headerlink" title="main.go代码："></a><code>main.go</code>代码：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"config"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    config.LoadConfig()</span><br><span class="line">    fmt.Println(<span class="string">"Hello,GO!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，在项目根目录执行<code>./install</code></p><p>这时候的目录结构如下：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">test</span><br><span class="line">|<span class="comment">-- bin</span></span><br><span class="line">|   `<span class="comment">-- test</span></span><br><span class="line">|<span class="comment">-- install</span></span><br><span class="line">|<span class="comment">-- pkg</span></span><br><span class="line">|   `<span class="comment">-- linux_amd64</span></span><br><span class="line">|       `<span class="comment">-- config.a</span></span><br><span class="line">`<span class="comment">-- src</span></span><br><span class="line">    |<span class="comment">-- config</span></span><br><span class="line">    |   `<span class="comment">-- config.go</span></span><br><span class="line">    `<span class="comment">-- test</span></span><br><span class="line">        `<span class="comment">-- main.go</span></span><br></pre></td></tr></table></figure><p>其中<code>config.a</code>是包<code>config</code>编译后生成的；<code>bin/test</code>是生成的可执行的二进制文件。</p><p>这是可以执行：<code>bin/test</code>。 输出结果为”<code>Hello,GO!</code>“</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><ol><li><p>包可以有多层目录，比如<code>net/http</code>包，表示源文件再<code>src/net/http</code>目录下，不过源文件中的包名是最后一个目录的名字，比如<code>http</code>。 而在<code>import</code>包是，必须完整的路径，比如: <code>import &quot;net/http&quot;</code></p></li><li><p>有时候会见到<code>local import</code>(不建议使用)，语法类似这样：</p></li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./config"</span></span><br></pre></td></tr></table></figure><p>当代码有这样的语句是，很多时候都会见到类似的错误：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">local <span class="keyword">import</span> <span class="string">"./config"</span> in non-local <span class="keyword">package</span></span><br></pre></td></tr></table></figure><blockquote><p>我所了解的这种导入方式的使用是：当写入一个简单地测试脚本，想要使用<code>go run</code>命令时，可以使用这种导入方式。</p></blockquote><p>比如上面的例子，把<code>test/main.go</code>移到<code>src</code>目录中，<code>test</code>目录删除，修改<code>main.go</code>中的<code>import &quot;config&quot;</code>为<code>import &quot;./config&quot;</code>，然后可以在src目录下执行： <code>go run main.go</code></p><p>可见，<code>local import</code>不依赖<code>$GOPATH</code></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于稳定</title>
      <link href="2015/01/19/about-the-stability/"/>
      <url>2015/01/19/about-the-stability/</url>
      
        <content type="html"><![CDATA[<p>为什么大部分的人都喜欢稳定呢？</p><p>比如想要一份稳定的工作，考公务员，进国企，端铁饭碗。</p><p>稳定不是平衡，稳定也不是持久，稳定的科学定义是对<strong>外界干扰的抵抗能力</strong>。</p><p>换而言之，稳定不关乎状态的好坏，<strong>稳定只关乎是否能够保持原来的状态</strong>，哪怕这个状态并不是那么理想。</p><a id="more"></a><h3 id="我们来看看下面的三个小球。"><a href="#我们来看看下面的三个小球。" class="headerlink" title="我们来看看下面的三个小球。"></a>我们来看看下面的三个小球。</h3><p><img src="/images/blog/stability/tree_ball_1.jpg" alt="稳定的三个小球"></p><p>这三个小球是三种<strong>平衡</strong>的状态。</p><p>左边这个小球是“稳定”的，如果它被挪动一定距离，只要这段距离不是太远，它都能够恢复原状。</p><p>中间这个小球无所谓稳定不稳定，如果它被挪动一定距离，它可以在新的地方安居乐业。</p><p>右边这个小球是不稳定的，哪怕稍微轻轻的碰一下，它也会一路滑落，再也回不到最初的地方。</p><h3 id="为什么左边的小球稳定呢？"><a href="#为什么左边的小球稳定呢？" class="headerlink" title="为什么左边的小球稳定呢？"></a>为什么左边的小球稳定呢？</h3><p>因为它的能量最小。它所处在所有可能的位置中最低的那个位置，所以重力势能最小。一旦它被扰动，只可能被扰动到重力势能更高的地方，因为没有比它现在的位置重力势能更低的地方。这样，只要外界干扰一去除，在重力的作用下，小球就会自动回到原来的平衡位置，所以我们说它使最稳定的。它不需要任何外部能量，单靠自己的重力就能够保持再这个位置。</p><p>右边的小球是不稳定的，一点点风吹草动就能让它万劫不复。从左边到右边，它需要付出大量的努力才能达到现在的位置。为了保持这样的位置，它还必须要持续的输入外部能量来抵抗任何可能的扰动。换言之，它必须枕戈待旦，一直抗争不止，否则，就会从这个位置滑落。</p><h3 id="那这个和人们喜不喜欢稳定有什么关系呢？"><a href="#那这个和人们喜不喜欢稳定有什么关系呢？" class="headerlink" title="那这个和人们喜不喜欢稳定有什么关系呢？"></a>那这个和人们喜不喜欢稳定有什么关系呢？</h3><p>如果你觉得自己稳定，自己不需要任何努力就可以保持现在的位置，那是因为你就处在<strong>最小能量</strong>状态。你不努力，你也不会下落，也没有什么后果，那并不是因为你不会下落，只是因为你已经到了<strong>极低点</strong>。没错，我说的是<strong>极低点</strong>，而不是<strong>最低点</strong>。</p><p><img src="/images/blog/stability/two_ball_1.jpg" alt="two ball"></p><p><strong>所有动物生而平等，但有些动物比其他动物更平等</strong>。也许你的极低点，比很多人的极高点还要搞。也许你意识不到，<strong>你生来就有的，却有可能是别人苦苦追寻的</strong>。也许你会明白，<strong>你拼命追赶的，却也不过是别人的起点</strong>。</p><p>我不觉得<strong>向上爬</strong>就一定是好的，我更不觉得“人往高处走，水往低处流”这句话是有道理的。</p><p><strong>我只是觉得，这样的“稳定”无形中是一个牢笼，是一个束缚。哪怕你自己想出去看看，有时候也会被自己的重力压垮，自己又把自己拉回原来的位置。</strong></p><p><strong>“稳定”意味着失去了改变的可能性</strong>，不管这个改变是好的还是坏的。“稳定”有好处，因为它杜绝了变坏的可能；但是稳定也有坏处，因为它把变化的可能也一并屏蔽了。是利大于弊，还是弊大于利，需要你自己掂量。</p><p>我个人觉得，人生的路那么宽，又有那么多的可能，有意或无意的把自己束缚在“稳定”的这一洼盆地里，或多或少有坐井观天之嫌。多走走，多看看，扯起风帆去看看真正的大海，哪怕需要多付出很多的力气，哪怕有遇到风暴的可能，也胜过舒服的躺在“稳定”的避风港里。</p><p><img src="/images/blog/stability/one_ball_1.jpg" alt="image"></p><p>当有一天，你克服了“稳定”的枷锁，克服了自己的懒惰和惯性，一番苦战之后，终于站在不稳定的极高点。你也许会觉得，剩下的人生就是一片坦途了。</p><p>但是人生不是二维的，你要面临的问题太多太多了。</p><p><img src="/images/blog/stability/one_ball_2.jpg" alt="image"></p><p>也许，你会发现，一个方向的峰顶，只不过是另一个方向的谷底。前面的路还有太长太长。</p><p><img src="/images/blog/stability/one_ball_3.jpg" alt="image"></p><p>终于有一天，你回发现，原来生活是这样的。起起伏伏，曲曲折折，又是陷入谷底，有时又柳暗花明。</p><p>知道了生活的现实，却依然愿意走出“稳定”的小绿洲，踏上那荆棘满地却又风景如画的路途，我觉得这才是真正的勇敢和乐观。</p>]]></content>
      
      
      <categories>
          
          <category> 生活感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用HTML5的应用缓存</title>
      <link href="2015/01/13/using-html5-application-cache/"/>
      <url>2015/01/13/using-html5-application-cache/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/manifest.png" alt="manifest"></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> <a href="https://html5.org/" target="_blank" rel="noopener">HTML5</a> 提供一种 <strong>应用缓存</strong> 机制，使得基于web的应用程序可以离线运行。开发者可以使用 Application Cache (AppCache) 接口设定浏览器缓存的数据并使得数据离线有效。 在处于离线状态时，即使用户点击刷新按钮，应用也能正常加载与工作。</p><p>使用应用缓存可以得到以下益处：</p><ul><li>离线浏览: 用户可以在离线状态下浏览网站内容。</li><li>更快的速度: 因为数据被存储在本地，所以速度会更快.</li><li>减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源。</li></ul><a id="more"></a><h1 id="应用缓存如何工作"><a href="#应用缓存如何工作" class="headerlink" title="应用缓存如何工作"></a>应用缓存如何工作</h1><h2 id="开启应用缓存"><a href="#开启应用缓存" class="headerlink" title="开启应用缓存"></a>开启应用缓存</h2><p>若想为应用开启应用缓存，你需要在应用页面中的 <html> 元素上增加 manifest 特性，请看下面的例子：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"example.appcache"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>manifest 特性与 <strong>缓存清单(cache manifest)</strong> 文件关联，这个文件包含了浏览器<strong>需要为你的应用缓存的资源(文件)列表</strong>。</p><p>你应当在每一个意图缓存的页面上添加 <strong>manifest</strong> 特性。浏览器不会缓存不带有<strong>manifest</strong> 特性的页面，除非这个页面已经被写在清单文件内的列表里了。你没有必要添加所有你意图缓存的页面的清单文件，浏览器会将用户访问过的并带有 manifest 特性的所有页面添加进应用缓存中。</p><h2 id="加载文档"><a href="#加载文档" class="headerlink" title="加载文档"></a>加载文档</h2><p>使用了应用缓存机制以后加载文档的顺序是这样的：</p><ul><li>如果应用缓存存在，浏览器直接从缓存中加载文档与相关资源，不会访问网络。这会提升文档加载速度。</li><li>浏览器检查清单文件列出的资源是否在服务器上被修改。</li><li>如果清单文件被更新了, 浏览器会下载新的清单文件和相关的资源。 这都是在后台执行的，基本不会影响到webapp的性能。</li></ul><p>下面详细描述了加载文档与更新应用缓存的流程：</p><ol><li>当浏览器访问一个包含 manifest 特性的文档时，如果应用缓存不存在，浏览器会加载文档，然后获取所有在清单文件中列出的文件，生成应用缓存的第一个版本。</li><li>对该文档的后续访问会使浏览器直接从应用缓存(而不是服务器)中加载文档与其他在清单文件中列出的资源。此外，浏览器还会向 window.applicationCache 对象发送一个 checking 事件，在遵循合适的 HTTP 缓存规则前提下，获取清单文件。</li><li>如果当前缓存的清单副本是最新的，浏览器将向 applicationCache 对象发送一个 noupdate 事件，到此，更新过程结束。注意，如果你在服务器修改了任何缓存资源，同时也应该修改清单文件，这样浏览器才能知道它需要重新获取资源。</li><li>如果清单文件已经改变，文件中列出的所有文件—也包括通过调用 applicationCache.add() 方法添加到缓存中的那些文件—会被获取并放到一个临时缓存中，遵循适当的 HTTP 缓存规则。对于每个加入到临时缓存中的文件，浏览器会向 applicationCache 对象发送一个 progress 事件。如果出现任何错误，浏览器会发送一个 error 事件，并暂停更新。</li><li>一旦所有文件都获取成功，它们会自动移送到真正的离线缓存中，并向  applicationCache 对象发送一个 cached 事件。鉴于文档早已经被从缓存加载到浏览器中，所以更新后的文档不会重新渲染，直到页面重新加载(可以手动或通过程序).</li></ol><h1 id="存储位置与清除离线缓存"><a href="#存储位置与清除离线缓存" class="headerlink" title="存储位置与清除离线缓存"></a>存储位置与清除离线缓存</h1><p>在 Chrome 中，你可以在设置中选择 「清除浏览器数据…」 或访问 <a href="chrome://appcache-internals">chrome://appcache-internals</a> 来清除缓存。</p><p>Safari 在设置中有一个类似的”清空缓存” 选项，但是需要重启浏览器后才能生效。</p><p>在 Firefox 中，离线缓存数据与 Firefox 配置文件是分开存储的—紧挨着硬盘缓存：</p><ul><li>Windows Vista/7: C:\Users&lt;username&gt;\AppData\Local\Mozilla\Firefox\Profiles&lt;salt&gt;.<profile name>\OfflineCache</li><li>Mac/Linux: /Users/<username>/Library/Caches/Firefox/Profiles/<salt>.<profile name>/OfflineCache</li></ul><p>应用缓存可以变成废弃的。如果从服务器上移除一个应用的清单文件，浏览器将会清除所有清单中列出的应用缓存，并向 applicationCache 对象发送一个「obsolete」事件。这将使得应用缓存的状态变为 OBSOLETE。</p><h1 id="缓存清单文件"><a href="#缓存清单文件" class="headerlink" title="缓存清单文件"></a>缓存清单文件</h1><h2 id="引用一个缓存清单文件"><a href="#引用一个缓存清单文件" class="headerlink" title="引用一个缓存清单文件"></a>引用一个缓存清单文件</h2><p>web 应用中的 manifest 特性可以指定为缓存清单文件的相对路径或一个绝对 URL(绝对 URL 必须与应用同源)。缓存清单文件可以使用任意扩展名，但传输它的 MIME 类型必须为 text/cache-manifest。</p><p>Apache配置对manifest支持，在根目录或应用的同级目录下的**.htaccess**中加入下面的配置</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">AddType <span class="type">text</span>/<span class="keyword">cache</span>-manifest .appcache</span><br></pre></td></tr></table></figure><p>Nginx配置对manifest支持，在<strong>conf/mime.types</strong>中加入下面的配置</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">text</span>/<span class="keyword">cache</span>-manifest                  appcache manifest;</span><br></pre></td></tr></table></figure><h2 id="缓存清单文件中的记录"><a href="#缓存清单文件中的记录" class="headerlink" title="缓存清单文件中的记录"></a>缓存清单文件中的记录</h2><p>缓存清单文件是一个纯文本文件，它列出了所有浏览器应该缓存起来的资源，以便能够离线访问。资源使用 URI 来标识。在缓存清单文件中列出的所有记录必须拥有相同的协议、主机名与端口号。</p><h1 id="示例-1：一个简单的缓存清单文件"><a href="#示例-1：一个简单的缓存清单文件" class="headerlink" title="示例 1：一个简单的缓存清单文件"></a>示例 1：一个简单的缓存清单文件</h1><p>下面是一个简单的缓存清单文件，example.appcache，适用于一个虚拟的网站 <a href="http://www.example.com./" target="_blank" rel="noopener">www.example.com。</a></p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"><span class="meta"># v1 - 2011-08-13</span></span><br><span class="line"><span class="meta"># This is a comment.</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.example.com/index.html</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.example.com/header.png</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.example.com/blah/blah</span></span><br></pre></td></tr></table></figure><p>一个缓存清单文件可以包含三段内容 (CACHE， NETWORK， 和 FALLBACK， 下面详细讨论)。 在上面的例子中，没有段落标题，因此所有数据行都认为是属于显式 (CACHE) 段落，这意味着浏览器应该在应用缓存中缓存所有列出的资源。资源可以使用绝对或者相对 URL 来指定(例如 index.html)。</p><p>上面例子中的注释 「v1」很有必要存在。只有当清单文件发生变化时，浏览器才会去更新应用缓存。如果你要更改缓存资源(比如说，你使用了一张新的 header.png 图片)，你必须同时修改清单文件中的内容，以便让浏览器知道它们需要更新缓存。你可以对清单文件做任何改动，但大家都认同的最佳实践则是修正版本号。</p><blockquote><p>重要：不要在清单文件中指定清单文件本身，否则将无法让浏览器得知清单文件有新版本出现。</p></blockquote><h2 id="缓存清单文件中的段落：-CACHE，-NETWORK，与-FALLBACK"><a href="#缓存清单文件中的段落：-CACHE，-NETWORK，与-FALLBACK" class="headerlink" title="缓存清单文件中的段落： CACHE， NETWORK，与 FALLBACK"></a>缓存清单文件中的段落： CACHE， NETWORK，与 FALLBACK</h2><p>清单文件可以分为三段： CACHE， NETWORK，与 FALLBACK.</p><p><strong>CACHE:</strong><br>    这是缓存文件中记录所属的默认段落。在 CACHE: 段落标题后(或直接跟在 CACHE MANIFEST 行后)列出的文件会在它们第一次下载完毕后缓存起来。</p><p><strong>NETWORK:</strong><br>    在 NETWORK: 段落标题下列出的文件是需要与服务器连接的白名单资源。所有类似资源的请求都会绕过缓存，即使用户处于离线状态。可以使用通配符。</p><p><strong>FALLBACK:</strong><br>    FALLBACK: 段指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI—第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。</p><p>CACHE， NETWORK， 和 FALLBACK 段落可以以任意顺序出现在缓存清单文件中，并且每个段落可以在同一清单文件中出现多次。</p><h1 id="示例-2：-一个复杂且完整的缓存清单文件"><a href="#示例-2：-一个复杂且完整的缓存清单文件" class="headerlink" title="示例 2： 一个复杂且完整的缓存清单文件"></a>示例 2： 一个复杂且完整的缓存清单文件</h1><p>下面是一个更加完整的缓存清单文件，适用于一个虚拟的网站 <a href="http://www.example.com：">www.example.com：</a></p><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"><span class="meta"># v1 2011-08-14</span></span><br><span class="line"><span class="meta"># This is another comment</span></span><br><span class="line">index.html</span><br><span class="line">cache.html</span><br><span class="line">style.css</span><br><span class="line">image1.png</span><br><span class="line"></span><br><span class="line"><span class="meta"># Use from network if available</span></span><br><span class="line">NETWORK:</span><br><span class="line">network.html</span><br><span class="line"></span><br><span class="line"><span class="meta"># Fallback content</span></span><br><span class="line">FALLBACK:</span><br><span class="line">/ fallback.html</span><br></pre></td></tr></table></figure><p>该例子使用了 NETWORK 与 FALLBACK 段落，指明了 network.html 页面必须始终从网络获取，fallback.html 页面应该作为后备资源来提供(例如，当无法与服务器建立连接时)。</p><h2 id="缓存清单文件的结构"><a href="#缓存清单文件的结构" class="headerlink" title="缓存清单文件的结构"></a>缓存清单文件的结构</h2><p>缓存清单文件必须以 <strong>text/cache-manifest</strong> MIME 类型来传输。所有通过 MIME 类型传输的文件必须符合本节中定义的适用于应用缓存清单的语法。</p><p>缓存清单是 UTF-8 格式的文本文件，有可能包含一个 BOM 字符。新行可能使用换行符(U+000A)，回车(U+000D)，或回车加换行符来表示。</p><p>缓存清单文件的第一行必须包含字符串 CACHE MANIFEST (两个单词间使用一个 U+0020 空白)，紧接着是零或多个空白或制表符。本行的其他文本会被忽略。</p><p>缓存清单文件的余下内容必须包含零或多个下面的行：</p><p><strong>空行</strong><br>    你可以使用包含零或多个空白与制表符的空行。</p><p><strong>注释</strong><br>    注释包括零或多个制表符或空白字符，紧接着是一个 # 字符，再然后是零或多个注释文本字符。注释只能在所在行起作用，不能追加到其他行上。这意味着你无法使用片段标识符。</p><p><strong>段落标题</strong><br>    段落标题指定了缓存文件即将操作的段落。有三个可选的标题：</p><pre><code>    CACHE:         切换到缓存清单的显式段落(默认段落)。    NETWORK:     切换到缓存清单的在线白名单段落。    FALLBACK:     切换到缓存清单的后备资源段落。</code></pre><p>缓存清单可以在段落内任意切换(每个段落标题可以使用多次)，而且段落允许为空。</p><h1 id="一个应用缓存中的资源"><a href="#一个应用缓存中的资源" class="headerlink" title="一个应用缓存中的资源"></a>一个应用缓存中的资源</h1><p>一个应用缓存至少会包含一个资源，由 URI 指定。所有资源都属于下列类别之一：</p><p><strong>主记录</strong><br>    这些资源被加入缓存的原因是：用户浏览的一个上下文中包含一个文档，该文档用 manifest 特性明确指明了它属于该缓存。</p><p><strong>显式记录</strong><br>    这些是在应用缓存清单文件中显式列出的资源。</p><p><strong>网络记录</strong><br>    这些是在应用缓存清单文件中作为网络记录列出的资源。</p><p><strong>后备记录</strong><br>    这些是在应用缓存清单文件中作为后备记录列出的资源。</p><h2 id="主记录"><a href="#主记录" class="headerlink" title="主记录"></a>主记录</h2><p>任意在 <html> 元素上包含一个 manifest 特性的 HTML 文件都可以是主记录。例如，我们拥有 HTML 文件 <a href="http://www.example.com/entry.html" target="_blank" rel="noopener">http://www.example.com/entry.html</a> ，它看起来是这样的：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"example.appcache"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Application Cache Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 entry.html 没有在 example.appcache 缓存清单文件中列出来，那么访问 entry.html 页面会使得 entry.html 作为一条主记录加入到应用缓存中。</p><h2 id="显式记录"><a href="#显式记录" class="headerlink" title="显式记录"></a>显式记录</h2><p>显式记录就是在缓存清单文件的 CACHE 段落显式列出的资源。</p><h2 id="网络记录"><a href="#网络记录" class="headerlink" title="网络记录"></a>网络记录</h2><p>缓存清单文件的 NETWORK 段落指定了 web 应用需要在线访问的资源。一个应用缓存中的网络记录本质上来说是一个「在线白名单」—在 NETWORK 段落指定的 URI 会从服务器而不是缓存加载。这使得浏览器的安全模型通过限制用户让其只访问经过验证的资源来避免潜在的安全漏洞。</p><p>举例来说，你可以使用网络记录来从服务器而不是缓存中加载并执行脚本或其他代码：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">CACHE</span> <span class="string">MANIFEST</span></span><br><span class="line"><span class="attr">NETWORK</span>:<span class="string"></span></span><br><span class="line"><span class="attr">/api</span></span><br></pre></td></tr></table></figure><p>上面列出的缓存清单段落能够保证对 <a href="http://www.example.com/api/" target="_blank" rel="noopener">http://www.example.com/api/</a> 子目录中资源的请求始终通过网络加载，而不会去访问缓存。</p><blockquote><p>注意： 简单的从清单文件中过滤主记录(在 html 元素中拥有 manifest 特性的文件)并不会产生同样的结果，因为主记录会被添加到—后续访问的获取也会从—应用缓存中。</p></blockquote><h2 id="后备记录"><a href="#后备记录" class="headerlink" title="后备记录"></a>后备记录</h2><p>当尝试请求资源失败时会使用后备记录。例如，缓存清单文件 <a href="http://www.example.com/example.appcache" target="_blank" rel="noopener">http://www.example.com/example.appcache</a> 包含如下内容：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"><span class="symbol">FALLBACK:</span></span><br><span class="line">example<span class="meta-keyword">/bar/</span> example.html</span><br></pre></td></tr></table></figure><p>任何访问 <a href="http://www.example.com/example/bar/" target="_blank" rel="noopener">http://www.example.com/example/bar/</a> 或它的任意子目录及内容都会使浏览器发出请求，去尝试加载请求的资源。如果尝试失败(可能是由于网络连接失败或服务器问题)，浏览器将会加载 example.html。</p><h1 id="缓存状态"><a href="#缓存状态" class="headerlink" title="缓存状态"></a>缓存状态</h1><p>每个应用缓存都有一个状态，标示着缓存的当前状况。共享同一清单 URI 的缓存拥有相同的缓存状态，可能是其中之一：</p><p><strong>UNCACHED(未缓存)</strong><br>    一个特殊的值，用于表明一个应用缓存对象还没有完全初始化。</p><p><strong>IDLE(空闲)</strong><br>    应用缓存此时未处于更新过程中。</p><p><strong>CHECKING(检查)</strong><br>    清单已经获取完毕并检查更新。</p><p><strong>DOWNLOADING(下载中)</strong><br>    下载资源并准备加入到缓存中，这是由于清单变化引起的。</p><p><strong>UPDATEREADY(更新就绪)</strong><br>    一个新版本的应用缓存可以使用。有一个对应的事件 updateready，当下载完毕一个更新，并且还未使用 swapCache() 方法激活更新时，该事件触发，而不会是 cached 事件。</p><p><strong>OBSOLETE(废弃)</strong><br>    应用缓存现在被废弃。</p><h1 id="测试缓存清单的更新"><a href="#测试缓存清单的更新" class="headerlink" title="测试缓存清单的更新"></a>测试缓存清单的更新</h1><p>你可以使用 JavaScript 来写程序检测应用是否拥有一个可以更新的缓存清单文件。因为缓存清单文件可能会在脚本添加事件前完成更新，所以脚本应该始终检测 <code>window.applicationCache.status</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onUpdateReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'found new version!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.applicationCache.addEventListener(<span class="string">'updateready'</span>, onUpdateReady);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.applicationCache.status === <span class="built_in">window</span>.applicationCache.UPDATEREADY) &#123;</span><br><span class="line">  onUpdateReady();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 若要手动测试一个新的清单文件，你可以使用 <code>window.applicationCache.update()</code> 。</p><h1 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h1><ul><li><p>永远不要使用传统 GET 参数(例如 <code>other-cached-page.html?parameterName=value</code>) 来访问缓存文件。这会使浏览器绕过缓存，直接从网络获取。若想链接一个参数需要在 JavaScript 中解析的资源，你可以将参数放到链接的 hash 部分，例如 <code>other-cached-page.html#whatever?parameterName=value</code> 。</p></li><li><p>当应用被缓存后，仅仅更新在 web 页面中使用的资源(文件)还不足以更新被缓存的文件。你需要在浏览器获取和使用更新的文件前，去更新缓存清单文件本身。你可以使用 <code>window.applicationCache.swapCache()</code> 以编程的方式完成上述目的，虽然这无法影响到已经加载完毕的资源。为了保证资源从应用缓存的最新版本中加载，最理想的办法就是刷新页面。</p></li><li><p>通过在 web 服务器上设置 <code>expires header</code> 来使 <code>*.appcache</code> 文件立即过期是个好主意。这避免了将清单文件缓存的风险。例如，在 Apache 中，你可以指定下面的配置项：</p></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">ExpiresByType <span class="type">text</span>/<span class="keyword">cache</span>-manifest "access plus <span class="number">0</span> seconds"</span><br></pre></td></tr></table></figure><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><ul><li><a href="http://www.html5rocks.com/en/tutorials/appcache/beginner/" target="_blank" rel="noopener">HTML5Rocks - A Beginner’s Guide to Using the Application Cache</a></li><li><a href="http://appcachefacts.info/" target="_blank" rel="noopener">appcachefacts.info</a> - detailed information on AppCache idiosyncrasies</li><li><a href="http://hacks.mozilla.org/2010/01/offline-web-applications/" target="_blank" rel="noopener">offline web applications</a> at hacks.mozilla.org - showcases an offline app demo and explains how it works.</li><li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#offline" target="_blank" rel="noopener">HTML 5 working draft: Offline web applications</a></li><li><a href="http://developer.teradata.com/blog/js186040/2011/11/html5-cache-manifest-an-off-label-usage" target="_blank" rel="noopener">HTML5 Cache Manifest: An Off-label Usage</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIApplicationCache" target="_blank" rel="noopener">nsIApplicationCache</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIApplicationCacheNamespace" target="_blank" rel="noopener">nsIApplicationCacheNamespace</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIApplicationCacheContainer" target="_blank" rel="noopener">nsIApplicationCacheContainer</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIApplicationCacheChannel" target="_blank" rel="noopener">nsIApplicationCacheChannel</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIApplicationCacheService" target="_blank" rel="noopener">nsIApplicationCacheService</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIDOMOfflineResourceList" target="_blank" rel="noopener">nsIDOMOfflineResourceList</a></li><li><a href="http://www.ibm.com/developerworks/web/library/wa-ffox3/" target="_blank" rel="noopener">Get ready for Firefox 3.0 - A Web developer’s guide to the many new features in this popular browser, especially the offline application features</a> (IBM developerWorks)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> html5 </tag>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你是咸鱼吗？</title>
      <link href="2015/01/13/are-you-a-salted-fish/"/>
      <url>2015/01/13/are-you-a-salted-fish/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/salted_fish.jpg" alt="咸鱼"></p><p>我在05年的时候，写了一篇《你是咸鱼吗？》的Blog，转眼十年过去了。回头看看这十年来走过的路程，虽然有些弯弯绕绕、曲曲折折，但是很欣慰的是，我还记得当初的梦想，我没有变成咸鱼。</p><a id="more"></a><p>下面是我05年写得blog，整理并转载一下。</p><p>时间过的真快啊！过了今天，我来北京就整整三年了！</p><p>“做人如果没梦想，那跟咸鱼有什么分别？”，这句话是周星星同学在《少林足球》中的经典明言，还好现在的我还没有放弃我的理想和追求，还没有变成“咸鱼”！</p><p>希望能够用下文来激励自己不要忘记自己最初的梦想！</p><pre><code>我劝你呀，脚踏实地地做人吧，这里有一份洗厕所的工作你先做着，你就别做梦了。做人如果没梦想，那跟咸鱼有什么分别啊？你连鞋都没有，那不就是咸鱼一条啦，学人家讲理想。话不能这么讲，我心中的一团火是不会熄地。</code></pre><p>当我看到这里的时候，心里禁不住颤抖了一下。这段话是周星星同学在《少林足球》里对大师兄说的一段话。</p><p>个人最喜欢的周星星的三部影片分别是《大话西游》，《喜剧之王》以及这部《少林足球》。如果说《大话西游》是以一种荒诞的形式表达了个人梦想与个人情感之间的冲突，爱情与道义之不能两全的命题。《喜剧之王》描述的是一个处于社会底层的人追求自己的理想和爱情而奋斗不息的故事。而《少林足球》说的是这样一个处于底层的群体坚持自己的信念，为了自己的理想奋力拼搏并最终获得成功的故事。</p><p>当我第一次看这部影片的时候，带给我的是笑声，当我第二次看的时候，带给我了思考，但我今夜再看的时候，带给了我泪水。</p><p>也许我们每个人心里都有一个梦，梦想对我们来说，有时候是那么的真切，有时候是那么的遥远。世上有几个人又能梦想成真呢？当现实和自己的理想冲突的时候，我们是坚持自己的信念还是做一条没有梦想的咸鱼？</p><p>人生的路很曲折，也很反复。当昔日高高在上，不可一世的“黄金右脚”沦落到替他人擦鞋。当昔日的轻功高手现在却拿不到放到头顶的一圈纸。当嘴里说着“奔驰被人开走了，一分钟几十万的业务”的三师兄躲在小店里吃小面的时候。我看到了人生无常，人生悲哀。但是这世界上多少的人是这样活着的？</p><p>人与咸鱼的区别，起码有一点就是人是有梦想的，而咸鱼没有。《少林足球》里的足球，其实只是一个具体的符号。这个足球和我们踢的足球是没有关系的。这个符号其实是一个通用的东西，在每个人心里的足球都是不一样的。你的足球又是什么?</p><p>周星星拍《喜剧之王》的时候，是他感情有折的时候，拍《少林足球》是他事业受挫的时期。不同心情拍出的影片就会有不同的感受。但是有一点，都是对情感理想的不屈追求。所以才会引起大众的共鸣，拨动普通人的心弦。</p><p>如果有一天，失败降临在你我身上。在最万分无助的时候，想想他在片中对阿梅那样说的“要有自信，你是最好的”，是的，我们是最好的。</p><pre><code>不坠那青云之志！梦想就是心里的那团火！</code></pre><p>朋友，你还记得自己最初的梦想吗？不要变成“咸鱼”哦！</p>]]></content>
      
      
      <categories>
          
          <category> 生活感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradle依赖范围介绍</title>
      <link href="2015/01/12/gradle-dependency-scope/"/>
      <url>2015/01/12/gradle-dependency-scope/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/gradle.png" alt="Gradle Logo"></p><p>自从Google推出Android的集成开发环境（IDE）– <a href="http://developer.android.com/tools/studio/index.html" target="_blank" rel="noopener">Android Studio</a>，默认集成了<a href="http://www.gradle.org/" target="_blank" rel="noopener">Gradle</a>来进行对Android项目生命周期的管理。那我们也需要从原来的Ant转成Gradle。</p><p>对于开发工程师来说，像Gradle这样的工具，第一体验是对依赖的管理。团队里面有不少原来是使用<a href="http://maven.apache.org/" target="_blank" rel="noopener">Maven</a>的同学，会有这样的问题：“maven的依赖管理除了最基本的坐标体系（groupId、artifactId、version、packaging）以外，还有一个scope的概念。那作为继承了maven的依赖体系的gradle，它的依赖范围又有哪些？”</p><a id="more"></a><h3 id="那我们来看看Gradle的依赖范围（dependent-scope到底有哪些）。"><a href="#那我们来看看Gradle的依赖范围（dependent-scope到底有哪些）。" class="headerlink" title="那我们来看看Gradle的依赖范围（dependent scope到底有哪些）。"></a>那我们来看看Gradle的依赖范围（dependent scope到底有哪些）。</h3><h4 id="war插件使用的依赖范围"><a href="#war插件使用的依赖范围" class="headerlink" title="war插件使用的依赖范围"></a>war插件使用的依赖范围</h4><ul><li><p>providedCompile</p><pre><code>  war插件提供的范围类型:与compile作用类似,但不会被添加到最终的war包中这是由于编译、测试阶段代码需要依赖此类jar包，而运行阶段容器已经提供了相应的支持，所以无需将这些文件打入到war包中了;例如Servlet API就是一个很明显的例子.</code></pre></li><li><p>providedRuntime</p><pre><code>  同providedCompile类似，也是war插件提供的范围类型。它的范围和jar插件的runtime基本一样，。</code></pre></li></ul><p>相关说明可以看看Gradle官方文档的<a href="http://www.gradle.org/docs/current/userguide/war_plugin.html#N131A1" target="_blank" rel="noopener">第26章第4节 The War Plugin</a></p><h4 id="java插件使用的依赖范围"><a href="#java插件使用的依赖范围" class="headerlink" title="java插件使用的依赖范围"></a>java插件使用的依赖范围</h4><ul><li><p>compile</p><pre><code>  编译范围依赖在所有的classpath中可用，同时它们也会被打包。</code></pre></li><li><p>runtime</p><pre><code>  runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。</code></pre></li><li><p>testCompile</p><pre><code>  测试期编译需要的附加依赖</code></pre></li><li><p>testRuntime</p><pre><code>  测试期编译需要的附加依赖</code></pre></li><li><p>archives</p><pre><code>  项目构件时会使用的依赖范围</code></pre></li><li><p>default</p><pre><code>  配置默认依赖范围，用在这个项目上一个项目依赖的默认配置。包含本项目在运行时所需的构件和依赖。</code></pre></li></ul><p>相关说明可以查看Gradle官方文档的<a href="http://www.gradle.org/docs/current/userguide/java_plugin.html#sec:java_plugin_and_dependency_management" target="_blank" rel="noopener">第23章第5节 The Java Plugin</a></p><p>其他插件的依赖范围基本上也就是这两个插件的子集了，了解了上述的依赖范围也就等于了解Gradle所有的依赖范围了。</p><h3 id="Gradle的依赖范围与Tasks之间的关系"><a href="#Gradle的依赖范围与Tasks之间的关系" class="headerlink" title="Gradle的依赖范围与Tasks之间的关系"></a>Gradle的依赖范围与Tasks之间的关系</h3><p><img src="/images/blog/javaPluginConfigurations.png" alt="依赖范围与Gradle Tasks之间的关系"></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> engineered </tag>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端解耦原则</title>
      <link href="2015/01/05/frontend-decoupling-principle/"/>
      <url>2015/01/05/frontend-decoupling-principle/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/decoupling.png" alt="解耦"></p><h2 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h2><p>当你能够做到修改一个组件而不需要更改其他组件时，就做到了松耦合，松耦合对于代码可维护性来说是至关重要的。</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>不要使用 css 表达式。（这种方式应该已经废弃了）</li><li>javascript 和 css 之间只通过 className 进行通信。</li><li>不要使用 html 的 on 属性，如：onclick。应该使用 id 保持 javascript 和 html 的沟通。</li><li>使用模板。</li></ul><a id="more"></a><h2 id="将-javascript-从-css-中抽离"><a href="#将-javascript-从-css-中抽离" class="headerlink" title="将 javascript 从 css 中抽离"></a>将 <strong>javascript</strong> 从 <strong>css</strong> 中抽离</h2><p>在 ie8 和更早版本的浏览器中有一个特性，即 <strong>css 表达式</strong> 。如下：</p><h3 id="不好的写法"><a href="#不好的写法" class="headerlink" title="不好的写法"></a>不好的写法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">expression</span>(document.body.offsetWidth + <span class="string">"px"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，现在ie9 已经不再支持 <strong>css 表达式</strong> 了。<br>而且，这种写法自2013年以来，我再没有见过。</p><h2 id="将-css-从-javascript-中抽离"><a href="#将-css-从-javascript-中抽离" class="headerlink" title="将 css 从 javascript 中抽离"></a>将 <strong>css</strong> 从 <strong>javascript</strong> 中抽离</h2><h3 id="不好的写法-1"><a href="#不好的写法-1" class="headerlink" title="不好的写法"></a>不好的写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.style.color = <span class="string">"red"</span>;</span><br><span class="line">element.style.left = <span class="string">"10"</span>px;</span><br><span class="line">element.style.visibility = <span class="string">"visible"</span>;</span><br></pre></td></tr></table></figure><h3 id="好的写法"><a href="#好的写法" class="headerlink" title="好的写法"></a>好的写法</h3><p>在 css 中定义样式 ， 在 javascript 中 通过 className 通信</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.reveal</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javascript</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.className += <span class="string">"reveal"</span>;    <span class="comment">// 原生写法</span></span><br><span class="line">$(element).addClass(<span class="string">"reveal"</span>);    <span class="comment">// 如果是 jQuery</span></span><br></pre></td></tr></table></figure><h2 id="将-javascript-从-html-中抽离"><a href="#将-javascript-从-html-中抽离" class="headerlink" title="将 javascript 从 html 中抽离"></a>将 <strong>javascript</strong> 从 <strong>html</strong> 中抽离</h2><h3 id="不好的写法-2"><a href="#不好的写法-2" class="headerlink" title="不好的写法"></a>不好的写法</h3><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">button</span> <span class="keyword">onclick</span>=<span class="string">"doSomething()"</span> id=<span class="string">"action"</span>&gt;click me&lt;/<span class="keyword">button</span>&gt;</span><br></pre></td></tr></table></figure><p>我们要避免使用 onclick 等 on 属性来绑定一个事件处理程序。<br>应该使用 id 保持 javascript 和 html 的沟通。</p><h3 id="好的写法-如使用-jQuery"><a href="#好的写法-如使用-jQuery" class="headerlink" title="好的写法, 如使用 jQuery"></a>好的写法, 如使用 jQuery</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#action"</span>).<span class="keyword">on</span><span class="params">(<span class="string">"click"</span>,doSomething)</span>;</span><br></pre></td></tr></table></figure><h2 id="将-html-从-javascript-中抽离"><a href="#将-html-从-javascript-中抽离" class="headerlink" title="将 html 从 javascript 中抽离"></a>将 <strong>html</strong> 从 <strong>javascript</strong> 中抽离</h2><p>注释中包含模板文本</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"mylist"</span>&gt;&lt;!--<span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item%s"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%s"</span>&gt;</span>%s<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"1"</span>&gt;</span>First item<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;&lt;a href="2"&gt;Second item&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;&lt;a href="3"&gt;Third item&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><h3 id="注释也是-DOM-的一部分"><a href="#注释也是-DOM-的一部分" class="headerlink" title="注释也是 DOM 的一部分"></a>注释也是 <strong>DOM</strong> 的一部分</h3><p>function addItem(url, text) {<br>    var mylist = document.getElementById(“mylist”),<br>        templateText = mylist.firstChild.nodeValue;<br>        result = sprintf(template, url, text);<br>    div.innerHTML = result;<br>    mylist.insertAdjacentHTML(“beforeend”, result);<br>}<br>addItem(“4”, “Four item”);</p><h3 id="使用一个带有自定义-type-属性的-script-元素。"><a href="#使用一个带有自定义-type-属性的-script-元素。" class="headerlink" title="使用一个带有自定义 type 属性的 script 元素。"></a>使用一个带有自定义 <strong>type</strong> 属性的 <strong>script</strong> 元素。</h3><p>浏览器会默认地将 <strong>script</strong> 元素中的内容识别为 <strong>JavaScript</strong> 代码， 但你可以通过给 <strong>type</strong> 赋值为浏览器不识别的类型，来告诉浏览器这不是一段 javascript 脚本。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-my-template"</span> <span class="attr">id</span>=<span class="string">"list-item"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%s"</span>&gt;</span>%s<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以通过 <strong>script</strong> 标签的 <strong>text</strong> 属性来提取模板文本。<br>这样 <strong>addItem()</strong> 函数就会变成这样。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> add<span class="constructor">Item(<span class="params">url</span>, <span class="params">text</span>)</span> &#123;</span><br><span class="line">    var mylist = document.get<span class="constructor">ElementById(<span class="string">"mylist"</span>)</span>,</span><br><span class="line">        script = document.get<span class="constructor">ElementById(<span class="string">"list-item"</span>)</span>,</span><br><span class="line">        templateText = script.test,</span><br><span class="line">        result = sprintf(template, url, text),</span><br><span class="line">        div = document.create<span class="constructor">Element(<span class="string">"div"</span>)</span>;</span><br><span class="line">    div.innerHTML = result.replace(/^\s*/, <span class="string">""</span>);</span><br><span class="line">    <span class="built_in">list</span>.append<span class="constructor">Child(<span class="params">div</span>.<span class="params">firstChild</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">add<span class="constructor">Item(<span class="string">"/item/4"</span>, <span class="string">"Four item"</span>)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> engineered </tag>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网项目生命周期</title>
      <link href="2014/12/31/project-life-cycle/"/>
      <url>2014/12/31/project-life-cycle/</url>
      
        <content type="html"><![CDATA[<p>下面这张图是我在google+中无意看到的，虽然有失偏颇，但是也经历过不少这样的互联网项目。</p><p>当你碰到这样的项目时，你该怎么办？这是一个需要深思的问题……</p><a id="more"></a><p><img src="/images/blog/project_life_cycle.jpg" alt="项目生命周期"></p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> product </tag>
            
            <tag> management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>brew update失败处理方法</title>
      <link href="2014/12/31/brew-update-error/"/>
      <url>2014/12/31/brew-update-error/</url>
      
        <content type="html"><![CDATA[<p>使用<code>brew update</code>时报错，错误如下：</p><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>Your local changes to the following files would be overwritten by merge:</span><br></pre></td></tr></table></figure><p>我看了diff，代码变更和网站上的代码变更一致，但是版本控制没有跟踪到。</p><p>解决办法就是同步到最新的版本，或者如果有自行修改或者第三方的修改要保留，可以merge</p><a id="more"></a><p>方法1.删除这些更改的文件，然后<code>brew update</code></p><p>方法2.重新获取最新的文件，并且<code>hardreset</code></p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard FETCH_HEAD</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/usr/local</span> &amp;&amp; sudo git reset <span class="params">--hard</span> FETCH_HEAD</span><br></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">cd `brew --<span class="built_in">prefix</span>`</span><br><span class="line">git remote add <span class="built_in">origin</span> https://github.com/mxcl/homebrew.git</span><br><span class="line">git fetch <span class="built_in">origin</span></span><br><span class="line">git <span class="built_in">reset</span> --hard <span class="built_in">origin</span>/master</span><br></pre></td></tr></table></figure><p><code> 方法3.保留更改，</code>brew update`，再应用更改</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">You have made some changes in the brew repository.</span><br><span class="line"></span><br><span class="line">You can either <span class="keyword">do</span> a git stash, brew <span class="keyword">update</span>, git stash pop <span class="keyword">to</span> <span class="keyword">keep</span> your changes, <span class="keyword">or</span> git <span class="keyword">reset</span> –hard <span class="keyword">HEAD</span>, brew <span class="keyword">update</span> <span class="keyword">to</span> <span class="keyword">reset</span> the changes.</span><br></pre></td></tr></table></figure><p>接着<code>brew doctor</code>又提示</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Warning: The /usr/local directory <span class="keyword">is</span> not writable.</span><br><span class="line">Even <span class="keyword">if</span> <span class="keyword">this</span> directory was writable <span class="keyword">when</span> you installed Homebrew, other</span><br><span class="line">software may change permissions on <span class="keyword">this</span> directory. Some versions of the</span><br><span class="line">“InstantOn” component of Airfoil are known to <span class="keyword">do</span> <span class="keyword">this</span>.</span><br></pre></td></tr></table></figure><p>是group的问题，默认group是wheel，brew要求是admin</p><p>view source</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sudo chgrp -R <span class="keyword">admin</span> /usr/<span class="keyword">local</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mac OSX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> brew </tag>
            
            <tag> mac osx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Sublime开发Golang</title>
      <link href="2014/12/22/use-sublime-develop-golang/"/>
      <url>2014/12/22/use-sublime-develop-golang/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/golang.jpg" alt="golang logo"></p><h2 id="安装Golang"><a href="#安装Golang" class="headerlink" title="安装Golang"></a>安装Golang</h2><p>在<a href="http://golang.org/" target="_blank" rel="noopener">官网</a>上直接下载安装包就可以了。下载pkg格式的最新安装包 ，直接双击运行，一路按照提示操作就可以完成安装。</p><p>或者使用brew进行安装 <code>brew install go</code></p><p>完成安装之后，打开终端，输入 <code>go version</code> ，检查golang sdk是否安装成功。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">➜  ~  <span class="keyword">go</span> version</span><br><span class="line"><span class="keyword">go</span> version go1<span class="number">.3</span><span class="number">.3</span> darwin/amd64</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>GOPATH是用来告诉Golang命令和其他相关工具 ，在哪儿可以找到你的Go包目录。</p><p>GOPATH是一个路径列表，类似PATH的配置。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GOPATH=~/workspace/demo/go-demo</span><br></pre></td></tr></table></figure><p>我将Golang的相关配置都写在一个独立的.golangrc的文件中，然后在.zshrc中引入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.golangrc</span><br></pre></td></tr></table></figure><blockquote><p>如果你在GOLANG中配置了多个目录的话，当你下载开源包是(<code>go get *****</code>)，开源包默认会找到第一个目录，会统一下到第一个目录的pkg目录下。</p></blockquote><h2 id="go官方推荐的项目结构"><a href="#go官方推荐的项目结构" class="headerlink" title="go官方推荐的项目结构"></a>go官方推荐的项目结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/</span><br><span class="line">    hello                          <span class="comment"># command executable</span></span><br><span class="line">    outyet                         <span class="comment"># command executable</span></span><br><span class="line">pkg/</span><br><span class="line">    linux_amd64/</span><br><span class="line">        github.com/golang/example/</span><br><span class="line">            stringutil.a           <span class="comment"># package object</span></span><br><span class="line">src/</span><br><span class="line">    github.com/golang/example/</span><br><span class="line">        .git/                      <span class="comment"># Git repository metadata</span></span><br><span class="line">hello/</span><br><span class="line">    hello.go               <span class="comment"># command source</span></span><br><span class="line">outyet/</span><br><span class="line">    main.go                <span class="comment"># command source</span></span><br><span class="line">    main_test.go           <span class="comment"># test source</span></span><br><span class="line">stringutil/</span><br><span class="line">    reverse.go             <span class="comment"># package source</span></span><br><span class="line">    reverse_test.go        <span class="comment"># test source</span></span><br></pre></td></tr></table></figure><p>参考</p><blockquote><p><a href="http://golang.org/doc/code.html" target="_blank" rel="noopener">http://golang.org/doc/code.html</a></p></blockquote><h2 id="Sublime安装GoSublime"><a href="#Sublime安装GoSublime" class="headerlink" title="Sublime安装GoSublime"></a>Sublime安装GoSublime</h2><p>Package Control如何安装我就不说了。直接安装<a href="https://github.com/DisposaBoy/GoSublime" target="_blank" rel="noopener">GoSublime</a>插件</p><p>Mac OSX下使用Command + Shift + P打开<code>Package Control</code>，然后输入 <code>pcip</code> (Package Control:Install Package的缩写)</p><p>在随后的界面中输入<code>GoSublime</code>，回车，就开始安装GoSubmlime了。</p><p>当你可以在Sublime的 <code>Preferences -&gt; Package Settings</code> 看到 <code>GoSublime</code> ，那么恭喜你，你的基于Sublime的Golang开发环境就搭建完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> sublime </tag>
            
            <tag> program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grunt项目脚手架</title>
      <link href="2014/12/11/grunt-project-scaffolding/"/>
      <url>2014/12/11/grunt-project-scaffolding/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文： <a href="https://github.com/gruntjs/grunt-docs/blob/master/Project-Scaffolding.md" target="_blank" rel="noopener">https://github.com/gruntjs/grunt-docs/blob/master/Project-Scaffolding.md</a></p></blockquote><h1 id="1-grunt-init"><a href="#1-grunt-init" class="headerlink" title="1. grunt-init"></a>1. grunt-init</h1><p>grunt-init 是一个脚手架工具，用于自动创建项目。基于当前的环境和几个问题的答案创建一个完整的目录结构。确切的文件和内容取决于所选的模板，和模板提出的问题的答案。</p><p>注：本独立程序曾经作为“init”任务内置于 Grunt。关于该变化的更多信息查看 Grunt 从 0.3 升级到 0.4 指南。</p><a id="more"></a><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><p>为了使用 <strong>grunt-init</strong> ，你需要全局安装它。</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g grunt-init</span><br></pre></td></tr></table></figure><p>这将把将命令 <code>grunt-init</code> 放入系统路径中，从而可以从任意目录运行它。</p><p>注：你可能需要使用指令 sudo 或者以管理员身份运行命令解释程序来做到这一点。</p><h1 id="3-用法"><a href="#3-用法" class="headerlink" title="3. 用法"></a>3. 用法</h1><ul><li>使用 <code>grunt-init --help</code> 获取程序帮助和可用的模板列表。</li><li>使用 <code>grunt-init TEMPLATE</code> 基于一个可用的模板创建一个项目。</li><li>使用 <code>grunt-init /path/to/TEMPLATE</code> 基于一个任意位置的模板创建一个项目。</li></ul><p>需要注意的是，大多数模板在当前目录中生成它们的文件，因此一定要先切换到一个新目录，如果不希望覆盖已有文件的话。</p><h1 id="4-安装模板"><a href="#4-安装模板" class="headerlink" title="4. 安装模板"></a>4. 安装模板</h1><p>一旦模板被安装到 <code>~/.grunt-init/</code> 目录（在 Windows 上是 <code>(%USERPROFILE%\.grunt=init\）</code>，就可以通过 grunt-init 使用它们。使用你使用 git 拷贝一个模范到该目录中。例如，可以这样安装 <a href="https://github.com/gruntjs/grunt-init-jquery" target="_blank" rel="noopener">grunt-init-jquery</a> 模板：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@github.com:gruntjs/grunt-init-jquery.git ~/.grunt-init/jquery</span><br></pre></td></tr></table></figure><p>注：如果你想以<em>“foobarbaz”</em>在本地使用模板，你可以在拷贝时指定<code>~/.grunt-init/foobarbaz</code>。grunt-init 将使用模板在目录 <code>~/.grunt-init/</code> 中的实际目录名。</p><p>一些 grunt-init 模板由官方维护：</p><ul><li><a href="https://github.com/gruntjs/grunt-init-commonjs" target="_blank" rel="noopener">grunt-init-commonjs</a> - 创建一个 commonjs 模块，包括 Nodeunit 单元测试。（<a href="https://github.com/gruntjs/grunt-init-commonjs-sample/tree/generated" target="_blank" rel="noopener">生成的样本库</a> | <a href="https://github.com/gruntjs/grunt-init-commonjs-sample#project-creation-transcript" target="_blank" rel="noopener">创建记录</a>）</li><li><a href="https://github.com/gruntjs/grunt-init-gruntfile" target="_blank" rel="noopener">grunt-init-gruntfile</a> - 创建一个基本的 Gruntfile。（<a href="https://github.com/gruntjs/grunt-init-gruntfile-sample/tree/generated" target="_blank" rel="noopener">生成的样本库</a> | <a href="https://github.com/gruntjs/grunt-init-gruntfile-sample#project-creation-transcript" target="_blank" rel="noopener">创建记录</a>）</li><li><a href="https://github.com/gruntjs/grunt-init-gruntplugin" target="_blank" rel="noopener">grunt-init-gruntplugin</a> -创建一个 Grunt 插件，包含 Nodeunit 单元测试。（<a href="https://github.com/gruntjs/grunt-init-gruntplugin-sample/tree/generated" target="_blank" rel="noopener">生成的样本库</a> | <a href="https://github.com/gruntjs/grunt-init-gruntplugin-sample#project-creation-transcript" target="_blank" rel="noopener">创建记录</a>）</li><li><a href="https://github.com/gruntjs/grunt-init-jquery" target="_blank" rel="noopener">grunt-init-jquery</a> - 创建一个 jQuery 插件，包含 Nodeunit 单元测试。（<a href="https://github.com/gruntjs/grunt-init-jquery-sample/tree/generated" target="_blank" rel="noopener">生成的样本库</a> | <a href="https://github.com/gruntjs/grunt-init-jquery-sample#project-creation-transcript" target="_blank" rel="noopener">创建记录</a>）</li><li><a href="https://github.com/gruntjs/grunt-init-node" target="_blank" rel="noopener">grunt-init-node</a> - 创建一个 Node.js 模块，包含 Nodeunit 单元测试。（<a href="https://github.com/gruntjs/grunt-init-node-sample/tree/generated" target="_blank" rel="noopener">生成的样本库</a> | <a href="https://github.com/gruntjs/grunt-init-node-sample#project-creation-transcript" target="_blank" rel="noopener">创建记录</a>）</li></ul><h1 id="5-自定义模板"><a href="#5-自定义模板" class="headerlink" title="5. 自定义模板"></a>5. 自定义模板</h1><p>你可以创建和使用自定义模板。你的模板必须遵循与上述模板同样的结构。</p><p>一个命名为 <code>my-template</code> 的模板要遵循下面的通用文件结构：</p><ul><li>my-template/template.js - 主模板文件.</li><li>my-template/rename.json - 模板特定的命名规则，作为模板处理。</li><li>my-template/root/ - 拷贝到目标位置的文件。</li></ul><p>假设这些文件已经在 <code>/path/to/my-template</code>，可以用命令 <code>grunt-init /path/to/my-template</code> 处理该模板。多个不重名的模板可以存在于同一个目录项，就像内置模板一样。</p><blockquote><p>没有在内置模板中找到多个不重名模板，疑问中</p></blockquote><p>此外，如果将自定义模板放入 <code>~/.grunt-init/</code> 目录（Windows 上是 <code>%USERPROFILE%\.grunt-init\</code>），运行 <code>grunt-init my-template</code> 将自动被使用。</p><h2 id="5-1-拷贝文件"><a href="#5-1-拷贝文件" class="headerlink" title="5.1 拷贝文件"></a>5.1 拷贝文件</h2><p>当 init 模板运行时，只要一个模板使用方法 <code>init.filesToCopy</code> 和 <code>init.copyAndProcess</code>，目录 <code>root/</code> 中的所有文件将被复制到当前目录。</p><p>请注意，所以拷贝文件会被当作模板处理，模板 <code>{ % % }</code> 将在收集的 <code>props</code> 数据对象下处理，除非设置了选项 <code>noProcess</code>。看看 <a href="https://github.com/gruntjs/grunt-init-jquery" target="_blank" rel="noopener">jQuery 模板</a>例子。</p><h2 id="5-2-重命名或不包括模板文件"><a href="#5-2-重命名或不包括模板文件" class="headerlink" title="5.2 重命名或不包括模板文件"></a>5.2 重命名或不包括模板文件</h2><p><code>rename.json</code> 描述 <code>sourcepath</code> 到 <code>destpath</code> 的重命名映射。<code>sourcepath</code> 必须是 <code>root/</code> 文件夹下将被拷贝文件的路径，而 <code>destpath</code> 值可以包含 <code>{ % % }</code> 模板，描述目标路径是什么。</p><p>如果指定 <code>destpath</code> 为 <code>false</code>，该文件不会被复制。此外，<code>srcpath</code> 支持通配符。</p><h1 id="6-指定默认提示答案"><a href="#6-指定默认提示答案" class="headerlink" title="6. 指定默认提示答案"></a>6. 指定默认提示答案</h1><p>没有初始化提示或者有一个硬编码的默认值，或者产看当前环境来尝试判断默认值。如果你想覆盖个别提示的默认值，你可以在选项文件 <code>~/.grunt-init/defaults.json</code>（OS X 或 Linux）或 <code>%USERPROFILE%\.grunt-init\defaults.json</code>（Window）中这么做。</p><p>例如，我的 <code>defaults.json</code> 文件看起来就像这样，因为我想用一个稍微不同的名称而不是默认名称，想要排除我的电子邮件地址，想自动指定一个作者网址。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"author_name"</span>: <span class="string">"\"Cowboy\" Ben Alman"</span>,</span><br><span class="line">  <span class="attr">"author_email"</span>: <span class="string">"none"</span>,</span><br><span class="line">  <span class="attr">"author_url"</span>: <span class="string">"http://benalman.com/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在所有内置提示被文档化之前，你可以在<a href="https://github.com/gruntjs/grunt-init/blob/master/tasks/init.js" target="_blank" rel="noopener">源代码</a>中找到它们的名称和默认值。</p><h1 id="7-定义一个初始化模板"><a href="#7-定义一个初始化模板" class="headerlink" title="7. 定义一个初始化模板"></a>7. 定义一个初始化模板</h1><blockquote><p>对照 ~/.grunt-init/node/template.js 理解。</p></blockquote><h2 id="7-1-exports-description"><a href="#7-1-exports-description" class="headerlink" title="7.1 exports.description"></a>7.1 exports.description</h2><p>当用户运行 <code>grunt init</code> 或 <code>grunt-init</code> 来显示所有有效的初始化模板列表时，简短的模板描述随模板名称一起显示。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.description = descriptionString;</span><br></pre></td></tr></table></figure><h2 id="7-2-exports-notes"><a href="#7-2-exports-notes" class="headerlink" title="7.2 exports.notes"></a>7.2 exports.notes</h2><p>如果指定了，该可选的扩展描述将在所有提示之前显示。这是一个很好的向用户提供一点点帮助解释命名约定的地方，哪些提示是必须或可选的，等等。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.notes = notesString;</span><br></pre></td></tr></table></figure><h2 id="7-3-exports-warnOn"><a href="#7-3-exports-warnOn" class="headerlink" title="7.3 exports.warnOn"></a>7.3 exports.warnOn</h2><p>如果该可选（但是推荐）的通配符或通配符数组被（已存在的文件或目录）匹配，Grunt 将中止，并导致一条警告信息，用户可以使用 <code>--force</code> 覆盖该行为。这些初试化模板可能潜在的覆盖已存在文件时非常有用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.warnOn = wildcardPattern;</span><br></pre></td></tr></table></figure><p>而最常见的值是 ‘*’，匹配所有文件或文件夹，使用的 <a href="https://github.com/isaacs/minimatch" target="_blank" rel="noopener">minimatch</a> 通配符语法允许很大的灵活性。例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.warnOn = <span class="string">'Gruntfile.js'</span>;    <span class="comment">// Warn on a Gruntfile.js file.</span></span><br><span class="line">exports.warnOn = <span class="string">'*.js'</span>;            <span class="comment">// Warn on any .js file.</span></span><br><span class="line">exports.warnOn = <span class="string">'*'</span>;               <span class="comment">// Warn on any non-dotfile or non-dotdir.</span></span><br><span class="line">exports.warnOn = <span class="string">'.*'</span>;              <span class="comment">// Warn on any dotfile or dotdir.</span></span><br><span class="line">exports.warnOn = <span class="string">'&#123;.*,*&#125;'</span>;          <span class="comment">// Warn on any file or dir (dot or non-dot).</span></span><br><span class="line">exports.warnOn = <span class="string">'!*/**'</span>;           <span class="comment">// Warn on any file (ignoring dirs).</span></span><br><span class="line">exports.warnOn = <span class="string">'*.&#123;png,gif,jpg&#125;'</span>; <span class="comment">// Warn on any image file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is another way of writing the last example.</span></span><br><span class="line">exports.warnOn = [<span class="string">'*.png'</span>, <span class="string">'*.gif'</span>, <span class="string">'*.jpg'</span>];</span><br></pre></td></tr></table></figure><h2 id="7-4-exports-template"><a href="#7-4-exports-template" class="headerlink" title="7.4 exports.template"></a>7.4 exports.template</h2><p>虽然 <code>exports</code> 属性定义在该函数之外，但是所有实际的初始化代码在该函数内指定。三个参数被传给该函数。参数 <code>grunt</code> 指向 grunt，包含了所有的 <a href="http://gruntjs.com/api/grunt" target="_blank" rel="noopener">grunt 方法和库</a>。参数 <code>init</code> 是一个包含了特定于该初始化模板的方法和属性的对象。参数 <code>done</code> 是一个函数，当初始化模板执行完成时必须调用该函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.template = <span class="function"><span class="keyword">function</span>(<span class="params">grunt, init, done</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// See the "Inside an init template" section.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="8-初始化模板内部"><a href="#8-初始化模板内部" class="headerlink" title="8. 初始化模板内部"></a>8. 初始化模板内部</h1><h2 id="8-1-init-addLicenseFiles"><a href="#8-1-init-addLicenseFiles" class="headerlink" title="8.1 init.addLicenseFiles"></a>8.1 init.addLicenseFiles</h2><p>添加适当命名的许可证文件到 files 对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> files = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> licenses = [<span class="string">'MIT'</span>];</span><br><span class="line">init.addLicenseFiles(files, licenses);</span><br><span class="line"><span class="comment">// files === &#123;'LICENSE-MIT': 'licenses/LICENSE-MIT'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="8-2-init-availableLicenses"><a href="#8-2-init-availableLicenses" class="headerlink" title="8.2 init.availableLicenses"></a>8.2 init.availableLicenses</h2><p>返回有效许可证数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> licenses = init.availableLicenses();</span><br><span class="line"><span class="comment">// licenses === [ 'Apache-2.0', 'GPL-2.0', 'MIT', 'MPL-2.0' ]</span></span><br></pre></td></tr></table></figure><h2 id="8-3-init-copy"><a href="#8-3-init-copy" class="headerlink" title="8.3 init.copy"></a>8.3 init.copy</h2><p>复制一个文件，指定一个绝对或相对源路径和一个可选的相对目标路径，可以通过传入的回调函数处理复制的文件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.copy(srcpath[, destpath], options)</span><br></pre></td></tr></table></figure><h2 id="8-4-init-copyAndProcess"><a href="#8-4-init-copyAndProcess" class="headerlink" title="8.4 init.copyAndProcess"></a>8.4 init.copyAndProcess</h2><p>遍历传入的对象中的所有文件，拷贝源文件到目标地址，并处理文件内容。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.copyAndProcess(files, props[, options])</span><br></pre></td></tr></table></figure><h2 id="8-5-init-defaults"><a href="#8-5-init-defaults" class="headerlink" title="8.5 init.defaults"></a>8.5 init.defaults</h2><p><code>defaults.json</code> 中用户指定的默认初始值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.defaults</span><br></pre></td></tr></table></figure><h2 id="8-6-init-destpath"><a href="#8-6-init-destpath" class="headerlink" title="8.6 init.destpath"></a>8.6 init.destpath</h2><p>绝对目标文件路径。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.destpath()</span><br></pre></td></tr></table></figure><h2 id="8-7-init-expand"><a href="#8-7-init-expand" class="headerlink" title="8.7 init.expand"></a>8.7 init.expand</h2><p>与 <a href="https://github.com/gruntjs/grunt/wiki/grunt.file#wiki-grunt-file-expand" target="_blank" rel="noopener">grunt.file.expand</a> 一致。</p><p>返回一个不重复数组，含有匹配通配符模式的所有文件和目录路径。该方法接收逗号分割的痛佩服模式，或者通配符模式数组。匹配以 ! 开头的模式的路径将从返回值中排除。模式被顺序处理，所以包含和排除的顺序是重要的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.expand([options, ] patterns)</span><br></pre></td></tr></table></figure><h2 id="8-8-init-filesToCopy"><a href="#8-8-init-filesToCopy" class="headerlink" title="8.8 init.filesToCopy"></a>8.8 init.filesToCopy</h2><p>返回一个包含了待复制文件的对象，包含绝对源路径和相对目标路径，按照 <code>rename.json</code>（如果存在的话）中的规则重命名（或忽略）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> files = init.filesToCopy(props);</span><br><span class="line"><span class="comment">/* files === &#123; '.gitignore': 'template/root/.gitignore',</span></span><br><span class="line"><span class="comment">  '.jshintrc': 'template/root/.jshintrc',</span></span><br><span class="line"><span class="comment">  'Gruntfile.js': 'template/root/Gruntfile.js',</span></span><br><span class="line"><span class="comment">  'README.md': 'template/root/README.md',</span></span><br><span class="line"><span class="comment">  'test/test_test.js': 'template/root/test/name_test.js' &#125; */</span></span><br></pre></td></tr></table></figure><h2 id="8-9-init-getFile"><a href="#8-9-init-getFile" class="headerlink" title="8.9 init.getFile"></a>8.9 init.getFile</h2><p>返回单个任务文件路径。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.getFile(filepath[, ...])</span><br></pre></td></tr></table></figure><h2 id="8-10-init-getTemplates"><a href="#8-10-init-getTemplates" class="headerlink" title="8.10 init.getTemplates"></a>8.10 init.getTemplates</h2><p>返回含有所有有效模板的对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.getTemplates()</span><br></pre></td></tr></table></figure><h2 id="8-11-init-initSearchDirs"><a href="#8-11-init-initSearchDirs" class="headerlink" title="8.11 init.initSearchDirs"></a>8.11 init.initSearchDirs</h2><p>初始化目录来搜索初始化模板。这里的<code>模板</code>是指模板路径。会包括 <code>~/.grunt-init/</code> 和 <code>grunt-init</code> 中的核心初始化任务。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.initSearchDirs([filename])</span><br></pre></td></tr></table></figure><h2 id="8-12-init-process"><a href="#8-12-init-process" class="headerlink" title="8.12 init.process"></a>8.12 init.process</h2><p>启动进程，开始提示输入。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.process(options, prompts, done)</span><br><span class="line"></span><br><span class="line">init.process(&#123;&#125;, [</span><br><span class="line">  <span class="comment">// Prompt for these values</span></span><br><span class="line">  init.prompt(<span class="string">'name'</span>),</span><br><span class="line">  init.prompt(<span class="string">'description'</span>),</span><br><span class="line">  init.prompt(<span class="string">'version'</span>)</span><br><span class="line">], <span class="function"><span class="keyword">function</span>(<span class="params">err, props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// All finished, do something with the properties</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="8-13-init-prompt"><a href="#8-13-init-prompt" class="headerlink" title="8.13 init.prompt"></a>8.13 init.prompt</h2><p>提示用户输入。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.prompt(name[, <span class="keyword">default</span>])</span><br></pre></td></tr></table></figure><h2 id="8-14-init-prompts"><a href="#8-14-init-prompts" class="headerlink" title="8.14 init.prompts"></a>8.14 init.prompts</h2><p>含有所有提示的对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prompts = init.prompts;</span><br></pre></td></tr></table></figure><h2 id="8-15-init-readDefaults"><a href="#8-15-init-readDefaults" class="headerlink" title="8.15 init.readDefaults"></a>8.15 init.readDefaults</h2><p>从任务文件（如果存在的话）读取 JSON 默认值，并合并到一个数据对象中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.readDefaults(filepath[, ...])</span><br></pre></td></tr></table></figure><h2 id="8-16-init-renames"><a href="#8-16-init-renames" class="headerlink" title="8.16 init.renames"></a>8.16 init.renames</h2><p>模板的重命名规则。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> renames = init.renames;</span><br><span class="line"><span class="comment">// renames === &#123; 'test/name_test.js': 'test/\&#123;\%= name \%\&#125;_test.js' &#125;</span></span><br></pre></td></tr></table></figure><h2 id="8-17-init-searchDirs"><a href="#8-17-init-searchDirs" class="headerlink" title="8.17 init.searchDirs"></a>8.17 init.searchDirs</h2><p>目录数组，用于在其中搜索模板。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dirs = init.searchDirs;</span><br><span class="line"><span class="comment">/* dirs === [ '/Users/shama/.grunt-init',</span></span><br><span class="line"><span class="comment">  '/usr/local/lib/node_modules/grunt-init/templates' ] */</span></span><br></pre></td></tr></table></figure><h2 id="8-18-init-srcpath"><a href="#8-18-init-srcpath" class="headerlink" title="8.18 init.srcpath"></a>8.18 init.srcpath</h2><p>通过文件名搜索初始化模板路径，并返回一个绝对路径。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.srcpath(filepath[, ...])</span><br></pre></td></tr></table></figure><h2 id="8-19-init-userDir"><a href="#8-19-init-userDir" class="headerlink" title="8.19 init.userDir"></a>8.19 init.userDir</h2><p>返回用户模板路径的绝对路径。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dir = init.userDir();</span><br><span class="line"><span class="comment">// dir === '/Users/shama/.grunt-init'</span></span><br></pre></td></tr></table></figure><h2 id="8-20-init-writePackageJSON"><a href="#8-20-init-writePackageJSON" class="headerlink" title="8.20 init.writePackageJSON"></a>8.20 init.writePackageJSON</h2><p>保存一个 package.json 文件到目标目录。回调函数可以用来后置处理属性，或添加或移除或其他任何操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.writePackageJSON(filename, props[, callback])</span><br></pre></td></tr></table></figure><h1 id="9-内置提示"><a href="#9-内置提示" class="headerlink" title="9. 内置提示"></a>9. 内置提示</h1><h2 id="9-1-author-email"><a href="#9-1-author-email" class="headerlink" title="9.1 author_email"></a>9.1 author_email</h2><p>Author’s email address to use in the <code>package.json</code>. Will attempt to find a default value from the user’s git config.</p><h2 id="9-2-author-name"><a href="#9-2-author-name" class="headerlink" title="9.2 author_name"></a>9.2 author_name</h2><p>Author’s full name to use in the <code>package.json</code> and copyright notices. Will attempt to find a default value from the user’s git config.</p><h2 id="9-3-author-url"><a href="#9-3-author-url" class="headerlink" title="9.3 author_url"></a>9.3 author_url</h2><p>A public URL to the author’s website to use in the <code>package.json</code>.</p><h2 id="9-4-bin"><a href="#9-4-bin" class="headerlink" title="9.4 bin"></a>9.4 bin</h2><p>A relative path from the project root for a cli script.</p><h2 id="9-5-bugs"><a href="#9-5-bugs" class="headerlink" title="9.5 bugs"></a>9.5 bugs</h2><p>A public URL to the project’s issues tracker. Will default to the github issue tracker if the project has a github repository.</p><h2 id="9-6-description"><a href="#9-6-description" class="headerlink" title="9.6 description"></a>9.6 description</h2><p>A description of the project. Used in the package.json and README files.</p><h2 id="9-7-grunt-version"><a href="#9-7-grunt-version" class="headerlink" title="9.7 grunt_version"></a>9.7 grunt_version</h2><p>A valid semantic version range descriptor of Grunt the project requires.</p><h2 id="9-8-homepage"><a href="#9-8-homepage" class="headerlink" title="9.8 homepage"></a>9.8 homepage</h2><p>A public URL to the project’s home page. Will default to the github url if a github repository.</p><h2 id="9-9-jquery-version"><a href="#9-9-jquery-version" class="headerlink" title="9.9 jquery_version"></a>9.9 jquery_version</h2><p>If a jQuery project, the version of jQuery the project requires. Must be a valid semantic version range descriptor.</p><h2 id="9-10-licenses"><a href="#9-10-licenses" class="headerlink" title="9.10 licenses"></a>9.10 licenses</h2><p>The license(s) for the project. Multiple licenses are separated by spaces. The licenses built-in are: MIT, MPL-2.0, GPL-2.0, and Apache-2.0. Defaults to MIT. Add custom licenses with init.addLicenseFiles.</p><h2 id="9-11-main"><a href="#9-11-main" class="headerlink" title="9.11 main"></a>9.11 main</h2><p>The primary entry point of the project. Defaults to the project name within the lib folder.</p><h2 id="9-12-name"><a href="#9-12-name" class="headerlink" title="9.12 name"></a>9.12 name</h2><p>The name of the project. Will be used heavily throughout the project template. Defaults to the current working directory.</p><h2 id="9-13-node-version"><a href="#9-13-node-version" class="headerlink" title="9.13 node_version"></a>9.13 node_version</h2><p>The version of Node.js the project requires. Must be a valid semantic version range descriptor.</p><h2 id="9-14-npm-test"><a href="#9-14-npm-test" class="headerlink" title="9.14 npm_test"></a>9.14 npm_test</h2><p>The command to run tests on your project. Defaults to grunt.</p><h2 id="9-15-repository"><a href="#9-15-repository" class="headerlink" title="9.15 repository"></a>9.15 repository</h2><p>Project’s git repository. Defaults to a guess of a github url.<br>9.16 title ⬆</p><p>A human readable project name. Defaults to the actual project name altered to be more human readable.</p><h2 id="9-17-version"><a href="#9-17-version" class="headerlink" title="9.17 version"></a>9.17 version</h2><p>The version of the project. Defaults to the first valid semantic version, 0.1.0.</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> engineered </tag>
            
            <tag> grunt </tag>
            
            <tag> front-end </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux performance tools</title>
      <link href="2014/12/09/linux-performance-tools/"/>
      <url>2014/12/09/linux-performance-tools/</url>
      
        <content type="html"><![CDATA[<p>先挖个坑，慢慢填。</p><p><img src="/images/blog/linux_observability_tools.png" alt="Linux Performace Tools"></p><p><a href="http://www.brendangregg.com/blog/2014-11-22/linux-perf-tools-2014.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zsh在scp时不能使用通配符的原因和解决方案</title>
      <link href="2014/12/09/zsh-scp-wildcard/"/>
      <url>2014/12/09/zsh-scp-wildcard/</url>
      
        <content type="html"><![CDATA[<p>scp是我们经常使用的一个本地与远程服务器相互cp数据的命令，zsh是我最喜欢的shell，但是在zsh下使用scp来cp远程服务器的文件时，却出现这样的错误。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">scp <span class="string">ip:</span><span class="regexp">/home/</span>tonydeng<span class="regexp">/logs/</span>*.log .</span><br><span class="line"><span class="string">zsh:</span> no matches <span class="string">found:</span> <span class="string">ip:</span><span class="regexp">/home/</span>tonydeng<span class="regexp">/logs/</span>*.log</span><br></pre></td></tr></table></figure><p>同样地命令，在bash下确实可以执行的，这个原因是什么呢？</p><a id="more"></a><p>由于zsh不会按照远程地址上的文件去扩展参数，当你使用<code>ip:/home/tonydeng/logs/*.log</code>，因为本地当前目录中，是不存在<code>ip:/home/tonydeng/logs/*.log</code>，所以匹配失败。默认情况下，bash 在匹配失败时就使用原来的内容，zsh 则报告一个<code>no matches</code>的错误。</p><p>在zsh中执行<code>setopt nonomatch</code>，告诉它不要报告<code>no matches</code>的错误，而是当匹配失败时直接使用原来的内容。</p><p>实际上，不管是 bash 还是 zsh，不管设置了什么选项，只要把<code>ip:/home/tonydeng/logs/*.log</code>加上引号，如<code>&quot;ip:/home/tonydeng/logs/*.log&quot;</code>，就可解决问题。</p><p>当然根本的解决办法还是告诉zsh不要报告<code>no matches</code>错误。</p><p>建议你执行下面的命令一劳永逸，好好享受zsh给你带来的快乐和便利吧。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"setopt nonomatch"</span> &gt;&gt; ~<span class="string">/.zshrc</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"set -o nonomatch"</span> &gt;&gt; ~<span class="string">/.zshrc</span></span><br></pre></td></tr></table></figure><p>其实我之前的<a href="/blog/2014/12/07/octopress-can-not-create-new-post-on-zsh/">这篇blog</a>也是同样的原因。</p><p>参考</p><p>stackoverflow的问答<a href="http://stackoverflow.com/questions/20037364/why-zsh-tries-to-expand-and-bash-does-not" target="_blank" rel="noopener">Why zsh tries to expand * and bash does not?</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PSSH基本使用介绍</title>
      <link href="2014/12/08/pssh/"/>
      <url>2014/12/08/pssh/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/pssh.png" alt="PSSH"></p><p>pssh是一个用python编写的可以在多台服务器上执行命令的工具，同时支持拷贝文件等功能，在同类工具中还是很方便使用的。项目地址：<a href="https://code.google.com/p/parallel-ssh/" target="_blank" rel="noopener">parallel-ssh</a></p><a id="more"></a><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>Mac下可以直接使用brew来安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew  install pssh</span><br><span class="line">==&gt; Downloading https://parallel-ssh.googlecode.com/files/pssh-2.3.1.tar.gz</span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">==&gt; python setup.py install --prefix=/usr/<span class="built_in">local</span>/Cellar/pssh/2.3.1 --install-data=/usr/<span class="built_in">local</span>/Cellar/pssh/2.3.1/share</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Python modules have been installed and Homebrew<span class="string">'s site-packages is not</span></span><br><span class="line"><span class="string">in your Python sys.path, so you will not be able to import the modules</span></span><br><span class="line"><span class="string">this formula installed. If you plan to develop with these modules,</span></span><br><span class="line"><span class="string">please run:</span></span><br><span class="line"><span class="string">  mkdir -p /Users/tonydeng/Library/Python/2.7/lib/python/site-packages</span></span><br><span class="line"><span class="string">  echo '</span>import site; site.addsitedir(<span class="string">"/usr/local/lib/python2.7/site-packages"</span>)<span class="string">' &gt;&gt; /Users/tonydeng/Library/Python/2.7/lib/python/site-packages/homebrew.pth</span></span><br><span class="line"><span class="string">==&gt; Summary</span></span><br><span class="line"><span class="string">🍺  /usr/local/Cellar/pssh/2.3.1: 40 files, 228K, built in 9 seconds</span></span><br></pre></td></tr></table></figure><p>其他平台安装方法类似</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://parallel-ssh.googlecode.com/files/pssh-2.3.1.tar.gz</span><br><span class="line">tar zxvf pssh-2.3.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> pssh-2.3.1</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>pssh安装包给我们提供了多个非常实用的工具，我们可以查看一下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  pssh  ll /usr/<span class="built_in">local</span>/Cellar/pssh/2.3.1/bin</span><br><span class="line">total 48</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   141B 12  8 15:32 pnuke</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   142B 12  8 15:32 prsync</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   140B 12  8 15:32 pscp</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   142B 12  8 15:32 pslurp</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   140B 12  8 15:32 pssh</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   148B 12  8 15:32 pssh-askpass</span><br></pre></td></tr></table></figure><p>提供的工具作用如下：</p><ol><li>parallel-ssh （pssh） 在多个主机上并行地运行命令。</li><li>parallel-scp （pscp）把文件并行地复制到多个主机上。</li><li>parallel-rsync （psync）通过 rsync 协议把文件高效地并行复制到多个主机上。</li><li>parallel-slurp （pslurp）把文件并行地从多个远程主机复制到中心主机上。</li><li>parallel-nuke （pnuke）并行地在多个远程主机上杀死进程。</li></ol><h2 id="pssh基本使用方法"><a href="#pssh基本使用方法" class="headerlink" title="pssh基本使用方法"></a>pssh基本使用方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pssh -h host.txt -P <span class="string">"command"</span></span><br></pre></td></tr></table></figure><p>如果对pssh的参数不太明白的话，可使用–help来获得帮助。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  pssh  pssh --<span class="built_in">help</span></span><br><span class="line">Usage: pssh [OPTIONS] <span class="built_in">command</span> [...]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --version             show program<span class="string">'s version number and exit</span></span><br><span class="line"><span class="string">  --help                show this help message and exit</span></span><br><span class="line"><span class="string">  -h HOST_FILE, --hosts=HOST_FILE</span></span><br><span class="line"><span class="string">                        hosts file (each line "[user@]host[:port]")</span></span><br><span class="line"><span class="string">  -H HOST_STRING, --host=HOST_STRING</span></span><br><span class="line"><span class="string">                        additional host entries ("[user@]host[:port]")</span></span><br><span class="line"><span class="string">  -l USER, --user=USER  username (OPTIONAL)</span></span><br><span class="line"><span class="string">  -p PAR, --par=PAR     max number of parallel threads (OPTIONAL)</span></span><br><span class="line"><span class="string">  -o OUTDIR, --outdir=OUTDIR</span></span><br><span class="line"><span class="string">                        output directory for stdout files (OPTIONAL)</span></span><br><span class="line"><span class="string">  -e ERRDIR, --errdir=ERRDIR</span></span><br><span class="line"><span class="string">                        output directory for stderr files (OPTIONAL)</span></span><br><span class="line"><span class="string">  -t TIMEOUT, --timeout=TIMEOUT</span></span><br><span class="line"><span class="string">                        timeout (secs) (0 = no timeout) per host (OPTIONAL)</span></span><br><span class="line"><span class="string">  -O OPTION, --option=OPTION</span></span><br><span class="line"><span class="string">                        SSH option (OPTIONAL)</span></span><br><span class="line"><span class="string">  -v, --verbose         turn on warning and diagnostic messages (OPTIONAL)</span></span><br><span class="line"><span class="string">  -A, --askpass         Ask for a password (OPTIONAL)</span></span><br><span class="line"><span class="string">  -x ARGS, --extra-args=ARGS</span></span><br><span class="line"><span class="string">                        Extra command-line arguments, with processing for</span></span><br><span class="line"><span class="string">                        spaces, quotes, and backslashes</span></span><br><span class="line"><span class="string">  -X ARG, --extra-arg=ARG</span></span><br><span class="line"><span class="string">                        Extra command-line argument</span></span><br><span class="line"><span class="string">  -i, --inline          inline aggregated output and error for each server</span></span><br><span class="line"><span class="string">  --inline-stdout       inline standard output for each server</span></span><br><span class="line"><span class="string">  -I, --send-input      read from standard input and send as input to ssh</span></span><br><span class="line"><span class="string">  -P, --print           print output as we get it</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example: pssh -h hosts.txt -l irb2 -o /tmp/foo uptime</span></span><br></pre></td></tr></table></figure><p>简单解释一下pssh help提供的例子。在hosts.txt中列出来的服务器上远程执行uptime命令，并将执行结果输出到/tmp/uptime目录下相应地服务器的文件中。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pssh -h hosts.txt -l root -o /tmp/uptime uptime</span><br></pre></td></tr></table></figure><p>其中相关参数说明：</p><blockquote><p>-h hosts.txt 指定服务器列表的文件为hosts.txt</p><p>-l root 指定远程用户为root</p><p>-o /tmp/uptime 指定远程命令执行返回结果输出目录为/tmp/uptime</p><p>uptime 指定远程服务器上执行的命令为uptime</p></blockquote><p>我们执行一下看看，执行结果说明在172.18.10.25和172.18.10.24两台服务器上执行成功。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1] 09:51:28 [SUCCESS] 172.18.10.25</span><br><span class="line">[2] 09:51:28 [SUCCESS] 172.18.10.24</span><br></pre></td></tr></table></figure><p>查看执行结果输出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l /tmp/uptime</span><br><span class="line">-rw-r--r--  1 tonydeng  wheel    71B 12  9 09:51 172.18.10.24</span><br><span class="line">-rw-r--r--  1 tonydeng  wheel    71B 12  9 09:51 172.18.10.25</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">cat /tmp/uptime/<span class="number">172.18</span><span class="number">.10</span><span class="number">.24</span></span><br><span class="line"><span class="number">09</span>:<span class="number">51</span>:<span class="number">26</span> up <span class="number">59</span> days, <span class="number">13</span>:<span class="number">48</span>,  <span class="number">0</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br><span class="line"></span><br><span class="line">cat /tmp/uptime/<span class="number">172.18</span><span class="number">.10</span><span class="number">.25</span></span><br><span class="line"><span class="number">09</span>:<span class="number">51</span>:<span class="number">26</span> up <span class="number">59</span> days, <span class="number">13</span>:<span class="number">47</span>,  <span class="number">0</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br></pre></td></tr></table></figure><p>通过这个例子大家应该能够明白pssh的使用方法了吧。</p><h2 id="pscp基本用法"><a href="#pscp基本用法" class="headerlink" title="pscp基本用法"></a>pscp基本用法</h2><p><code>pscp</code>用来将文件并行的复制到多个主机上。</p><p><code>pscp</code>和<code>pssh</code>的很多参数都是一样的，就不在多说了，举一个简单的例子来说明一下<code>pscp</code>的简单实用。</p><p>基本使用方法:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pscp -h ip文件 本地文件 远程目录</span><br></pre></td></tr></table></figure><p>例子:将本机的<code>/tmp/i.txt</code>文件复制到<code>host.txt</code>列出的主机上的<code>/tmp</code>目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pscp -h hosts.txt -l root /tmp/i.txt /tmp</span><br><span class="line">[1] 09:52:28 [SUCCESS] 172.18.10.25</span><br><span class="line">[2] 09:52:28 [SUCCESS] 172.18.10.24</span><br></pre></td></tr></table></figure><p><strong>特别参数说明：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-r 用于递归的复制目录</span><br></pre></td></tr></table></figure><h2 id="pslurp基本用法"><a href="#pslurp基本用法" class="headerlink" title="pslurp基本用法"></a>pslurp基本用法</h2><p><code>pslurp</code>把文件并行地从多个远程主机复制到中心主机上</p><p>基本用法:</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">plurp</span> -h <span class="built_in">ip</span>文件  -L 本地目录  远程文件 本地文件名称</span><br></pre></td></tr></table></figure><p>例子： 将<code>host.txt</code>列出的主机上的<code>/tmp/i.txt</code>文件复制到本机的<code>/tmp/i.txt</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pslurp -h host.txt -l root -L /tmp /tmp/i.txt i.txt</span><br><span class="line">[1] 09:53:28 [SUCCESS] 172.18.10.25</span><br><span class="line">[2] 09:53:28 [SUCCESS] 172.18.10.24</span><br></pre></td></tr></table></figure><p>特别参数说明：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-L 指定本地存放文件的目录</span></span><br></pre></td></tr></table></figure><p>虽然帮助文档中说 <code>-L</code> 参数是可选的，但是经过我试验 <code>-L</code> 参数是必须的，要不然会报错。</p><p>增加 <code>-L</code> 参数后，会在 <code>-L</code> 指定的本地目录下创建<code>[用户@]主机IP[:端口]</code>目录，对应的目录下用于存放从改主机复制过来的文件。</p><h2 id="pnuke基本使用"><a href="#pnuke基本使用" class="headerlink" title="pnuke基本使用"></a>pnuke基本使用</h2><p><code>pnuke</code>并行地在多个远程主机上杀死进程。</p><p><code>pnuke</code> 的参数与<code>pssh</code>一样,只是最后的字符串为要结束的进程名称</p><p>例子： 将<code>host.txt</code>列出的主机上的<code>httpd</code>进程杀死</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pnuke -h host.txt -l root httpd</span><br><span class="line">[1] 09:55:28 [SUCCESS] 172.18.10.25</span><br><span class="line">[2] 09:55:28 [SUCCESS] 172.18.10.24</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> pssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>效率脚本:删除指定项目的所有feature分支</title>
      <link href="2014/12/08/auto-delete-feature-branchs/"/>
      <url>2014/12/08/auto-delete-feature-branchs/</url>
      
        <content type="html"><![CDATA[<p>使用Git来管理代码，的确给我们带来很多方便，尤其是使用gitflow流程，让我们开发流程更加清晰，响应需求变化速度更快。</p><p>由于我们基于gitlab来进行code review，所有的分支都会push到远程仓库来进行code review。当一个版本完成之后，在远程和本地都会存在一些过期的、无用的分支。对于有些强迫症的我来说，保留这些无用的分支实在很难受，一个一个手工的删除这些分支也不符合我的风格，还是写个脚本来批量处理吧。</p><a id="more"></a><h2 id="删除哪些分支？"><a href="#删除哪些分支？" class="headerlink" title="删除哪些分支？"></a>删除哪些分支？</h2><p>由于大部分的过期的分支都是feature分支，所以我们就来这些已经合并过的本地和远程的feature分支吧。</p><h3 id="Shell脚本如下："><a href="#Shell脚本如下：" class="headerlink" title="Shell脚本如下："></a>Shell脚本如下：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">WORKSPACE=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$WORKSPACE</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$WORKSPACE</span></span><br><span class="line"></span><br><span class="line">BRANCHS=`git branch -r|awk -F <span class="string">'/'</span> <span class="string">'&#123;if($2=="feature")print $2"/"$3"/"$4&#125;'</span>`</span><br><span class="line"><span class="keyword">for</span> br <span class="keyword">in</span> <span class="variable">$BRANCHS</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        local_result=`git branch -d <span class="variable">$br</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"git branch -d <span class="variable">$br</span> result: <span class="variable">$local_result</span>"</span></span><br><span class="line">        remote_result=`git push origin :<span class="variable">$br</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"git push origin :<span class="variable">$br</span> result: <span class="variable">$remote_result</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BRANCHS</span></span><br></pre></td></tr></table></figure><h3 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/sh/git/feature_branch_del.sh your_git_project</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> git </tag>
            
            <tag> script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Octopress Can Not Create new Post on Zsh</title>
      <link href="2014/12/07/octopress-can-not-create-new-post-on-zsh/"/>
      <url>2014/12/07/octopress-can-not-create-new-post-on-zsh/</url>
      
        <content type="html"><![CDATA[<p>在<strong>zsh</strong>中执行rake new_post[“Title”]时会报错，提示”no matches found”。</p><p>原因是<strong>zsh</strong>中若出现下列符合，则将识别为查找文件名的通配符。</p><blockquote><p>‘*’, ‘(’, ‘|’, ‘&lt;’, ‘[’, or ‘?’</p></blockquote><p>很不幸的时，我们在octopress中创建新blog的命令就出现了“[”这个符号。</p><p>报错信息如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">➜  <span class="selector-tag">tonydeng</span><span class="selector-class">.github</span><span class="selector-class">.io</span> <span class="selector-tag">git</span><span class="selector-pseudo">:(source)</span> <span class="selector-tag">rake</span> <span class="selector-tag">new_post</span><span class="selector-attr">[<span class="string">"title"</span>]</span></span><br><span class="line"><span class="selector-tag">zsh</span>: <span class="selector-tag">no</span> <span class="selector-tag">matches</span> <span class="selector-tag">found</span>: <span class="selector-tag">new_post</span><span class="selector-attr">[title]</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>解决方法有两个：</p><p>1、 快速解决法，将rake之后都用双引号“”括起来：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">➜  <span class="selector-tag">tonydeng</span><span class="selector-class">.github</span><span class="selector-class">.io</span> <span class="selector-tag">git</span><span class="selector-pseudo">:(source)</span> <span class="selector-tag">rake</span> "<span class="selector-tag">new_post</span><span class="selector-attr">[title]</span>"</span><br></pre></td></tr></table></figure><p>2、 彻底解决法，在执行rake时，取消zsh的通配(GLOB)：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">➜  tonydeng.github.io gi<span class="variable">t:</span>(<span class="keyword">source</span>) <span class="keyword">echo</span> <span class="string">"alias rake='noglob rake'"</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>oh-my-zsh的<a href="https://github.com/robbyrussell/oh-my-zsh/issues/433" target="_blank" rel="noopener">issue #443</a></p><p>Mike Ballou的文章 <a href="http://mikeballou.com/blog/2011/07/18/zsh-and-rake-parameters/" target="_blank" rel="noopener">ZSH and Rake Parameters</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> zsh </tag>
            
            <tag> octopress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX设计哲学</title>
      <link href="2009/10/27/the-design-philosophy-to-UNIX/"/>
      <url>2009/10/27/the-design-philosophy-to-UNIX/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/kiss.png" alt="KISS"></p><p>现在所有常用的操作系统基本上都是在Unix的基础上衍生–Mac OSX、Linux（最少是借鉴–Windows）出来的，而且基本上大学的操作系统的课程也是拿Unix系统来讲解的。</p><a id="more"></a><p>最近在看<a href="http://book.douban.com/subject/1467587/" target="_blank" rel="noopener">《Unix 编程艺术》</a>这本书，上网搜索了相关的信息，发现好多人都在谈论“UNIX设计哲学”。<a href="http://en.wikipedia.org/wiki/Unix_philosophy#cite_note-0" target="_blank" rel="noopener">Wikipedia</a>上也列出了好几个版本，不同的人有不同的总结。</p><p>不过，这几个版本中所有人都同意** “简单原则”–尽量用简单的方法解决问题–是“Unix哲学”的根本原则 **。这也就是著名的<code>KISS(keep it simple,stupid)</code>，意思是“保持简单和笨拙”。关于KIIS大家可以看<a href="http://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html" target="_blank" rel="noopener">阮一峰大大的Blog</a></p><p>Unix哲学中更多的内容不是这些先哲们口头表述出来的，而是由他们所作的一切和Unix本身所作出的榜样体现出来的。</p><p>从整体上来说，可以概括为以下几点：</p><ol><li><p>模块原则：使用简洁的接口拼合简单的部件。</p></li><li><p>清晰原则：清晰胜于机巧。</p></li><li><p>组合原则：设计时考虑拼接组合。</p></li><li><p>分离原则：策略同机制分离，接口同引擎分离。</p></li><li><p>简洁原则：设计要简洁，复杂度能低则低。</p></li><li><p>吝啬原则：除非确无他法，不要编写庞大的程序。</p></li><li><p>透明性原则：设计要可见，以便审查和调试。</p></li><li><p>健壮原则：健壮源于透明与简洁。</p></li><li><p>表示原则：把知识叠入数据以求逻辑质朴而健壮。</p></li><li><p>通俗原则：接口设计避免标新立异。</p></li><li><p>缄默原则：如果一个程序没什么好说的，就沉默。</p></li><li><p>补救原则：出现异常时，马上退出并给出足够错误信息。</p></li><li><p>经济原则：宁花机器一分，不花程序员一秒。</p></li><li><p>生成原则：避免手工hack，尽量编写程序去生成程序。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> engineered </tag>
            
            <tag> unix </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你是一个够职业的软件工程师吗？</title>
      <link href="2009/10/19/are-you-a-professional-engineer/"/>
      <url>2009/10/19/are-you-a-professional-engineer/</url>
      
        <content type="html"><![CDATA[<p>这两天看了一个这样的文章<a href="http://www.programmer.com.cn/1041/" target="_blank" rel="noopener">《软件工程师的十个“不职业”行为》</a>，是陈尚义老师整理分享的。看完之后，抚心自问，自己还是比较职业的软件工程师。</p><p>现在将这十条不职业的行为摘录下来，时刻提醒自己。</p><ul><li><p>行为一：对外交付半成品。</p></li><li><p>行为二：不遵守标准和规范。</p></li><li><p>行为三：不积极帮助他人。</p></li><li><p>行为四：版权意识不敏感。（这点要注意）</p></li><li><p>行为五：对待计划不严肃。</p></li><li><p>行为六：公事私事想混淆。</p></li><li><p>行为七：不注意更新自己。</p></li><li><p>行为八：不主动与人沟通。</p></li><li><p>行为九：不遵守职场规则。</p></li><li><p>行为十：不够诚实和正直</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程师文化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> engineered </tag>
            
            <tag> professional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中setuid、setgid及sticky bit的区别</title>
      <link href="2007/04/06/the-difference-between-setuid-setgid-and-sticky-bit-in-linux/"/>
      <url>2007/04/06/the-difference-between-setuid-setgid-and-sticky-bit-in-linux/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/linux-access-control.png" alt="Linux File System Access Control"></p><p><code>Linux</code>中除了常见的读（<code>r</code>）、写（<code>w</code>）、执行（<code>x</code>）权限以外，还有3个特殊的权限，分别是<code>setuid</code>、<code>setgid</code>和<code>stick bit</code>。</p><p>这些特殊的权限，在被执行时都会有特殊的用处。如果不了解，很容易被黑客利用这些权限的特性来获得系统更高级的权限，甚至对系统造成无法挽回的伤害。</p><a id="more"></a><h2 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h2><ul><li><code>setuid</code>: 在执行时具有文件所有者的权限.</li><li><code>setgid</code>: 设置目录. 一个目录被标上<code>setgid</code>位,此目录下创建的文件继承该目录的属性.</li><li><code>sticky bit</code>: 该位可以理解为防删除位. 设置<code>sticky bit</code>位后，就算用户对目录具有写权限，但也只能添加文件而不能删除文件。</li></ul><h2 id="系统已有的特殊权限相关文件"><a href="#系统已有的特殊权限相关文件" class="headerlink" title="系统已有的特殊权限相关文件"></a>系统已有的特殊权限相关文件</h2><h3 id="setuid"><a href="#setuid" class="headerlink" title="setuid"></a><code>setuid</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -l /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 27832 6月  10 2006 /usr/bin/passwd</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -l /usr/bin/chsh</span><br><span class="line">-rws--x--x 1 root root 23872 8月   4 2006 /usr/bin/chsh</span><br></pre></td></tr></table></figure><h3 id="setgid"><a href="#setgid" class="headerlink" title="setgid"></a><code>setgid</code></h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ ls -l /usr/bin/write</span><br><span class="line">-rwxr-sr-x <span class="number">1</span> root tty <span class="number">19536</span> <span class="number">8</span>月   <span class="number">4</span> <span class="number">2006</span> /usr/bin/write</span><br></pre></td></tr></table></figure><h3 id="sticky-bit"><a href="#sticky-bit" class="headerlink" title="sticky bit"></a><code>sticky bit</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -l -d /tmp</span><br><span class="line">drwxrwxrwt. 9 root root 198 3月   6 03:44 /tmp</span><br></pre></td></tr></table></figure><h2 id="如何设置："><a href="#如何设置：" class="headerlink" title="如何设置："></a>如何设置：</h2><p>操作这些标志与操作文件权限的命令是一样的, 都是使用<code>chmod</code>。</p><p>有两种方法对这些标志来操作</p><ol><li><p><code>chmod u+s temp</code> – 为<code>temp</code>文件加上<code>setuid</code>标志. (<code>setuid</code> 只对文件有效，<code>u</code>=用户)<br><code>chmod g+s tempdir</code> – 为<code>tempdir</code>目录加上<code>setgid</code>标志 (<code>setgid</code> 只对目录有效，<code>g</code>=组名)<br><code>chmod o+t temp</code> – 为<code>temp</code>文件加上<code>sticky</code>标志 (<code>sticky</code>只对文件有效)</p></li><li><p>采用八进制方式. 这一组八进制数字三位的意义如下,<br><code>abc</code><br><code>a</code> - <code>setuid</code>位, 如果该位为<code>1</code>, 则表示设置<code>setuid </code><br><code>b</code> - <code>setgid</code>位, 如果该位为<code>1</code>, 则表示设置<code>setgid </code><br><code>c</code> - <code>sticky</code>位, 如果该位为<code>1</code>, 则表示设置<code>sticky</code></p></li></ol><p>设置后, 可以用 <code>ls -l</code> 来查看. 如果本来在该位上有<code>x</code>, 则这些特殊标志显示为小写字母 (<code>s, s, t</code>). 否则, 显示为大写字母 <code>(S, S, T</code>)<br>如:</p><p><code>rwsrw-r--</code> 表示有<code>setuid</code>标志 (<code>rwxrw-r--:rwsrw-r--</code>)<br><code>rwxrwsrw-</code> 表示有<code>setgid</code>标志 (<code>rwxrwxrw-:rwxrwsrw-</code>)<br><code>rwxrw-rwt</code> 表示有<code>sticky</code>标志 (<code>rwxrw-rwx:rwxrw-rwt</code>)</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://www.linuxvoice.com/core-technology-access-control/" target="_blank" rel="noopener">CORE TECHNOLOGY: ACCESS CONTROL</a><br><a href="https://www.youtube.com/watch?v=vKcb8M6mczA" target="_blank" rel="noopener">SADS: SetUid and SetGUID and sticky bit (Linux File Permissions)</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> setuid </tag>
            
            <tag> setgid </tag>
            
            <tag> sticky bit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash中的快捷键</title>
      <link href="2007/03/06/shortcuts-in-bash/"/>
      <url>2007/03/06/shortcuts-in-bash/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/shortcuts-bash.jpg" alt="快捷键"></p><p><code>ctrl+p</code> 向上翻以前使用的命令<br><code>ctrl+n</code> 向下翻以前使用的命令<br><code>ctrl+a</code> 光标移到命令行的开始<br><code>ctrl+e</code> 光标移到命令行的结尾<br><code>ctrl+d</code> 删除当前光标下的字符<br><code>ctrl+h</code> 删除当前光标前的字符<br><code>ctrl+f</code> 光标向后移动一位<br><code>ctrl+b</code> 光标向前移动一位<br><code>ctrl+u</code> 删除光标以前的所有字符<br><code>ctrl+k</code> 删除光标以后的所有字符<br><code>ctrl+w</code> 删除光标前的一个单词</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> bash </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一条Linux命令，一段人类文明</title>
      <link href="2006/03/28/A-Linux-command-a-human-civilization/"/>
      <url>2006/03/28/A-Linux-command-a-human-civilization/</url>
      
        <content type="html"><![CDATA[<p>以前听人说在Linux上可以查到一个很奇怪的月份，只是当时忘了那个特殊的月份。今天在网上搜了一下，发现通过这个命令（月份）了解了一段人类文明历史。呵呵。虽然和Linux没什么关系，但是确实是因为Linux才让我了解到的。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">~ cal <span class="number">9</span> <span class="number">1752</span></span><br><span class="line"></span><br><span class="line">September <span class="number">1752</span></span><br><span class="line">S M Tu W Th F S</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>我们发现1752年9月2日的后面竟然是14日，确实很奇怪，通过在网上搜索，找到了答案：</p><p>1582年2月，罗马教廷要求从1582 年10月中减去10天，因此1852 年10月4日后面紧跟着就是15日。 在意大利、西班牙等国家都这样处理了。其他天主教国家也很快跟着这么做了，但是新教国家不愿意修改， 而且希腊等东正教国家直到20世纪初才修改，所以这个改革在英国及其殖民地（包括美国）在1752年9月才被执行。这样 1752 年9月2日后面跟着的就是1752 年9月14日。 这就是为什么cal会生成上面输出的原因了。</p><p>为什么减去10天得原因是由于地球章动的常年累月的影响累计，历法已经不准了。虽然是罗马教皇宣布的，但是其实是天文学家们计算得出来的。</p><p>P.S.：Windows用户是没福气查到这个特殊月份了，因为Windows的纪年范围只是1980-2099。呵呵</p>]]></content>
      
      
      <categories>
          
          <category> 工程师文化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我所衷爱的仙桃菜</title>
      <link href="2005/03/17/the-xiantao-dishes-i-love/"/>
      <url>2005/03/17/the-xiantao-dishes-i-love/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/blog/xiantao/xiantao.gif" alt="仙桃"></p><p>仙桃市是湖北的一个小城市，临近武汉。说起来您也许不太熟悉这个名字，但若提起体操界的“双李”（大双小双），那确是妇孺皆知的。没错，仙桃就是有着“体操之乡”美名的我的故乡。仙桃原名沔阳，在饮食上以她的“沔阳三蒸”闻名。</p><a id="more"></a><p><img src="/images/blog/xiantao/three-steamed.jpg" alt="沔阳三蒸"></p><p>沔阳三蒸，即蒸鱼、蒸肉、蒸菜，因菜分三种故得三蒸之名。湖北人做起蒸菜，与一般江浙人家的清蒸鱼之类的菜，是截然不同的。江浙人家的清蒸菜，用料极简， 只是将姜丝葱蒜裹进鱼肚子里，搁进蒸笼清蒸而成，味道太过清淡。湖北人做起蒸菜，特别是我家乡的沔阳三蒸，却是大操大办，极有气派的。人人家里都有一口大甄(<code>zhen</code>第四声)，形如水桶，质为实木，直径约有两尺，高达六、七十公分，看起来蛮笨重的，但做起蒸菜来却非它不可。</p><p>湖北人请客吃饭，一般喜欢在家里操办。那蒸菜是必不可少的三道菜。请两三桌客就要动甄(<code>zhen</code>第四声)了。饭和菜一起蒸，更有滋味。</p><p>先淘洗好三五斤米，搁在蒸笼底层，其上用薄纱布隔开，纱布上先放一层约5厘米厚洗净剁烂的蔬菜，蔬菜上再放置切好的鱼块和肉块，就可以开蒸了。您看我说 得好像很简单，其实这里面的手续复杂着呢。先说这蔬菜吧，可放同一种蔬菜，也可放两三种不同的蔬菜，如果是叶状的蔬菜，如茼蒿或青菜，要先剁得碎碎的，和 事先调好的米粉拌匀了，再放好食盐，味精，香料，这才算好。若是块状的菜，如土豆、莲藕，豆腐丸子等，要先做成鹌鹑蛋般大小的块，也是和混着食盐味精香料 的米粉一起拌匀了，妥妥贴贴的搁在米上。鱼和肉要选新鲜的，腌制过的虽然也可以蒸，但味道总不如新鲜的蒸出来地道。鱼和肉先切块，同样拌上米粉。这米呀、 菜呀、鱼呀、肉呀，都收拾好了，就可以将甄上锅开始蒸了。装好这些东西的蒸笼很重，得由大力气的男人才能搬上锅。用来蒸蒸笼的锅当然不是一般炒菜用的小钢 筋锅，得用直径接近一米的大铁锅，锅里先放好小半锅烧得半开的水，再放上蒸笼，蒸笼上盖好木头做的斗笠形状的盖子，灶膛里面架起火，开始蒸。</p><p>足足蒸上他两个钟头，这才慢慢闻到菜的香味了。做蒸菜是不用放油的。因为这蒸笼的上层是搁着鱼和肉的，蒸汽蒸得这鱼和肉的油都慢慢流出来了，一层层的沁到 下面的蔬菜里面，裹着米粉的蔬菜吸收了想像鱼肉的油香，就不需要再另放食油了。最底层的米饭也熟了。这蒸笼里的米、菜和肉，相互吸收彼此的味道，鱼肉吸收 大米和蔬菜的清爽，大米和蔬菜也因吸收鱼肉的油脂变得更加可口。</p><p>用大海碗一碗一碗的盛出来了。蒸鱼蒸肉和蒸菜要分开装，每一碗上都淋上事先调好的汤料，最多的是醋，再加上一点点的麻油，这些汤料慢慢的沁到这一碗菜里，就更美味了。</p><p>等到要吃的时候，将扣在菜上的小碗揭开，嗯～，香气扑面而来呀！</p><p>这沔阳三蒸里面，我最衷爱的是蒸菜，特别是蒸的茼蒿和土豆，蒸好的茼蒿裹着清香的米粉、爽口的香醋和麻油，粘绵得化不开，挑起一团放进口里，又香又烫，真 是美味。蒸土豆那更是又美味又漂亮。特别是我老妈做的蒸土豆，味道调得好不说，那火候更是掌握的恰到好处，蒸出来的土豆一块块金黄的，通透的，看起来像是 有油快流出来，美味无匹，回味到如今！</p><p>仙桃菜没有什么太大的名气，但是却是最家常，最适合一家人围桌吃饭之用的。</p><p><img src="/images/blog/xiantao/lihao.jpg" alt="炒藜蒿"></p><p>除了沔阳三蒸之外，还有一味别的地方没有的美味，就是炒藜蒿。藜蒿分家生和野生两种，家生的也就罢了，那野生的藜蒿，用腊肉和青辣椒爆炒，美味得不得了。 我们家乡还有一种做法，就是将采来的野生藜蒿装到一个大蛇皮袋子里，捆扎好了，用大石头压紧，让这新鲜的蔬菜在里面糅烂了。拿出来叶子一抖就直掉下来，只 剩下仍然青翠的茎干。这半尺来长，铁丝般粗细的藜蒿茎，炒起来特别带劲，又脆又香，如果您能够吃辣，那就更好了，因为如果藜蒿加上很多的辣椒一起炒，更加 香辣。</p><p>呜呼，写得我口水都快流出来了。您哪天到湖北来，到仙桃来，可千万别错过了这两道美味！</p>]]></content>
      
      
      <categories>
          
          <category> 生活感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美食 </tag>
            
            <tag> 仙桃 </tag>
            
            <tag> 仙桃菜 </tag>
            
            <tag> 家乡菜 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
