<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TonyDeng&#39;s Blog</title>
  
  <subtitle>“In me the tiger sniffes the rose.” -- Siegfried Sasson</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tonydeng.github.io/"/>
  <updated>2019-06-20T12:10:27.481Z</updated>
  <id>http://tonydeng.github.io/</id>
  
  <author>
    <name>Tony Deng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Pyenv介绍</title>
    <link href="http://tonydeng.github.io/2018/02/27/pyenv/"/>
    <id>http://tonydeng.github.io/2018/02/27/pyenv/</id>
    <published>2018-02-27T04:57:55.000Z</published>
    <updated>2019-06-20T12:10:27.481Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog/python-2-vs-python-3.jpg" alt="python 2 vs python 3"></p><p>去年 11 月，<a href="http://www.numpy.org/" target="_blank" rel="noopener">Numpy</a>团队的一份声明引发了<code>Python</code>社区的关注：这一科学计算库即将放弃对于 <code>Python 2.7</code> 的支持，全面转向<code>Python 3</code>。</p><blockquote><p>声明原文<a href="https://github.com/numpy/numpy/blob/master/doc/neps/dropping-python2.7-proposal.rst" target="_blank" rel="noopener">Plan for dropping Python 2.7 support</a></p></blockquote><a id="more"></a><p>不过，还是有很多<code>Python</code>的项目依然还是使用<code>2.7</code>的版本来进行开发和维护。尤其是我这种喜欢折腾新东西的人来说，一门语言同时在一个系统中存在多个版本是一个非常正常的事情。也经常有同学来问我<code>Python</code>不同版本之间兼容和切换的问题。</p><p>今天给大家推荐一下<code>Python</code>环境管理的工具，简单整理一下<code>pyenv</code>相关的介绍和使用。</p><p><code>pyenv</code>是一个非常好用的<code>Python</code>环境管理工具。</p><p>有这些主要特性：</p><ol><li>方便的安装、管理不同版本的<code>Python</code>，而且不需要<code>sudo</code>权限，不会污染系统的<code>Python</code>版本</li><li>可以修改当前用户使用的默认<code>Python</code>版本</li><li>集成<code>virtualenv</code>，自动安装、激活</li><li>命令行自动补全</li></ol><p>详细内容见 <a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">Github - pyenv/pyenv</a>.</p><h1 id="安装pyenv"><a href="#安装pyenv" class="headerlink" title="安装pyenv"></a>安装pyenv</h1><p>使用<a href="https://github.com/pyenv/pyenv-installer" target="_blank" rel="noopener">pyenv-installer</a></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">curl -L https://raw.githubusercontent.com/pyenv/pyenv-installer/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure><p>然后在<code>~/.bashrc</code>或<code>~/.zshrc</code>中添加如下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">"~/.pyenv/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv init -)</span>"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv virtualenv-init -)</span>"</span></span><br></pre></td></tr></table></figure><p><code>macOS</code>用户可以直接使用<code>brew</code>这个包管理系统直接安装<code>pyenv</code>，直接完成上述两步操作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>完整的命令行列表可以参考<a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md" target="_blank" rel="noopener">pyenv/COMMANDS.md</a>.</p><h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装<code>Python</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv install 3.6.1</span><br></pre></td></tr></table></figure><p>这个命令会为当前用户下载和安装<code>Python 3.6.1</code>。</p><h2 id="新建虚拟环境"><a href="#新建虚拟环境" class="headerlink" title="新建虚拟环境"></a>新建虚拟环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 3.6.1 py36</span><br></pre></td></tr></table></figure><p>设置当前路径使用的 Python 环境</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> py36</span><br></pre></td></tr></table></figure><p>这个命令会在当前路径创建一个<code>.python-version</code>文件，文件内容就是 <code>py36</code>，即环境名称。所以一般需要把<code>.python-version</code>添加到 <code>.gitignore</code>.</p><p>下次进入该目录时，会自动激活虚拟环境，离开后自动退出。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ol><li><a href="https://www.jiqizhixin.com/articles/2018-01-29-3" target="_blank" rel="noopener">在Python 2.7即将停止支持时，我们为你准备了一份3.x迁移指南</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog/python-2-vs-python-3.jpg&quot; alt=&quot;python 2 vs python 3&quot;&gt;&lt;/p&gt;
&lt;p&gt;去年 11 月，&lt;a href=&quot;http://www.numpy.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Numpy&lt;/a&gt;团队的一份声明引发了&lt;code&gt;Python&lt;/code&gt;社区的关注：这一科学计算库即将放弃对于 &lt;code&gt;Python 2.7&lt;/code&gt; 的支持，全面转向&lt;code&gt;Python 3&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;声明原文&lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/neps/dropping-python2.7-proposal.rst&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Plan for dropping Python 2.7 support&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="效率" scheme="http://tonydeng.github.io/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="python" scheme="http://tonydeng.github.io/tags/python/"/>
    
      <category term="pyenv" scheme="http://tonydeng.github.io/tags/pyenv/"/>
    
  </entry>
  
  <entry>
    <title>理想的创业团队原型和创建产品原则</title>
    <link href="http://tonydeng.github.io/2018/02/13/the-two-laws-of-building-products/"/>
    <id>http://tonydeng.github.io/2018/02/13/the-two-laws-of-building-products/</id>
    <published>2018-02-13T08:47:23.000Z</published>
    <updated>2019-06-20T12:10:27.481Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文谈了创建产品的原则和理想的创业团队应具备的各种技能</p></blockquote><ol><li>如果你不能销售它，不要建立它</li><li>如果你不能建立它，不要销售它</li></ol><p><a href="http://disciplinedentrepreneurship.com/" target="_blank" rel="noopener">麻省理工学院的Bill Aulet说</a> ，企业的唯一必要和充分条件是付费客户。 但这并不是一个好的业务的充分条件;相反，我们需要使用<code>IDEO</code>的<code>Tim Brown</code>提出的“<a href="https://www.ideou.com/pages/design-thinking" target="_blank" rel="noopener">设计思维</a>”方法作为指南，找到客户需求的最佳选择，在技术上可行，在商业上可行。 然后我们需要卖掉它，继续卖它，再卖一些（重要的话说三遍）。</p><p><img src="/images/blog/two-laws-of-building-products/design-thinking.png" alt="design-thinking"></p><a id="more"></a><blockquote><p>免责声明 : economic viability should be measured in your preferred currency. The value of your investments can go up as well as down. Bitcoin for illustration only.</p></blockquote><p>发现这个神奇的地方（上图中重合的🚀区域）需要太多的韧性和运气或者纪律和严谨性。许多成功的企业都是通过不断的尝试和失败而进入他们的产品/市场的，这也是为什么初创公司和小型企业的失败率如此之高的原因之一。</p><p>新企业和新产品需要从高不确定性迅速发展到尽可能快的程度(以及最小的投资)。为了加快寻找理想、可行和可行的解决方案的过程，你需要一个团队。</p><p>原文： <a href="https://medium.com/swlh/the-two-laws-of-building-products-74880772c678" target="_blank" rel="noopener">The two laws of building products</a></p><h2 id="三是神奇的数字。-四和五也很好。"><a href="#三是神奇的数字。-四和五也很好。" class="headerlink" title="三是神奇的数字。 四和五也很好。"></a>三是神奇的数字。 四和五也很好。</h2><p>遇到一个能有效挑战你的解决方案的三个方面的人的机会是微乎其微的，而且很少能找到一个能做到这一点的创业团队。当你找到这些团队的时候，这是商业成功的火箭燃料。</p><p>以我的经验来看，创业团队往往是由机遇而非精心设计的。联合创始人已经在社会上或以前的工作中相互了解，或者在他们感兴趣的事情上相识。这些偶然的会议和共同的兴趣倾向于喜欢相似的个性和技能集——产品的拥有者在产品事件中相遇，Ruby开发者在Ruby聚会上见面。因此，我们经常发现缺少必要的多样性的创业团队通过产品的三个视角来工作。相反，这是一种痛苦的经历，是一种烧钱的方式，让他们知道他们需要了解自己缺失的学科。</p><h2 id="启动原型"><a href="#启动原型" class="headerlink" title="启动原型"></a>启动原型</h2><p>几年前，在我与初创公司合作之前，我曾经历过很多次黑客日。多年来，我们尝试了不同的方法来提出想法和组建团队。我们发现了同样的自我强化困境;技术人员会寻找其他技术人员，建立技术原型，市场营销人员会寻找其他的市场营销人员，并建立令人惊叹的产品推介。这些都是令人惊奇但不平衡的作品进入了黑客日的评判。</p><p>因此，为了迫使不同的团队，我们要求人们按照原型来安排自己，并要求不同的团队使用不同的技能。</p><p><img src="/images/blog/two-laws-of-building-products/startup-archetypes.png" alt="the startup archetypes"></p><p>每个参加黑客日的人都得到了对原型的描述，并要求自己选择一个主要的和次要的类别。 然后，当团队成立时，我们问他们避免拥有多个相同的原型。</p><p>最终结果？ 我们有史以来最成功的黑客日，创造了两家新企业，它们都进入了我们的内部孵化器。</p><h2 id="原型如何映射到三个视角"><a href="#原型如何映射到三个视角" class="headerlink" title="原型如何映射到三个视角?"></a>原型如何映射到三个视角?</h2><p>任何在一段时间内从事商业活动的人都会遇到这类的销售主管，他们会为了达成协议而高兴地销售不存在的功能，而开发人员为了解决他们销售不存在的功能而苦逼的编码。</p><p>创建我们的原型的原因是为了在团队中创造一种平衡以及挑战和妥协的健康张力——我们希望开发团队挑战销售人员考虑他们所承诺的可行性,销售高管鼓励技术人员对速度完美市场交易。</p><p>我们最初使用的原型来自于对成功的创始人团队的即兴研究。我从我认识的团队中吸取了经验，并从其他创始人那里得到了一个长时间的交流，他们提出了他们的理想团队的原型。</p><p>这是一种尝试、错误和猜测，但我们发现了一个重要的实现——跨职能团队超越了亲密朋友的团队，尽管他们是在当下创建的。这个项目的挑战创造了团队合作，但这些技能却让人成功。</p><p>这些技能的重要性在于，它们会在团队成员之间制造紧张关系，从而帮助团队解决三个视角的问题。通过拉动不同的方向，代表不同的学科，团队更能想出更真实、更可爱的解决方案。</p><h2 id="新原型"><a href="#新原型" class="headerlink" title="新原型"></a>新原型</h2><p>在第一次黑客日之后的几年中，我回顾并修改了我推荐的原型。在某种程度上，这直接来自于需要解决这三个方面的问题，同时也认识到新业务的另外两个关键因素。该产品不仅需要是令人满意的、可行的和可持续发展的，而且我们还需要能够长期的销售产品或服务。</p><p><img src="/images/blog/two-laws-of-building-products/new-archetypes.png" alt="the new archetypes"></p><h3 id="梦想家"><a href="#梦想家" class="headerlink" title="梦想家"></a>梦想家</h3><p>伟大的企业是由梦想家开创的。 梦想家为企业树立了未来的愿景，并说服创始人和投资者走上旅程。 梦想家通常是首席客户传道者，他带来了最初的想法，鼓舞了员工和投资者。 梦想家是积极的，有时是不现实的; 他们面临的挑战是，他们往往不接地气，也不行动 - 他们可以把现实炸弹留在身后，而其他人可能需要捡起这些炸弹。</p><p>技能：公开演讲，投资者关系，大局思维，以客户为中心，鼓舞人心。 梦想家让团队，客户和投资者在情感上参与产品和业务。</p><h3 id="黑客"><a href="#黑客" class="headerlink" title="黑客"></a>黑客</h3><p>如果你不能建立它，不要销售它。 黑客的工作是解决现实的问题。 如果梦想家的工作是梦想不可能的事，那么黑客的工作就是让不可能的事情成为可能。</p><p>虽然梦想家可能会一直向前推进，但黑客的任务是踩下梦想家的现实炸弹，找到解决难题的真正方法。 如果你的产品是软件，黑客可能是一个程序员。 如果它是有形的，他们可能是一名工程师。 如果您提供服务，黑客是一位流程设计师。 黑客是商业的手。 然而，黑客有时可能拥有<code>Eeyore</code>一样的品质，看到每一个新想法带来的痛苦，并常常为可能的未来过度设计解决方案。</p><blockquote><p><code>Eeyore</code>是《小熊维尼和蜂蜜树》的角色，一个旧的灰色小毛驴，它悲观、过于冷静、自卑、消沉。</p></blockquote><p>技能：程序员，建筑师，工程师，科学家，木匠。 硬技能会有所不同，但黑客需要知道（或快速学习）构建解决方案所需的一切。</p><h3 id="设计师"><a href="#设计师" class="headerlink" title="设计师"></a>设计师</h3><p>设计师不仅仅是业务的艺术方面，尽管这在某种程度上属于这个角色。设计师提出了一种设计思维的方法和对产品和过程的敏感性，以达到目的和可爱。设计师通常是部分用户体验设计师，部分插画师，但所有的设计思维教练为团队的其他成员。</p><p>技能:设计思考者，海报艺术家，插画师，线框绘制者。设计师擅长于制作您的第一本小册子和您的第一个原型。</p><h3 id="骗子"><a href="#骗子" class="headerlink" title="骗子"></a>骗子</h3><p>没有骗子，你的生意不会成功。 你可能有其他角色的内向者，但是骗子是纯粹的外向型。有了骗子不用再担心接电话和给陌生人打电话，骗子会做好这些事情。虽然在没有产品的情况下有一个销售主管似乎是不必要的，但是Hustler会帮助你决定如何将你的产品推向市场，甚至是如何销售。 在活动和会议上，骗子与梦想家在舞台上争先恐后，但其中只有一个会抓取名片。</p><p>技能：推销，销路拓展，上门推销，销售流程和销售管理。 骗子把你的产品变成金钱，并且会知道销售周期的来龙去脉。</p><h3 id="分析师"><a href="#分析师" class="headerlink" title="分析师"></a>分析师</h3><p>或者，正如我亲切地称他们为“钱”。 分析师喜欢数据。给他们一个市场规模，他们就会运行这些数字。销售预测，现金消耗率，单位经济。分析师将研究你的获取客户成本、生命周期价值和你的财务状况。分析师关心的是如何把数字加起来，并保证没有赤字。</p><p>技能:不一定是会计或经济学家，分析师有可靠的数字头脑。可能来自财务或者是一个量化的角色，比如商业分析或咨询。</p><h2 id="为什么你不能在真空中做出决定。"><a href="#为什么你不能在真空中做出决定。" class="headerlink" title="为什么你不能在真空中做出决定。"></a>为什么你不能在真空中做出决定。</h2><p>团队需要做的比让顾客满意更好。 他们需要考虑在构建产品后的运营成本。 商业模式需要考虑到国际客户的销售成本，或通过搜索驱动的B2C服务中获取客户的渠道，或者运行24小时支持热线的成本。</p><p>大多数市场不再容忍成本加成的模式。 现在，市场设定了价格，您需要交付产品并获得利润。 您的成本不可能仅仅是物料清单，人工和运输。</p><p>所有这些复杂性都会在您的团队中推动创造性的对话。 随着黑客构建着梦想家向客户要求的产品，最好的解决方案是妥协。 跨职能团队允许创始人彼此学习并发展互补技能。</p><h2 id="团队是虚拟的"><a href="#团队是虚拟的" class="headerlink" title="团队是虚拟的"></a>团队是虚拟的</h2><p>尽管表面上看，我并不认为每个产品都需要一个人来代表每一个原型。相反，你需要的是一种技能的平衡，它涵盖了三个方面，每个产品和业务都有不同的需求。</p><p>尽管出现，我不相信每个产品都需要一个人代表每个原型。 相反，您正在寻找涵盖三个视角的技能平衡，并且每个产品和业务都会有不同的需求。</p><p>你的产品是否可取？ 它在技术上可行吗？ 它在商业上可行吗？ 你的团队应该能够回答所有这些问题，而不仅仅是一两个问题。团队的规模不如拥有可用的技能那么重要。</p><p>有可能你会有一个梦想家，他有外向的一面。或许你拥有一个拥有<code>MBA</code>学位的计算机专业毕业生，提供的是与黑客和分析师的能力。也许你的骗子有一个隐藏的艺术方面。重点不是要勾出原型，而是要确保你有能力正确地分析你的业务。</p><p>初创公司和小团队的美妙之处在于人们的角色定位不明确，因此需要在必要时进行投票。 原型只是你的指导，确保你可以考虑所有的角度。请记住，</p><ol><li>如果你不能销售它，不要建立它</li><li>如果你不能建立它，不要销售它</li></ol><blockquote><p>原文 ：<a href="https://medium.com/swlh/the-two-laws-of-building-products-74880772c678" target="_blank" rel="noopener">The two laws of building products</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文谈了创建产品的原则和理想的创业团队应具备的各种技能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如果你不能销售它，不要建立它&lt;/li&gt;
&lt;li&gt;如果你不能建立它，不要销售它&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://disciplinedentrepreneurship.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;麻省理工学院的Bill Aulet说&lt;/a&gt; ，企业的唯一必要和充分条件是付费客户。 但这并不是一个好的业务的充分条件;相反，我们需要使用&lt;code&gt;IDEO&lt;/code&gt;的&lt;code&gt;Tim Brown&lt;/code&gt;提出的“&lt;a href=&quot;https://www.ideou.com/pages/design-thinking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计思维&lt;/a&gt;”方法作为指南，找到客户需求的最佳选择，在技术上可行，在商业上可行。 然后我们需要卖掉它，继续卖它，再卖一些（重要的话说三遍）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/two-laws-of-building-products/design-thinking.png&quot; alt=&quot;design-thinking&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="创业" scheme="http://tonydeng.github.io/categories/%E5%88%9B%E4%B8%9A/"/>
    
    
      <category term="创业" scheme="http://tonydeng.github.io/tags/%E5%88%9B%E4%B8%9A/"/>
    
      <category term="产品" scheme="http://tonydeng.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="团队" scheme="http://tonydeng.github.io/tags/%E5%9B%A2%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>SDN之NETCONF Call Home</title>
    <link href="http://tonydeng.github.io/2017/11/28/netconf-call-home/"/>
    <id>http://tonydeng.github.io/2017/11/28/netconf-call-home/</id>
    <published>2017-11-27T16:18:35.000Z</published>
    <updated>2019-06-20T12:19:23.312Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog/netconf-callhome/rfc8071-datatracker-status.jpg" alt="rfc8071 datatracker status"></p><p>本文主要内容都来自于今年二月发布的<a href="https://tools.ietf.org/html/rfc8071" target="_blank" rel="noopener">RFC8071 - NETCONF Call Home and RESTCONF Call Home</a>，该RFC从2015年4月提出到最终发布一共修改了17个版本，其间修改内容可以<a href="https://datatracker.ietf.org/doc/rfc8071/" target="_blank" rel="noopener">点击查看详细内容</a>。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>NETCONF Call Home</code>支持两种安全传输网络配置协议分别是<code>Secure Shell(SSH)</code>和传输层安全<code>(TLS)</code>。  </p><blockquote><p><code>NETCONF</code>协议​​的绑定到<code>SSH</code>在<a href="https://tools.ietf.org/html/rfc6242" target="_blank" rel="noopener">RFC6242</a>中定义。<br><code>NETCONF</code>协议​​的绑定到<code>TLS</code>在<a href="https://tools.ietf.org/html/rfc7589" target="_blank" rel="noopener">RFC7589</a>中定义。<br><code>SSH</code>协议在<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253</a>中定义，<code>TLS</code>协议是在<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC5246</a>中定义。<code>SSH</code>和<code>TLS</code>协议都是<code>TCP</code>协议之上的协议。</p></blockquote><a id="more"></a><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p><code>call home</code>对于网络设备的初始化部署和持续管理都是非常有帮助的。那网络设备为什么使用<code>call home</code>这种方式？</p><ul><li>网络设备在第一次启动后可以主动<code>call home</code>，以便在其管理系统上注册。</li></ul><ul><li><p>网络设备可以以一种动态分配<code>IP</code>地址的方式访问网络，但是不会将其分配的IP地址注册到映射服务(例如，动态<code>DNS</code>)。</p></li><li><p>网络设备可以部署在实现所有内部网络IP地址的网络地址转换（NAT）的防火墙后面。</p></li><li><p>网络设备元件可以部署在不允许任何管理访问内部网络的防火墙之后。</p></li><li><p>网络设备可以配置为“隐身模式”，因此没有任何的端口可以提供给管理系统打开连接。</p></li><li><p>运营商可能倾向于让网络设备发起管理连接，认为在数据中心中保护一个开放端口比在网络中的每个网络设备上具有开放端口更容易。</p></li></ul><h3 id="解决方案概述"><a href="#解决方案概述" class="headerlink" title="解决方案概述"></a>解决方案概述</h3><p>下图说明了协议分层的<code>call home</code></p><p><img src="/images/blog/netconf-callhome/netconf-call-home-sequence.png" alt="NETCONF Call Home Sequence"></p><blockquote><p>消息层流程PlantUML请查看<a href="https://raw.githubusercontent.com/tonydeng/sdn-handbook/master/puml/netconf-call-home.puml" target="_blank" rel="noopener">netconf-messages-layer-flow.puml</a></p></blockquote><p>这张图有以下几点：</p><ol><li><code>NETCONF</code>服务器首先启动一个<code>TCP</code>连接到<code>NETCONF</code>客户端。</li><li>使用这个<code>TCP</code>连接，<code>NETCONF</code>客户端启动到<code>NETCONF</code>服务器的<code>SSH/TLS</code>会话。</li><li>使用此<code>SSH/TLS</code>会话，<code>NETCONF</code>客户端启动一个到<code>NETCONF</code>服务器的<code>NETCONF</code>会话。</li></ol><h2 id="NETCONF客户端"><a href="#NETCONF客户端" class="headerlink" title="NETCONF客户端"></a>NETCONF客户端</h2><p>术语“客户端”在<a href="https://tools.ietf.org/html/rfc6241#section-1.1" target="_blank" rel="noopener">RFC6241第1.1节</a>中定义。 在网络管理的情况下，<code>NETCONF</code>客户端可能是一个网络管理系统。</p><h3 id="客户端协议操作事项"><a href="#客户端协议操作事项" class="headerlink" title="客户端协议操作事项"></a>客户端协议操作事项</h3><ul><li>C1 <code>NETCONF</code>客户端侦听来自<code>NETCONF</code>服务器的<code>TCP</code>连接请求。 客户端必须支持在<a href="https://tools.ietf.org/html/rfc8071#section-6" target="_blank" rel="noopener">第6节</a>中定义的<code>IANA</code>分配的端口上接受<code>TCP</code>连接，但可以配置为侦听不同的端口。</li><li>C2 <code>NETCONF</code>客户端接受传入的<code>TCP</code>连接请求，并建立<code>TCP</code>连接。</li><li>C3 使用此<code>TCP</code>连接，<code>NETCONF</code>客户端启动<code>SSH</code>客户端<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253</a>或<code>TLS</code>客户端<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246</a>协议。 例如，假定使用<code>IANA分</code>配的端口，则在端口<code>4334</code>接受连接时启动<code>SSH</code>客户端协议，并且在端口<code>4335</code>或端口<code>4336</code>上接受连接时启动<code>TLS</code>客户端协议。</li><li>C4 当使用<code>TLS</code>时，<code>NETCONF</code>客户端必须告知<code>&quot;peer_allowed_to_send&quot;</code>，如<a href="https://tools.ietf.org/html/rfc6520" target="_blank" rel="noopener">RFC6520</a>所定义。 这是必需的，以便<code>NETCONF</code>服务器知道在<code>call home</code>连接时需要发送心跳包，保持长连接。</li><li>C5 作为建立<code>SSH</code>或<code>TLS</code>连接的一部分，<code>NETCONF</code>客户端必须验证服务器提供的主机密钥或证书。 该验证可以通过证书路径验证或通过将主机密钥或证书与先前信任的或“固定的”值进行比较来完成。 如果证书被提交并且包含撤销检查信息，<code>NETCONF</code>客户端应该检查证书的撤销状态。 如果确定证书已被吊销，客户端必须马上关闭连接。</li><li>C6 如果使用证书路径验证，则<code>NETCONF</code>客户端必须确保提供的证书具有对预先配置的颁发者证书的有效信任链，并且所呈现的证书对客户端之前知道的“标识符”<a href="https://tools.ietf.org/html/rfc6125" target="_blank" rel="noopener">RFC6125</a>进行编码 连接尝试。 如何在证书中编码标识符可以由与证书颁发者相关的策略来确定。 例如，可以知道给定的颁发者只在<code>X.509</code>证书的<code>“CommonName”</code>字段中签署具有唯一标识符（例如，序列号）的<code>IDevID</code>证书<a href="https://tools.ietf.org/html/rfc8071#ref-Std-802.1AR-2009" target="_blank" rel="noopener">Std-802.1AR-2009</a>。</li><li>C7 服务器的主机密钥或证书经过验证后，客户端将以<code>SSH</code>或<code>TLS</code>协议进行建立<code>SSH</code>或<code>TLS</code>连接。 在使用<code>NETCONF</code> 服务器执行客户端认证时，<code>NETCONF</code>客户端必须仅使用先前为<code>NETCONF</code>服务器提供的主机密钥或服务器证书关联的凭证。</li><li>C8 一旦<code>SSH</code>或<code>TLS</code>连接建立，<code>NETCONF</code>客户端启动<code>NETCONF</code>客户端<a href="https://tools.ietf.org/html/rfc6241" target="_blank" rel="noopener">RFC6241</a>或<code>RESTCONF</code>客户端<a href="https://tools.ietf.org/html/rfc8040" target="_blank" rel="noopener">RFC8040</a>协议。 假设使用<code>IANA</code>分配的端口，当在端口<code>4334</code>或端口<code>4335</code>上接受连接时启动<code>NETCONF</code>客户端协议，并且当在端口<code>4336</code>上接受连接时启动<code>RESTCONF</code>客户端协议。</li></ul><h3 id="客户端配置数据模型"><a href="#客户端配置数据模型" class="headerlink" title="客户端配置数据模型"></a>客户端配置数据模型</h3><p>如何配置<code>NETCONF</code>或<code>RESTCONF</code>客户端超出了本文的范围。</p><p>例如，可以使用什么样的配置来启用对<code>call home</code>的监听，配置可信证书颁发者，或者为预期的连接配置标识符。 也就是说，在<a href="https://tools.ietf.org/html/rfc8071#ref-NETCONF-MODELS" target="_blank" rel="noopener">NETCONF-MODELS</a>和<a href="https://tools.ietf.org/html/rfc8071#ref-RESTCONF-MODELS" target="_blank" rel="noopener">RESTCONF-MODELS</a>中提供了用于配置<code>NETCONF</code>和<code>RESTCONF</code>客户端的<code>YANG</code> <a href="https://tools.ietf.org/html/rfc7950" target="_blank" rel="noopener">RFC7950</a>数据模块，包括<code>call home</code>。</p><h2 id="NETCONF服务器"><a href="#NETCONF服务器" class="headerlink" title="NETCONF服务器"></a>NETCONF服务器</h2><p>术语“服务器”在<a href="https://tools.ietf.org/html/rfc6241#section-1.1" target="_blank" rel="noopener">RFC6241第1.1节</a>中定义。 在网络管理的情况下，<code>NETCONF</code>服务器可能是网络元件或设备。</p><h3 id="服务器协议操作"><a href="#服务器协议操作" class="headerlink" title="服务器协议操作"></a>服务器协议操作</h3><ul><li>S1 <code>NETCONF</code>服务器向<code>NETCONF</code>客户端发起<code>TCP</code>连接请求。 源端口可以根据本地策略或由操作系统随机分配。 服务器必须支持连接到<a href="https://tools.ietf.org/html/rfc8071#section-6" target="_blank" rel="noopener">第6节</a>中定义的一个<code>IANA</code>分配的端口，但可以配置为连接到不同的端口。 使用<code>IANA</code>分配的端口，服务器通过<code>SSH</code>连接到<code>NETCONF</code>的端口<code>4334</code>，通过<code>TLS</code>连接到<code>NETCONF</code>的端口<code>4335</code>和通过<code>TLS</code>的<code>RESTCONF</code>的端口<code>4336</code>。</li><li>S2 <code>TCP</code>连接请求被接受，<code>TCP</code>连接被建立。</li><li>S3 使用此<code>TCP</code>连接，<code>NETCONF</code>服务器将启动<code>SSH</code>服务器<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253</a>或<code>TLS</code>服务器<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246</a>协议，具体取决于它如何配置。 例如，假定使用<code>IANA</code>分配的端口，则在连接到远程端口<code>4334</code>之后使用<code>SSH</code>服务器协议，并且在连接到远程端口<code>4335</code>或远程端口<code>4336</code>之后使用<code>TLS</code>服务器协议。</li><li>S4 作为建立<code>SSH</code>或<code>TLS</code>连接的一部分，<code>NETCONF</code>服务器会将其主机密钥或证书发送给客户端。 如果发送了一个证书，服务器还必须发送所有中间证书到一个知名和可信赖的发行者。 如何发送证书列表在<a href="https://tools.ietf.org/html/rfc6187#section-2.1" target="_blank" rel="noopener">RFC6187第2.1节</a>中为<code>SSH</code>定义，在<a href="https://tools.ietf.org/html/rfc5246#section-7.4.2" target="_blank" rel="noopener">RFC5246第7.4.2节</a>中为<code>TLS</code>定义。</li><li>S5 建立<code>SSH</code>或<code>TLS</code>会话需要在所有情况下对客户端证书进行服务器身份验证，但<code>RESTCONF</code>除外，其中一些客户端身份验证方案在<code>安全传输连接（TLS）</code>建立后发生。 如果需要传输级（<code>SSH</code>或<code>TLS</code>）客户端身份验证，并且客户端无法在本地策略定义的时间内成功向服务器进行身份验证，则服务器必须关闭连接。</li><li>S6 一旦建立了<code>SSH</code>或<code>TLS</code>连接，<code>NETCONF</code>/<code>RESTCONF</code>服务器将启动<code>NETCONF</code>服务器<a href="https://tools.ietf.org/html/rfc6241" target="_blank" rel="noopener">RFC6241</a>或<code>RESTCONF</code>服务器<a href="https://tools.ietf.org/html/rfc8040" target="_blank" rel="noopener">RFC8040</a>协议，具体取决于如何配置。 假设使用<code>IANA</code>分配的端口，则在连接到远程端口<code>4334</code>或远程端口<code>4335</code>之后使用<code>NETCONF</code>服务器协议，并且在连接到远程端口<code>4336</code>之后使用<code>RESTCONF</code>服务器协议。</li><li>S7 如果需要长连接，作为连接发起者的<code>NETCONF</code>/<code>RESTCONF</code>服务器应该使用<code>keep-alive</code>机制主动测试连接的活跃性。 对于基于<code>TLS</code>的连接，<code>NETCONF</code>/<code>RESTCONF</code>服务器应该发送<a href="https://tools.ietf.org/html/rfc6520" target="_blank" rel="noopener">RFC6520</a>定义的<code>HeartbeatRequest</code>消息。 对于基于<code>SSH</code>的连接，根据<a href="https://tools.ietf.org/html/rfc4254#section-4" target="_blank" rel="noopener">RFC4254的第4节</a>，服务器应该发送一个<code>SSH_MSG_GLOBAL_REQUEST</code>消息，其中包含一个特别不存在的<code>&quot;request name&quot;</code>值（例如<a href="mailto:keepalive@ietf.org" target="_blank" rel="noopener">keepalive@ietf.org</a>）和<code>&quot;want reply&quot;</code>值设置为<code>&quot;1&quot;</code>。</li></ul><h3 id="服务器配置数据模型"><a href="#服务器配置数据模型" class="headerlink" title="服务器配置数据模型"></a>服务器配置数据模型</h3><p>如何配置<code>NETCONF</code>或<code>RESTCONF</code>服务器超出了本文的范围。</p><p>这包括可能用于指定主机名，<code>IP</code>地址，端口，算法或其他相关参数的配置。 也就是说，<a href="https://tools.ietf.org/html/rfc8071#ref-NETCONF-MODELS" target="_blank" rel="noopener">NETCONF-MODELS</a>和<a href="https://tools.ietf.org/html/rfc8071#ref-RESTCONF-MODELS" target="_blank" rel="noopener">RESTCONF-MODELS</a>中提供了用于配置NETCONF和RESTCONF服务器的YANG <a href="https://tools.ietf.org/html/rfc7950" target="_blank" rel="noopener">RFC7950</a>数据模块，包括<code>call home</code>。</p><h2 id="安全考虑"><a href="#安全考虑" class="headerlink" title="安全考虑"></a>安全考虑</h2><p><a href="https://tools.ietf.org/html/rfc6242" target="_blank" rel="noopener">RFC6242</a>和<a href="https://tools.ietf.org/html/rfc7589" target="_blank" rel="noopener">RFC7589</a>以及扩展<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253</a>，<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246 </a>和<a href="https://tools.ietf.org/html/rfc8040" target="_blank" rel="noopener">RFC8040</a>中描述的安全考虑也适用于此处。</p><p>这个<code>RFC</code>与<code>SSH</code>/<code>TLS</code>服务器启动底层TCP连接的方式背离了标准的<code>SSH</code>和<code>TLS</code>的使用。 这种逆转与<a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253</a>中的“客户端启动连接”和<a href="https://tools.ietf.org/html/rfc6125" target="_blank" rel="noopener">RFC6125</a>不一致，它们表示<strong>“客户端必须构建可接受的引用标识符列表，并且必须独立于服务提供的标识符“</strong> 。</p><p>与这些差异有关的风险主要集中在服务器认证上，客户无法将独立构建的引用标识符与服务器提供的引用标识符进行比较。为了减轻这些风险，要求<code>NETCONF</code>/<code>RESTCONF</code>客户端验证服务器的<code>SSH</code>主机密钥或证书，通过对预先配置的发行者证书进行证书路径验证，或者通过将主机密钥或证书与先前信任或“固定”值。此外，当使用证书时，要求客户端能够将在提供的证书中编码的标识符与客户端预先配置的标识符（例如，序列号）相匹配。</p><p>对于<code>NETCONF</code>/<code>RESTCONF</code>服务器提供<code>X.509</code>证书的情况，<code>NETCONF</code>/<code>RESTCONF</code>客户端应确保用于证书路径验证的<code>&quot;\&quot;</code>预配置颁发者证书对于服务器的制造商是唯一的。也就是说，证书不应该属于可能为多个制造商颁发证书的第三方认证机构。当使用将共享秘密（例如，密码）传递给服务器的客户机认证机制时，这是特别重要的。否则可能会导致客户端将共享密钥发送到恰好与客户端配置期望的服务器具有相同身份（例如，序列号）的另一个服务器的情况。</p><p>接下来会考虑与服务器身份验证无关的问题。</p><p>运行<code>NETCONF Call Home</code>或<code>RESTCONF Call Home</code>的面向<code>Internet</code>的主机将通过诸如”<a href="https://tools.ietf.org/html/rfc8071#ref-zmap" target="_blank" rel="noopener">zmap</a>“之类的扫描工具进行指纹识别。 <code>SSH</code>和<code>TLS</code>都提供了许多方法可以在主机上进行指纹识别。 <code>SSH</code>和<code>TLS</code>服务器相当成熟，能够抵御攻击，但是<code>SSH</code>和<code>TLS</code>客户端可能不够强大。实施者和部署需要确保提供软件更新机制，以便及时修复漏洞。</p><p>攻击者可以在推断出攻击者没有拥有有效密钥之前，对<code>NETCONF</code>/<code>RESTCONF</code>客户端进行拒绝服务（<code>DoS</code>）攻击，执行计算量大的操作。 例如，在<a href>TLS1.3</a>中，<code>ClientHello</code>消息包含成本很高的非对称密钥操作的密钥共享值。 推荐使用常见的减轻<code>DoS</code>攻击的预防措施，例如在一系列不成功的登录尝试后暂时将源地址列入黑名单。</p><p>当使用带有<code>RESTCONF</code>协议的<code>call home</code>时，在使用一些<code>HTTP</code>认证方案时，特别要注意传送共享密钥（例如密码）的<code>Basic</code> <a href="https://tools.ietf.org/html/rfc7617" target="_blank" rel="noopener">RFC7617</a>和<code>Digest</code> <a href="https://tools.ietf.org/html/rfc7616" target="_blank" rel="noopener">RFC7616</a>方案。 对于使用的任何<code>HTTP</code>客户机认证方案，实施者和部署都应确保查看<code>RFC</code>中的“安全注意事项”部分。</p><h2 id="IANA考虑事项"><a href="#IANA考虑事项" class="headerlink" title="IANA考虑事项"></a>IANA考虑事项</h2><p>IANA已经在“用户端口”范围内为服务名称“<code>netconf-ch-ssh</code>”，“<code>netconf-ch-tls</code>”和“<code>restconf-ch-tls</code>”分配了三个<code>TCP</code>端口号。 这些端口将是<code>NETCONF Call Home</code>和<code>RESTCONF Call Home</code>协议的默认端口。 以下是遵循<a href="https://tools.ietf.org/html/rfc6335" target="_blank" rel="noopener">RFC6335</a>中的规则的注册模板。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Service Name:           netconf-ch-ssh</span><br><span class="line">Port Number:            4334</span><br><span class="line">Transport Protocol(s):  TCP</span><br><span class="line">Description:            NETCONF Call Home (SSH)</span><br><span class="line">Assignee:               IESG &lt;iesg@ietf.org&gt;</span><br><span class="line">Contact:                IETF Chair &lt;chair@ietf.org&gt;</span><br><span class="line">Reference:              RFC 8071</span><br><span class="line"></span><br><span class="line">Service Name:           netconf-ch-tls</span><br><span class="line">Port Number:            4335</span><br><span class="line">Transport Protocol(s):  TCP</span><br><span class="line">Description:            NETCONF Call Home (TLS)</span><br><span class="line">Assignee:               IESG &lt;iesg@ietf.org&gt;</span><br><span class="line">Contact:                IETF Chair &lt;chair@ietf.org&gt;</span><br><span class="line">Reference:              RFC 8071</span><br><span class="line"></span><br><span class="line">Service Name:           restconf-ch-tls</span><br><span class="line">Port Number:            4336</span><br><span class="line">Transport Protocol(s):  TCP</span><br><span class="line">Description:            RESTCONF Call Home (TLS)</span><br><span class="line">Assignee:               IESG &lt;iesg@ietf.org&gt;</span><br><span class="line">Contact:                IETF Chair &lt;chair@ietf.org&gt;</span><br><span class="line">Reference:              RFC 8071</span><br></pre></td></tr></table></figure><h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><p>关于<code>NETCONF Call Home</code>的实现，可以参考<code>Juniper</code>在<a href="https://github.com/Juniper" target="_blank" rel="noopener">github</a>上开源的<a href="https://github.com/Juniper/netconf-call-home" target="_blank" rel="noopener">netconf-call-home</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tools.ietf.org/html/rfc8071" target="_blank" rel="noopener">RFC 8071 - NETCONF Call Home and RESTCONF Call Home</a></li><li><a href="https://tools.ietf.org/html/rfc6242" target="_blank" rel="noopener">RFC6242 - Using the NETCONF Protocol over Secure Shell (SSH)</a></li><li><a href="https://tools.ietf.org/html/rfc7589" target="_blank" rel="noopener">RFC7589 - Using the NETCONF Protocol over Transport Layer Security (TLS) with Mutual X.509 Authentication</a></li><li><a href="https://tools.ietf.org/html/rfc4253" target="_blank" rel="noopener">RFC4253 -  The Secure Shell (SSH) Transport Layer Protocol</a></li><li><a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC5246 -  The Transport Layer Security (TLS) Protocol Version 1.2</a></li><li><a href="https://tools.ietf.org/html/rfc8040" target="_blank" rel="noopener">RFC8040 - RESTCONF Protocol</a></li><li><a href="https://github.com/Juniper/netconf-call-home" target="_blank" rel="noopener">Juniper netconf-call-home</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog/netconf-callhome/rfc8071-datatracker-status.jpg&quot; alt=&quot;rfc8071 datatracker status&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文主要内容都来自于今年二月发布的&lt;a href=&quot;https://tools.ietf.org/html/rfc8071&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC8071 - NETCONF Call Home and RESTCONF Call Home&lt;/a&gt;，该RFC从2015年4月提出到最终发布一共修改了17个版本，其间修改内容可以&lt;a href=&quot;https://datatracker.ietf.org/doc/rfc8071/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看详细内容&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;NETCONF Call Home&lt;/code&gt;支持两种安全传输网络配置协议分别是&lt;code&gt;Secure Shell(SSH)&lt;/code&gt;和传输层安全&lt;code&gt;(TLS)&lt;/code&gt;。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;NETCONF&lt;/code&gt;协议​​的绑定到&lt;code&gt;SSH&lt;/code&gt;在&lt;a href=&quot;https://tools.ietf.org/html/rfc6242&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC6242&lt;/a&gt;中定义。&lt;br&gt;&lt;code&gt;NETCONF&lt;/code&gt;协议​​的绑定到&lt;code&gt;TLS&lt;/code&gt;在&lt;a href=&quot;https://tools.ietf.org/html/rfc7589&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC7589&lt;/a&gt;中定义。&lt;br&gt;&lt;code&gt;SSH&lt;/code&gt;协议在&lt;a href=&quot;https://tools.ietf.org/html/rfc4253&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC4253&lt;/a&gt;中定义，&lt;code&gt;TLS&lt;/code&gt;协议是在&lt;a href=&quot;https://tools.ietf.org/html/rfc4253&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC5246&lt;/a&gt;中定义。&lt;code&gt;SSH&lt;/code&gt;和&lt;code&gt;TLS&lt;/code&gt;协议都是&lt;code&gt;TCP&lt;/code&gt;协议之上的协议。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="SDN" scheme="http://tonydeng.github.io/categories/SDN/"/>
    
    
      <category term="NETCONF" scheme="http://tonydeng.github.io/tags/NETCONF/"/>
    
      <category term="RFC" scheme="http://tonydeng.github.io/tags/RFC/"/>
    
      <category term="RFC8071" scheme="http://tonydeng.github.io/tags/RFC8071/"/>
    
  </entry>
  
  <entry>
    <title>JUnit5教程-注解</title>
    <link href="http://tonydeng.github.io/2017/10/10/junit-5-annotations/"/>
    <id>http://tonydeng.github.io/2017/10/10/junit-5-annotations/</id>
    <published>2017-10-10T02:33:44.000Z</published>
    <updated>2019-06-20T12:10:27.480Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://junit.org/junit4/images/junit5-banner.png" alt="junit5 logo"></p><h2 id="JUnit5提供的注解"><a href="#JUnit5提供的注解" class="headerlink" title="JUnit5提供的注解"></a>JUnit5提供的注解</h2><table><thead><tr><th>Annotations</th><th>描述</th></tr></thead><tbody><tr><td><code>@BeforeEach</code></td><td>在方法上注解，在每个测试方法运行之前执行。</td></tr><tr><td><code>@AfterEach</code></td><td>在方法上注解，在每个测试方法运行之后执行</td></tr><tr><td><code>@BeforeAll</code></td><td>该注解方法会在所有测试方法之前运行，该方法必须是静态的。</td></tr><tr><td><code>@AfterAll</code></td><td>该注解方法会在所有测试方法之后运行，该方法必须是静态的。</td></tr><tr><td><code>@Test</code></td><td>用于将方法标记为测试方法</td></tr><tr><td><code>@DisplayName</code></td><td>用于为测试类或测试方法提供任何自定义显示名称</td></tr><tr><td><code>@Disable</code></td><td>用于禁用或忽略测试类或方法</td></tr><tr><td><code>@Nested</code></td><td>用于创建嵌套测试类</td></tr><tr><td><code>@Tag</code></td><td>用于测试发现或过滤的标签来标记测试方法或类</td></tr><tr><td><code>@TestFactory</code></td><td>标记一种方法是动态测试的测试工场</td></tr></tbody></table><a id="more"></a><h2 id="JUnit5-VS-JUnit4"><a href="#JUnit5-VS-JUnit4" class="headerlink" title="JUnit5 VS JUnit4"></a>JUnit5 VS JUnit4</h2><p><img src="https://image.slidesharecdn.com/junit5vsjunit4-170324194457/95/junit-5-vs-junit-4-9-638.jpg" alt="junit5 vs junit4"></p><blockquote><p>本图来自<a href="https://www.slideshare.net/rkmael" target="_blank" rel="noopener">Ismael</a>在Slideshare分享的<a href="https://www.slideshare.net/rkmael/junit-5-vs-junit-4" target="_blank" rel="noopener">JUnit 5 vs JUnit 4</a></p></blockquote><p>接下来来我们来一个个注解详细介绍。</p><h2 id="BeforeAll"><a href="#BeforeAll" class="headerlink" title="@BeforeAll"></a>@BeforeAll</h2><p>如[JUnit5 VS JUnit4](#JUnit5 VS JUnit4)图中所示，<code>@BeforeAll</code>是替换JUnit4的<code>@BeforeClass</code>。它用于表示在当前测试类中的所有测试之前应该执行注解的方法。</p><h3 id="BeforeAll使用"><a href="#BeforeAll使用" class="headerlink" title="@BeforeAll使用"></a>@BeforeAll使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BeforeAll</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Before All init() method called"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@BeforeAll</code>注解方法必须是静态方法，否则会抛出运行时错误。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.junit.platform.commons.JUnitException: <span class="meta">@BeforeAll</span> method <span class="string">'public void com.github.tonydeng.junit5.examples.JUnit5AnnotationsExample.init()'</span> must be <span class="keyword">static</span>.</span><br><span class="line">at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.assertStatic(LifecycleMethodUtils.java:<span class="number">66</span>)</span><br><span class="line">at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.lambda$findBeforeAllMethods$<span class="number">0</span>(LifecycleMethodUtils.java:<span class="number">42</span>)</span><br><span class="line">at java.util.ArrayList.forEach(ArrayList.java:<span class="number">1249</span>)</span><br><span class="line">at java.util.Collections$UnmodifiableCollection.forEach(Collections.java:<span class="number">1080</span>)</span><br><span class="line">at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findBeforeAllMethods(LifecycleMethodUtils.java:<span class="number">42</span>)</span><br></pre></td></tr></table></figure><h3 id="BeforeAll示例"><a href="#BeforeAll示例" class="headerlink" title="@BeforeAll示例"></a>@BeforeAll示例</h3><p>我们来举个例子。我使用了一个<code>Calculator</code>类并添加了一个<code>add</code>方法。我将使用<code>@RepeatedTest</code>注解测试它5次。此注解将导致<code>add</code>测试运行5次。但<code>@BeforeAll</code>注解方法只能调用一次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.RepeatedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.TestInfo;</span><br><span class="line"><span class="keyword">import</span> org.junit.platform.runner.JUnitPlatform;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before All init() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算器类是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在执行测试，您将在控制台输出下方看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Before All init() method called</span><br></pre></td></tr></table></figure><p>显然，@BeforeAll注解init()方法只调用一次。</p><h2 id="BeforeEach"><a href="#BeforeEach" class="headerlink" title="@BeforeEach"></a>@BeforeEach</h2><p>如[JUnit5 VS JUnit4](#JUnit5 VS JUnit4)图中所示，<code>@BeforeEach</code>注解是替换JUnit4中的<code>@Before</code>注解。它用于表示<code>@Test</code>在当前类中的每个方法之前应该执行注解方法。</p><h3 id="BeforeEach用法"><a href="#BeforeEach用法" class="headerlink" title="@BeforeEach用法"></a>@BeforeEach用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Before Each initEach() method called"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@BeforeEach 注解方法不能是静态方法，否则会抛出运行时错误。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.junit.platform.commons.JUnitException: <span class="meta">@BeforeEach</span> method <span class="string">'public static void com.github.tonydeng.junit5.examples.JUnit5AnnotationsExample.initEach()'</span> must not be <span class="keyword">static</span>.</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.assertNonStatic(LifecycleMethodUtils.java:<span class="number">73</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.lambda$findBeforeEachMethods$<span class="number">2</span>(LifecycleMethodUtils.java:<span class="number">54</span>)</span><br><span class="line">    at java.util.ArrayList.forEach(ArrayList.java:<span class="number">1249</span>)</span><br><span class="line">    at java.util.Collections$UnmodifiableCollection.forEach(Collections.java:<span class="number">1080</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findBeforeEachMethods(LifecycleMethodUtils.java:<span class="number">54</span>)</span><br></pre></td></tr></table></figure><h3 id="BeforeEach示例"><a href="#BeforeEach示例" class="headerlink" title="@BeforeEach示例"></a>@BeforeEach示例</h3><p>我还是使用之前<code>Calculator</code>类的add方法。我将使用<code>@RepeatedTest</code>注解测试它5次。此注解将导致<code>add</code>测试运行5次。对于每次运行的测试方法，<code>@BeforeEach</code>注解方法也应该每次运行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.RepeatedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.TestInfo;</span><br><span class="line"><span class="keyword">import</span> org.junit.platform.runner.JUnitPlatform;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before All init() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before Each initEach() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在执行测试，您将在控制台输出下方看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Before All init() method called</span><br><span class="line">Before Each initEach() method called</span><br><span class="line">Before Each initEach() method called</span><br><span class="line">Before Each initEach() method called</span><br><span class="line">Before Each initEach() method called</span><br><span class="line">Before Each initEach() method called</span><br><span class="line">Before Each initEach() method called</span><br></pre></td></tr></table></figure><p>显然，每个测试方法调用调用一次<code>@BeforeEach</code>注解<code>initEach()</code>方法。</p><h2 id="AfterEach"><a href="#AfterEach" class="headerlink" title="@AfterEach"></a>@AfterEach</h2><p>如[JUnit5 VS JUnit4](#JUnit5 VS JUnit4)图中所示，<code>@AfterJUnit</code>注解是替换JUnit4中的<code>@Before</code>注解。它用于表示<code>@Test</code>在当前类中的每个方法之前应该执行注解方法。</p><h3 id="AfterEach注解用法"><a href="#AfterEach注解用法" class="headerlink" title="@AfterEach注解用法"></a>@AfterEach注解用法</h3><p>注解方法@AfterEach如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"After Each cleanUpEach() method called"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@AfterEach 注解方法不能是静态方法，否则会抛出运行时错误。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.junit.platform.commons.JUnitException: <span class="meta">@AfterEach</span> method <span class="string">'public static void com.github.tonydeng.junit5.examples.JUnit5AnnotationsExample.cleanUpEach()'</span> must not be <span class="keyword">static</span>.</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.assertNonStatic(LifecycleMethodUtils.java:<span class="number">73</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.lambda$findAfterEachMethods$<span class="number">3</span>(LifecycleMethodUtils.java:<span class="number">60</span>)</span><br><span class="line">    at java.util.ArrayList.forEach(ArrayList.java:<span class="number">1249</span>)</span><br><span class="line">    at java.util.Collections$UnmodifiableCollection.forEach(Collections.java:<span class="number">1080</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findAfterEachMethods(LifecycleMethodUtils.java:<span class="number">60</span>)</span><br></pre></td></tr></table></figure><h3 id="AfterEach注解示例"><a href="#AfterEach注解示例" class="headerlink" title="@AfterEach注解示例"></a>@AfterEach注解示例</h3><p>我还是使用之前<code>Calculator</code>类的add方法。我将使用<code>@RepeatedTest</code>注解测试它5次。此注解将导致<code>add</code>测试运行5次。对于每次运行的测试方法，<code>@AfterEach</code>注解方法也应该每次运行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.RepeatedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.TestInfo;</span><br><span class="line"><span class="keyword">import</span> org.junit.platform.runner.JUnitPlatform;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After All cleanUp() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After Each cleanUpEach() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在执行测试，您将在控制台输出下方看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After All cleanUp() method called</span><br></pre></td></tr></table></figure><p>显然，每个测试方法调用调用一次<code>@AfterEach</code>注解<code>cleanUpEach()</code>方法。</p><h2 id="AfterAll"><a href="#AfterAll" class="headerlink" title="@AfterAll"></a>@AfterAll</h2><p>如[JUnit5 VS JUnit4](#JUnit5 VS JUnit4)图中所示，<code>@AfterAll</code>注解是替换JUnit4中的<code>@AfterClass</code>注解。它用于表示在当前测试类中的所有测试后应执行注解方法。</p><h3 id="AfterAll注解使用"><a href="#AfterAll注解使用" class="headerlink" title="@AfterAll注解使用"></a>@AfterAll注解使用</h3><p>注解方法@AfterAll如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterAll</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"After All cleanUp() method called"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@AfterAll 注解方法必须是静态方法，否则会抛出运行时错误。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.junit.platform.commons.JUnitException: <span class="meta">@AfterAll</span> method <span class="string">'public void com.github.tonydeng.junit5.examples.JUnit5AnnotationsExample.cleanUp()'</span> must be <span class="keyword">static</span>.</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.assertStatic(LifecycleMethodUtils.java:<span class="number">66</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.lambda$findAfterAllMethods$<span class="number">1</span>(LifecycleMethodUtils.java:<span class="number">48</span>)</span><br><span class="line">    at java.util.ArrayList.forEach(ArrayList.java:<span class="number">1249</span>)</span><br><span class="line">    at java.util.Collections$UnmodifiableCollection.forEach(Collections.java:<span class="number">1080</span>)</span><br><span class="line">    at org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findAfterAllMethods(LifecycleMethodUtils.java:<span class="number">48</span>)</span><br></pre></td></tr></table></figure><h3 id="AfterAll注解示例"><a href="#AfterAll注解示例" class="headerlink" title="@AfterAll注解示例"></a>@AfterAll注解示例</h3><p>我还是使用之前<code>Calculator</code>类的add方法。我将使用<code>@RepeatedTest</code>注解测试它5次。此注解将导致<code>add</code>测试运行5次。但<code>@AfterAll</code>注解方法只能调用一次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.RepeatedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.TestInfo;</span><br><span class="line"><span class="keyword">import</span> org.junit.platform.runner.JUnitPlatform;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After All cleanUp() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After Each cleanUpEach() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在执行测试，您将在控制台输出下方看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line">After All cleanUp() method called</span><br></pre></td></tr></table></figure><p>显然，<code>@AfterAll</code>注解<code>cleanUp()</code>方法只调用一次。</p><h2 id="RepeatedTest"><a href="#RepeatedTest" class="headerlink" title="@RepeatedTest"></a>@RepeatedTest</h2><p>JUnit5 <code>@RepeatedTest</code>注解能够编写可重复的测试模板，可以多次运行。频率可以配置为<code>@RepeatedTest</code>注解的参数。</p><h3 id="RepeatedTest注解用法"><a href="#RepeatedTest注解用法" class="headerlink" title="@RepeatedTest注解用法"></a>@RepeatedTest注解用法</h3><p>要创建可重复的测试模板方法，请使用注解方法@RepeatedTest。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line"><span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>addNumber()</code>测试将重复5次。请注意，重复测试的每次调用的行为就像一个常规<code>@Test</code>方法的执行，并且完全支持相同的生命周期回调和扩展。这意味着，<code>@BeforeEach</code>和<code>@AfterEach</code>注解的方法将被调用，他们适合在测试生命周期，为每个单独的调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.tonydeng.junit5.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.RepeatedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.TestInfo;</span><br><span class="line"><span class="keyword">import</span> org.junit.platform.runner.JUnitPlatform;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before All init() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before Each initEach() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"===addNumber testcase executed==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After Each cleanUpEach() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"After All cleanUp() method called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Before All init() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">Before Each initEach() method called</span><br><span class="line">===addNumber testcase executed===</span><br><span class="line">After Each cleanUpEach() method called</span><br><span class="line"></span><br><span class="line">After All cleanUp() method called</span><br></pre></td></tr></table></figure><h3 id="使用-RepeatedTest注解定制显示名称"><a href="#使用-RepeatedTest注解定制显示名称" class="headerlink" title="使用@RepeatedTest注解定制显示名称"></a>使用@RepeatedTest注解定制显示名称</h3><p>除了指定重复次数之外，您还可以为每次重复提供自定义显示名称。此自定义显示名称可以是静态文本+动态占位符的组合。目前支持3名占有者：</p><ul><li><code>{displayName}</code>：显示<code>@RepeatedTest</code>方法名称。</li><li><code>{currentRepetition}</code>：当前重复计数。</li><li><code>{totalRepetitions}</code>：重复的总数。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5AnnotationsExample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(value = <span class="number">5</span>, name = <span class="string">"&#123;displayName&#125; - repetition &#123;currentRepetition&#125; of &#123;totalRepetitions&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDE中运行该测试，将会产生类似下图的运行记录：</p><p><img src="https://s1.ax1x.com/2017/10/10/8iA7q.png" alt="RepeatedTest Run results"></p><p>您可以使用两个预定义的格式之一，即<code>RepeatedTest.LONG_DISPLAY_NAME</code>和<code>RepeatedTest.SHORT_DISPLAY_NAME</code>。<code>SHORT_DISPLAY_NAME</code>是未指定的默认格式。</p><ul><li><code>RepeatedTest.LONG_DISPLAY_NAME</code> - {displayName} :: repet {currentRepetition} {totalRepetitions}</li><li><code>RepeatedTest.SHORT_DISPLAY_NAME</code> - repetition {currentRepetition} {totalRepetitions}</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line"><span class="meta">@RepeatedTest</span>(value = <span class="number">5</span>, name = RepeatedTest.LONG_DISPLAY_NAME)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用RepetitionInfo接口"><a href="#使用RepetitionInfo接口" class="headerlink" title="使用RepetitionInfo接口"></a>使用RepetitionInfo接口</h3><p><a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/RepetitionInfo.html" target="_blank" rel="noopener">RepetitionInfo</a>用于将关于当前重复的重复测试的信息注入到<code>@RepeatedTest</code>和<code>@BeforeEach</code>，和<code>@AfterEach</code>方法中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5AnnotationsExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initEach</span><span class="params">(RepetitionInfo info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentRepetition = info.getCurrentRepetition();</span><br><span class="line">        <span class="keyword">int</span> totalRepetitions = info.getTotalRepetitions();</span><br><span class="line">        <span class="comment">//Use information as needed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"Add operation test"</span>)</span><br><span class="line">    <span class="meta">@RepeatedTest</span>(value = <span class="number">5</span>, name=<span class="string">"&#123;displayName&#125; :: repetition &#123;currentRepetition&#125; of &#123;totalRepetitions&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNumber</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, calculator.add(<span class="number">1</span>, <span class="number">1</span>), <span class="string">"1 + 1 should equal 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpEach</span><span class="params">(RepetitionInfo info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentRepetition = info.getCurrentRepetition();</span><br><span class="line">        <span class="keyword">int</span> totalRepetitions = info.getTotalRepetitions();</span><br><span class="line">        <span class="comment">//Use information as needed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到目前为止，整个<code>@RepeatedTest</code>功能处于<code>Experimental</code>状态。将来可以更新甚至删除。</p></blockquote><h2 id="Disabled"><a href="#Disabled" class="headerlink" title="@Disabled"></a>@Disabled</h2><p><a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Disabled.html" target="_blank" rel="noopener">@Disabled</a>注解可用于禁用测试套件的测试方法。此注解可以应用于测试类以及单独的测试方法。</p><p>它只接受一个可选参数，指示该测试被禁用的原因。</p><h3 id="Disabled测试类"><a href="#Disabled测试类" class="headerlink" title="@Disabled测试类"></a>@Disabled测试类</h3><p>当@Disabled通过测试类应用时，该类中的所有测试方法也将自动禁用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assumptions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Disabled;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnDev</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"DEV"</span>);</span><br><span class="line">        Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnProd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"PROD"</span>);</span><br><span class="line">        Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意运行次数：2/2（2跳过）。</p></blockquote><h3 id="Disabled测试方法"><a href="#Disabled测试方法" class="headerlink" title="@Disabled测试方法"></a>@Disabled测试方法</h3><p>@Disabled用于表示注解的测试方法当前已禁用，不应执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assumptions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Disabled;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Disabled</span>(<span class="string">"Do not run in lower environment"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnDev</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"DEV"</span>);</span><br><span class="line">        Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnProd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"PROD"</span>);</span><br><span class="line">        Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意运行次数：2/2（1跳过）。</p></blockquote><h2 id="Tag"><a href="#Tag" class="headerlink" title="@Tag"></a>@Tag</h2><p> <a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Tag.html" target="_blank" rel="noopener">@Tag</a>可用于从测试计划中过滤测试用例。它可以帮助为不同环境，不同用例或任何特定要求创建多个不同的测试计划。您可以通过在测试计划OR中仅包括那些标记的测试来排除测试计划中的其他测试来执行一组测试。</p><h3 id="Tag注解用法"><a href="#Tag注解用法" class="headerlink" title="@Tag注解用法"></a>@Tag注解用法</h3><p>您可以<code>@Tag</code>在测试类或测试方法或两者上应用注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Tag</span>(<span class="string">"development"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassATest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"userManagement"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCaseA</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">您也可以在单个测试用例上应用多个标签，以便将其包含在多个测试计划中。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassATest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"production"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCaseA</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-IncludeTags和-ExcludeTags创建测试计划"><a href="#使用-IncludeTags和-ExcludeTags创建测试计划" class="headerlink" title="使用@IncludeTags和@ExcludeTags创建测试计划"></a>使用@IncludeTags和@ExcludeTags创建测试计划</h3><p>可以在测试计划中使用<code>@IncludeTags</code>或<code>@ExcludeTags</code>注解来过滤测试或包含测试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@IncludeTags example</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="meta">@SelectPackages</span>(<span class="string">"com.github.tonydeng.junit5.examples"</span>)</span><br><span class="line"><span class="meta">@IncludeTags</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@ExcludeTags example</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="meta">@SelectPackages</span>(<span class="string">"com.github.tonydeng.junit5.examples"</span>)</span><br><span class="line"><span class="meta">@ExcludeTags</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要添加多个标签，请将所需标注的字符串数组传递给所需的注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="meta">@SelectPackages</span>(<span class="string">"com.github.tonydeng.junit5.examples"</span>)</span><br><span class="line"><span class="meta">@IncludeTags</span>(&#123;<span class="string">"production"</span>,<span class="string">"development"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不能在单个测试计划中同时包含<code>@IncludeTags</code>和<code>@ExcludeTags</code>注解。</p></blockquote><h3 id="Tag示例"><a href="#Tag示例" class="headerlink" title="@Tag示例"></a>@Tag示例</h3><p>假设我们有3个测试，我们想在开发环境中运行所有3个测试; 但是想在生产中只运行一个。所以我们将标记测试如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassATest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"production"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCaseA</span><span class="params">(TestInfo testInfo)</span> </span>&#123; <span class="comment">//run in all environments</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassBTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCaseB</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"development"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCaseC</span><span class="params">(TestInfo testInfo)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们为这两种环境创建测试计划。</p><h4 id="测试在生产环境中运行"><a href="#测试在生产环境中运行" class="headerlink" title="测试在生产环境中运行"></a>测试在生产环境中运行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="meta">@SelectPackages</span>(<span class="string">"com.github.tonydeng.junit5.examples"</span>)</span><br><span class="line"><span class="meta">@IncludeTags</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionTests</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试在开发环境中运行"><a href="#测试在开发环境中运行" class="headerlink" title="测试在开发环境中运行"></a>测试在开发环境中运行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="meta">@SelectPackages</span>(<span class="string">"com.github.tonydeng.junit5.examples"</span>)</span><br><span class="line"><span class="meta">@IncludeTags</span>(<span class="string">"development"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevelopmentTests</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://junit.org/junit4/images/junit5-banner.png&quot; alt=&quot;junit5 logo&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;JUnit5提供的注解&quot;&gt;&lt;a href=&quot;#JUnit5提供的注解&quot; class=&quot;headerlink&quot; title=&quot;JUnit5提供的注解&quot;&gt;&lt;/a&gt;JUnit5提供的注解&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Annotations&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@BeforeEach&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在方法上注解，在每个测试方法运行之前执行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@AfterEach&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在方法上注解，在每个测试方法运行之后执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@BeforeAll&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该注解方法会在所有测试方法之前运行，该方法必须是静态的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@AfterAll&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;该注解方法会在所有测试方法之后运行，该方法必须是静态的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Test&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于将方法标记为测试方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@DisplayName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于为测试类或测试方法提供任何自定义显示名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Disable&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于禁用或忽略测试类或方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Nested&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于创建嵌套测试类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@Tag&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于测试发现或过滤的标签来标记测试方法或类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@TestFactory&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标记一种方法是动态测试的测试工场&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="JUnit5 Tutorial" scheme="http://tonydeng.github.io/categories/JUnit5-Tutorial/"/>
    
    
      <category term="junit5" scheme="http://tonydeng.github.io/tags/junit5/"/>
    
      <category term="junit" scheme="http://tonydeng.github.io/tags/junit/"/>
    
      <category term="tutorial" scheme="http://tonydeng.github.io/tags/tutorial/"/>
    
      <category term="unit testing" scheme="http://tonydeng.github.io/tags/unit-testing/"/>
    
      <category term="annotations" scheme="http://tonydeng.github.io/tags/annotations/"/>
    
  </entry>
  
  <entry>
    <title>JUnit5教程-测试生命周期</title>
    <link href="http://tonydeng.github.io/2017/10/09/junit-5-test-lifecycle/"/>
    <id>http://tonydeng.github.io/2017/10/09/junit-5-test-lifecycle/</id>
    <published>2017-10-09T08:57:29.000Z</published>
    <updated>2019-06-20T12:10:27.480Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://junit.org/junit4/images/junit5-banner.png" alt="junit5 logo"></p><p>在JUnit5中，测试生命周期由4个主要注解驱动，即<code>@BeforeAll</code>、<code>@BeforeEach</code>、<code>@AfterEach</code>和<code>@AfterAll</code>。与此同时，每个测试方法都必须标注<code>@Test</code>注解。</p><a id="more"></a><h2 id="生命周期结构"><a href="#生命周期结构" class="headerlink" title="生命周期结构"></a>生命周期结构</h2><p><img src="http://junit.org/junit5/docs/current/user-guide/images/extensions_lifecycle.png" alt="junit 5 test lifecycle"></p><h2 id="Before-amp-After"><a href="#Before-amp-After" class="headerlink" title="Before &amp; After"></a>Before &amp; After</h2><p>在junit测试生命周期中，我们需要一些方法来设置和清除测试运行的环境或测试数据。</p><p>在JUnit中，对于每个测试 - 创建了一个新的测试实例。<code>@BeforeAll</code>和@<code>AfterAll</code>注释 - 以其名称清除 - 在整个测试执行周期中只应调用一次。所以他们必须被宣布</p><p>在JUnit中，对于每个测试 ，都会创建了一个新的测试实例。<code>@BeforeAll</code>和<code>@AfterAll</code>注解，在整个测试执行周期中只应调用一次。所以他们必须被声明为<code>static</code>。</p><p>如果他们是用相同注释注释的多个方法（例如两个方法<code>@BeforeAll</code>），那么它们的执行顺序是不确定的。</p><p><code>@BeforeEach</code>和<code>@AfterEach</code>为每个测试实例调用，所以他们不需要<code>static</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@BeforeAll executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setupThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@BeforeEach executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCalcOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======TEST ONE EXECUTED======="</span>);</span><br><span class="line">        Assertions.assertEquals( <span class="number">4</span> , Calculator.add(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCalcTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======TEST TWO EXECUTED======="</span>);</span><br><span class="line">        Assertions.assertEquals( <span class="number">6</span> , Calculator.add(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@AfterEach executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@AfterAll executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@BeforeAll executed</span><br><span class="line"></span><br><span class="line">@BeforeEach executed</span><br><span class="line">======TEST ONE EXECUTED=======</span><br><span class="line">@AfterEach executed</span><br><span class="line"></span><br><span class="line">@BeforeEach executed</span><br><span class="line">======TEST TWO EXECUTED=======</span><br><span class="line">@AfterEach executed</span><br><span class="line"></span><br><span class="line">@AfterAll executed</span><br></pre></td></tr></table></figure><h2 id="禁用测试"><a href="#禁用测试" class="headerlink" title="禁用测试"></a>禁用测试</h2><p>要在JUnit 5中禁用测试，您将需要使用<code>@Disabled</code>注释。它相当于JUnit 4的<code>@Ignored</code>注释。</p><p><code>@Disabled</code> 注释可以应用于测试类（禁用该类中的所有测试方法）或单独的测试方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCalcTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"======TEST TWO EXECUTED======="</span>);</span><br><span class="line">    Assertions.assertEquals( <span class="number">6</span> , Calculator.add(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在任何测试方法中，ou将需要确定它是否通过失败。你可以使用断言来做。资产有助于通过测试用例的实际输出验证预期输出。为了保持简单，所有JUnit Jupiter断言是<a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assertions.html" target="_blank" rel="noopener">org.junit.jupiter.Assertions</a>类中的静态方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Test will pass</span></span><br><span class="line">    Assertions.assertEquals(<span class="number">4</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test will fail</span></span><br><span class="line">    Assertions.assertEquals(<span class="number">3</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>), <span class="string">"Calculator.add(2, 2) test failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test will fail</span></span><br><span class="line">    Supplier&lt;String&gt; messageSupplier  = ()-&gt; <span class="string">"Calculator.add(2, 2) test failed"</span>;</span><br><span class="line">    Assertions.assertEquals(<span class="number">3</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>), messageSupplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要测试失败，只需使用<code>Assertions.fail()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assertions.fail(<span class="string">"not found good reason to pass"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p><a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assumptions.html" target="_blank" rel="noopener">Assumptions</a>提供了基于假设支持条件测试执行的静态方法。失败的假设导致测试被中止。无论何时继续执行给定的测试方法没有意义，通常使用假设。在测试报告中，这些测试将被标记为已通过。</p><p>假设类有两个方法：<code>assumeFalse()</code>，<code>assumeTrue()</code>。第三种方法<code>assumeThat()</code>处于实验状态，可能会在将来的版本中得到证实。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnDev</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.setProperty(<span class="string">"ENV"</span>, <span class="string">"DEV"</span>);</span><br><span class="line">    Assumptions.assumeTrue(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    <span class="comment">//remainder of test will proceed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnProd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.setProperty(<span class="string">"ENV"</span>, <span class="string">"PROD"</span>);</span><br><span class="line">    Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    <span class="comment">//remainder of test will be aborted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更改默认测试实例生命周期"><a href="#更改默认测试实例生命周期" class="headerlink" title="更改默认测试实例生命周期"></a>更改默认测试实例生命周期</h2><p>如果没有注释测试类或测试接口<code>@TestInstance</code>，则JUnit Jupiter将使用默认生命周期模式。</p><blockquote><p>在jupiter api的TestInstance中定义的Lifecycle枚举</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.junit.jupiter.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> org.apiguardian.api.API;</span><br><span class="line"><span class="keyword">import</span> org.apiguardian.api.API.Status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@API</span>(</span><br><span class="line">    status = Status.STABLE,</span><br><span class="line">    since = <span class="string">"5.0"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestInstance &#123;</span><br><span class="line">    TestInstance.<span class="function">Lifecycle <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Lifecycle &#123;</span><br><span class="line">        PER_CLASS,</span><br><span class="line">        PER_METHOD;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Lifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准默认模式是<code>PER_METHOD</code>，但是，可以更改执行整个测试计划的默认值。</p><p>要更改默认的测试实例生命周期模式，只需将<code>junit.jupiter.testinstance.lifecycle.default</code> 配置参数设置为 <code>TestInstance.Lifecycle</code>忽略大小写中定义的枚举常量的名称。</p><p>这可以被提供作为一个JVM系统属性，作为配置参数在 LauncherDiscoveryRequest被传递到Launcher，或通过JUnit的平台配置文件。</p><p>例如，要设置成默认的测试生命周期模式<code>Lifecycle.PER_CLASS</code>,可以使用以下系统属性启动JVM。</p><blockquote><p>-Djunit.jupiter.testinstance.lifecycle.default=per_class</p></blockquote><p>但是请注意，通过JUnit平台配置文件设置默认测试实例生命周期模式是一个更强大的解决方案，因为配置文件可以与项目一起检入版本控制系统，因此可以在IDE和您的构建软件中使用。</p><p>要<code>Lifecycle.PER_CLASS</code>通过JUnit平台配置文件设置默认测试实例生命周期模式，请创建一个以<code>junit-platform.properties</code>类路径根目录命名的文件（例如，<code>src/test/resources</code>），具有以下内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">junit.jupiter.testinstance.lifecycle.<span class="keyword">default</span> = per_class</span><br></pre></td></tr></table></figure><blockquote><p>更改默认的测试实例生命周期模式可能导致不可预测的结果和脆弱的构建。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://junit.org/junit4/images/junit5-banner.png&quot; alt=&quot;junit5 logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;在JUnit5中，测试生命周期由4个主要注解驱动，即&lt;code&gt;@BeforeAll&lt;/code&gt;、&lt;code&gt;@BeforeEach&lt;/code&gt;、&lt;code&gt;@AfterEach&lt;/code&gt;和&lt;code&gt;@AfterAll&lt;/code&gt;。与此同时，每个测试方法都必须标注&lt;code&gt;@Test&lt;/code&gt;注解。&lt;/p&gt;
    
    </summary>
    
      <category term="JUnit5 Tutorial" scheme="http://tonydeng.github.io/categories/JUnit5-Tutorial/"/>
    
    
      <category term="junit5" scheme="http://tonydeng.github.io/tags/junit5/"/>
    
      <category term="junit" scheme="http://tonydeng.github.io/tags/junit/"/>
    
      <category term="tutorial" scheme="http://tonydeng.github.io/tags/tutorial/"/>
    
      <category term="unit testing" scheme="http://tonydeng.github.io/tags/unit-testing/"/>
    
      <category term="test lifecycle" scheme="http://tonydeng.github.io/tags/test-lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>JUnit5教程-简介</title>
    <link href="http://tonydeng.github.io/2017/10/09/junit-5-tutorial-introduction/"/>
    <id>http://tonydeng.github.io/2017/10/09/junit-5-tutorial-introduction/</id>
    <published>2017-10-09T03:09:07.000Z</published>
    <updated>2019-06-20T12:10:27.480Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://junit.org/junit4/images/junit5-banner.png" alt="junit5 logo"></p><p>这个<a href="/categories/JUnit5-Tutorial/">JUnit5教程</a>将讲述如何使用Java8风格的编码以及其他功能，同时也了解<a href="http://junit.org/junit5/" target="_blank" rel="noopener">JUnit5</a>与之前的版本的区别。</p><h2 id="Junit5简介"><a href="#Junit5简介" class="headerlink" title="Junit5简介"></a>Junit5简介</h2><p>JUnit是Java中使用最广泛的测试框架，之前Java8发布了最引人注目的lambda表达式，整个Java的编码风格发生巨大的变化，JUnit5主要在希望能够适应Java8风格的编码以及相关工，这就是为什么建议在Java8之后的项目中使用JUnit5来创建和执行测试。</p><p>JUnit官方说明：</p><blockquote><p>JUnit 5 is the next generation of JUnit. The goal is to create an up-to-date foundation for developer-side testing on the JVM. This includes focusing on Java 8 and above, as well as enabling many different styles of testing.</p></blockquote><p>JUnit5的第一个可用性版本是在2017年9月10日发布的。</p><a id="more"></a><h2 id="JUnit5架构"><a href="#JUnit5架构" class="headerlink" title="JUnit5架构"></a>JUnit5架构</h2><p>相比JUnit4，JUnit5由三个不同的子项目及不同的模块组成。</p><blockquote><p>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</p></blockquote><p>下图是JUnit的架构图</p><p><img src="https://www.ibm.com/developerworks/library/j-introducing-junit5-part1-jupiter-api/Figure-1.png" alt="junit 5 architecture "></p><h3 id="1-JUnit-Platform"><a href="#1-JUnit-Platform" class="headerlink" title="1. JUnit Platform"></a>1. JUnit Platform</h3><p>启动Junit测试、IDE、构建工具或插件都需要包含和扩展Platform API，它定义了<code>TestEngine</code>在平台运行的新测试框架的API。</p><p>它还提供了一个控制台启动器，可以从命令行启动Platform，为Gradle和Maven插件提供支持。</p><h3 id="2-JUnit-Jupiter"><a href="#2-JUnit-Jupiter" class="headerlink" title="2. JUnit Jupiter"></a>2. JUnit Jupiter</h3><p>它用于编写测试代码的新的编程和扩展模型。它具有所有新的Junit注释和<code>TestEngine</code>实现来运行这些注释编写的测试。</p><h3 id="3-JUnit-Vintage"><a href="#3-JUnit-Vintage" class="headerlink" title="3. JUnit Vintage"></a>3. JUnit Vintage</h3><p>它主要的目的是支持在JUnit5的测试代码中运行JUnit3和4方式写的测试，它能够向前兼容之前的测试代码。</p><p>下图是JUnit5的依赖关系图</p><p><img src="http://junit.org/junit5/docs/current/user-guide/images/component-diagram.svg" alt="junit 5 dependence"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>你可以在Maven或Gradle项目中使用JUnit5，包含最小的两个依赖关系，即<code>junit-jupiter-engince</code>和<code>junit-platform-runner</code>。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.jupiter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-platform-runner<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.platform.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">testRuntime(<span class="string">"org.junit.jupiter:junit-jupiter-engine:5.0.0-M4"</span>)</span><br><span class="line">testRuntime(<span class="string">"org.junit.platform:junit-platform-runner:1.0.0-M4"</span>)</span><br></pre></td></tr></table></figure><p>如果你想了解更多的话，可以查看官方的<a href="https://github.com/junit-team/junit5-samples/blob/master/junit5-gradle-consumer/build.gradle" target="_blank" rel="noopener">build.gradle</a>和<a href="https://github.com/junit-team/junit5-samples/blob/master/junit5-maven-consumer/pom.xml" target="_blank" rel="noopener">pom.xml</a>。</p><h2 id="JUnit5-Annotations"><a href="#JUnit5-Annotations" class="headerlink" title="JUnit5 Annotations"></a>JUnit5 Annotations</h2><p>JUnit5提供了以下的注解来编写测试代码。</p><table><thead><tr><th>Annotations</th><th>描述</th></tr></thead><tbody><tr><td><code>@BeforeEach</code></td><td>在方法上注解，在每个测试方法运行之前执行。</td></tr><tr><td><code>@AfterEach</code></td><td>在方法上注解，在每个测试方法运行之后执行</td></tr><tr><td><code>@BeforeAll</code></td><td>该注解方法会在所有测试方法之前运行，该方法必须是静态的。</td></tr><tr><td><code>@AfterAll</code></td><td>该注解方法会在所有测试方法之后运行，该方法必须是静态的。</td></tr><tr><td><code>@Test</code></td><td>用于将方法标记为测试方法</td></tr><tr><td><code>@DisplayName</code></td><td>用于为测试类或测试方法提供任何自定义显示名称</td></tr><tr><td><code>@Disable</code></td><td>用于禁用或忽略测试类或方法</td></tr><tr><td><code>@Nested</code></td><td>用于创建嵌套测试类</td></tr><tr><td><code>@Tag</code></td><td>用于测试发现或过滤的标签来标记测试方法或类</td></tr><tr><td><code>@TestFactory</code></td><td>标记一种方法是动态测试的测试工场</td></tr></tbody></table><blockquote><p>可以查看详细的<a href="/2017/10/10/junit-5-annotations/">JUnit5注解</a>说明</p></blockquote><h2 id="使用JUnit5编写测试"><a href="#使用JUnit5编写测试" class="headerlink" title="使用JUnit5编写测试"></a>使用JUnit5编写测试</h2><p>JUnit4和JUnit5在测试编码风格上没有太大变化。这是其<a href="/2017/10/09/junit-5-test-lifecycle/">生命周期</a>方法的样本测试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Disabled;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Tag;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.tonydeng.junit5.examples.Calculator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@BeforeAll executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setupThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@BeforeEach executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"DEV"</span>)</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCalcOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======TEST ONE EXECUTED======="</span>);</span><br><span class="line">        Assertions.assertEquals( <span class="number">4</span> , Calculator.add(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Tag</span>(<span class="string">"PROD"</span>)</span><br><span class="line">    <span class="meta">@Disabled</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testCalcTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======TEST TWO EXECUTED======="</span>);</span><br><span class="line">        Assertions.assertEquals( <span class="number">6</span> , Calculator.add(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@AfterEach executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@AfterAll executed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试套件"><a href="#测试套件" class="headerlink" title="测试套件"></a>测试套件</h2><p>使用JUnit5的测试套件，可以将测试扩展到多个测试类和不同的软件包。JUnit5提供了两个注解： <a href="http://junit.org/junit5/docs/current/api/index.html?org/junit/platform/runner/SelectPackages.html" target="_blank" rel="noopener">@SelectPackages</a> 和 <a href="http://junit.org/junit5/docs/current/api/index.html?org/junit/platform/runner/SelectClasses.html" target="_blank" rel="noopener">@SelectClasses</a> 来创建测试套件。</p><p>要执行测试套件，可以是使用 <code>@RunWith(JUnitPlatform.class)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="meta">@SelectPackages</span>(<span class="string">"com.github.tonydeng.junit5.examples"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5TestSuiteExample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，你也可以使用以下注解来过滤测试包、类甚至测试方法。</p><ol><li><code>@IncludePackages</code>和<code>@ExcludePackages</code>来过滤包</li><li><code>@IncludeClassNamePatterns</code>和<code>@ExcludeClassNamePatterns</code>过滤测试类</li><li><code>@IncludeTags</code>和<code>@ExcludeTags</code>过滤测试方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(JUnitPlatform.class)</span><br><span class="line"><span class="meta">@SelectPackages</span>(<span class="string">"com.github.tonydeng.junit5.examples"</span>)</span><br><span class="line"><span class="meta">@IncludePackages</span>(<span class="string">"com.github.tonydeng.junit5.examples.packageC"</span>)</span><br><span class="line"><span class="meta">@ExcludeTags</span>(<span class="string">"PROD"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnit5TestSuiteExample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言有助于使用测试用例的实际输出验证预期输出。为了保持简单，所有JUnit Jupiter断言是<a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assertions.html" target="_blank" rel="noopener">org.junit.jupiter.Assertions</a>类中的静态方法，例如<code>assertEquals()</code>，<code>assertNotEquals()</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Test will pass</span></span><br><span class="line">    Assertions.assertNotEquals(<span class="number">3</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test will fail</span></span><br><span class="line">    Assertions.assertNotEquals(<span class="number">4</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>), <span class="string">"Calculator.add(2, 2) test failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test will fail</span></span><br><span class="line">    Supplier&lt;String&gt; messageSupplier  = ()-&gt; <span class="string">"Calculator.add(2, 2) test failed"</span>;</span><br><span class="line">    Assertions.assertNotEquals(<span class="number">4</span>, Calculator.add(<span class="number">2</span>, <span class="number">2</span>), messageSupplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p><a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assumptions.html" target="_blank" rel="noopener">Assumptions</a>类提供了静态方法来支持基于假设的条件测试执行。失败的假设导致测试被中止。无论何时继续执行给定的测试方法没有意义，通常使用假设。在测试报告中，这些测试将被标记为已通过。</p><p>JUnit的Jupiter假设类有两个这样的方法：<code>assumeFalse()</code>，<code>assumeTrue()</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnDev</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"DEV"</span>);</span><br><span class="line">        Assumptions.assumeTrue(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)), AppTest::message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testOnProd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">"ENV"</span>, <span class="string">"PROD"</span>);</span><br><span class="line">        Assumptions.assumeFalse(<span class="string">"DEV"</span>.equals(System.getProperty(<span class="string">"ENV"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">message</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TEST Execution Failed :: "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JUnit3或4的兼容性"><a href="#JUnit3或4的兼容性" class="headerlink" title="JUnit3或4的兼容性"></a>JUnit3或4的兼容性</h2><p>JUnit4已经存在了很长时间，并且有许多以JUnit4编写的测试.JUnit Jupiter还需要支持这些测试。为此，开发了JUnit Vintage子项目。</p><p>JUnit Vintage提供了TestEngine在JUnit 5平台上运行基于JUnit 3和JUnit 4的测试的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://junit.org/junit4/images/junit5-banner.png&quot; alt=&quot;junit5 logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个&lt;a href=&quot;/categories/JUnit5-Tutorial/&quot;&gt;JUnit5教程&lt;/a&gt;将讲述如何使用Java8风格的编码以及其他功能，同时也了解&lt;a href=&quot;http://junit.org/junit5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JUnit5&lt;/a&gt;与之前的版本的区别。&lt;/p&gt;
&lt;h2 id=&quot;Junit5简介&quot;&gt;&lt;a href=&quot;#Junit5简介&quot; class=&quot;headerlink&quot; title=&quot;Junit5简介&quot;&gt;&lt;/a&gt;Junit5简介&lt;/h2&gt;&lt;p&gt;JUnit是Java中使用最广泛的测试框架，之前Java8发布了最引人注目的lambda表达式，整个Java的编码风格发生巨大的变化，JUnit5主要在希望能够适应Java8风格的编码以及相关工，这就是为什么建议在Java8之后的项目中使用JUnit5来创建和执行测试。&lt;/p&gt;
&lt;p&gt;JUnit官方说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JUnit 5 is the next generation of JUnit. The goal is to create an up-to-date foundation for developer-side testing on the JVM. This includes focusing on Java 8 and above, as well as enabling many different styles of testing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JUnit5的第一个可用性版本是在2017年9月10日发布的。&lt;/p&gt;
    
    </summary>
    
      <category term="JUnit5 Tutorial" scheme="http://tonydeng.github.io/categories/JUnit5-Tutorial/"/>
    
    
      <category term="junit5" scheme="http://tonydeng.github.io/tags/junit5/"/>
    
      <category term="junit" scheme="http://tonydeng.github.io/tags/junit/"/>
    
      <category term="tutorial" scheme="http://tonydeng.github.io/tags/tutorial/"/>
    
      <category term="unit testing" scheme="http://tonydeng.github.io/tags/unit-testing/"/>
    
  </entry>
  
  <entry>
    <title>RUN vs CMD vs ENTRYPOINT in Dockerfile</title>
    <link href="http://tonydeng.github.io/2017/09/26/RUN-vs-CMD-vs-ENTRYPOINT-in-Dockerfile/"/>
    <id>http://tonydeng.github.io/2017/09/26/RUN-vs-CMD-vs-ENTRYPOINT-in-Dockerfile/</id>
    <published>2017-09-26T09:09:47.000Z</published>
    <updated>2019-06-20T12:10:27.479Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://logo-logos.com/wp-content/uploads/2016/10/Docker_logo_horizontal.png" alt="docker logo"></p><p><code>RUN</code>、<code>CMD</code> 和 <code>ENTIRYPOINT</code>这三个<code>Dockerfile</code>指令看起来都很类似，很容易搞混。我们来通过一些实践来详细讨论一下它们之间的差别。</p><p>简单的说：</p><ol><li><code>RUN</code>执行命令并创建新的镜像层，<code>RUN</code>经常用来安装Docker image中需要的软件。</li><li><code>CMD</code>设置容器启动后默认执行的命令及其参数，但<code>CMD</code>能够被<code>docker run</code>后面跟着的命令行参数代替。</li><li><code>ENTIRYPOINT</code>配置容器启动时运行的命令。</li></ol><a id="more"></a><h2 id="Shell和Exec格式"><a href="#Shell和Exec格式" class="headerlink" title="Shell和Exec格式"></a>Shell和Exec格式</h2><p>我们可以用Shell和Exec两种方式指定<code>RUN</code>、<code>CMD</code>和<code>ENTIRYPOINT</code>要运行的命令，这两者在使用中有细微的区别。</p><h3 id="Shell格式"><a href="#Shell格式" class="headerlink" title="Shell格式"></a>Shell格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;instruction&gt; &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install python3</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello World"</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello World"</span></span></span><br></pre></td></tr></table></figure><p>当指令执行是，shell格式底层会调用<code>/bin/sh -c &lt;command&gt;</code>。</p><p>例如下面的Dockerfile片段：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> name Tony Deng</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello, <span class="variable">$name</span>"</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意环境变量<code>name</code>已经被值<code>Tony Deng</code>替换了</p></blockquote><h3 id="Exec格式"><a href="#Exec格式" class="headerlink" title="Exec格式"></a>Exec格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;instruction&gt; [<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>,...]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"apt-get"</span>,<span class="string">"install"</span>,<span class="string">"python3"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/echo"</span>,<span class="string">"Hello World"</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/echo"</span>,<span class="string">"Hello World"</span>]</span></span><br></pre></td></tr></table></figure><p>当指令执行是，会直接调用<code>&lt;command&gt;</code>，不会被<code>shell</code>解析。</p><p>例如下面的Dockerfile片段：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> name Tony Deng</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/echo"</span>,<span class="string">"Hello, <span class="variable">$name</span>"</span>]</span></span><br></pre></td></tr></table></figure><p>运行容器将输出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello, <span class="variable">$name</span></span><br></pre></td></tr></table></figure><blockquote><p>注意环境变量<code>name</code>没有被替换</p></blockquote><p>如果希望使用环境变量，可以这样来修改</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> name Tony Deng</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"echo Hello, <span class="variable">$name</span>"</span>]</span></span><br></pre></td></tr></table></figure><p>这样，容器将会输出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello, Tony Deng</span><br></pre></td></tr></table></figure><p><code>CMD</code>和<code>ENTRYPOINT</code>推荐使用<code>Exec</code>格式，因为指令可读性更强，更容易理解，<code>RUN</code>则两种格式都可以。</p><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p><code>RUN</code>指令通常用于安装应用和软件包。</p><p> <code>RUN</code>在当前镜像的顶部执行命令，并创建新的镜像层。<code>Dockerfile</code>中常常包含多个<code>RUN</code>指令。</p><p>安装多个包的例子：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    bzr \</span></span><br><span class="line"><span class="bash">    cvs \</span></span><br><span class="line"><span class="bash">    git \</span></span><br><span class="line"><span class="bash">    mercuial \</span></span><br><span class="line"><span class="bash">    subversion</span></span><br></pre></td></tr></table></figure><blockquote><p>注意： <code>apt-get update</code> 和 <code>apt-get install</code>最好放在一个<code>RUN</code>指令中执行，这样能够保证每次安装都是最新的包。如果<code>apt-get install</code>在单独的<code>RUN</code>执行，则会使用<code>apt-get update</code>创建新的镜像层，而这一层可能是很久以前缓存的。</p></blockquote><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD指令允许用户指定容器的默认执行的命令。</p><p>此命令会在容器启动且docker run没有指定其他命令时执行。</p><ol><li>如果docker run指定了其他命令，CMD指定的默认命令将被忽略。</li><li>如果Dockerfile中有多个CMD指令，只有最后一个CMD生效。</li></ol><p>CMD有三种格式：</p><ol><li><code>Exec</code>格式： <code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;,...]</code>这是<code>CMD</code>推荐的格式。</li><li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>为<code>ENTRYPOINT</code>提供额外的参数，此时<code>ENTRYPOINT</code>必须使用<code>Exec</code>格式。</li><li><code>Shell</code>格式： <code>CMD command param1 param2</code></li></ol><p><code>Exec</code> 和 <code>Shell</code> 格式前面已经介绍过了。<br>第二种格式<code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>要与<code>Exec</code>格式的<code>ENTRYPOINT</code>指令配合使用，其用途是为<code>ENTRYPOINT</code>设置默认的参数。我们将在后面讨论<code>ENTRYPOINT</code>时举例说明。</p><p>下面看看 CMD 是如何工作的。Dockerfile 片段如下：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello world"</span></span></span><br></pre></td></tr></table></figure><p>运行容器 <code>docker run -it [image]</code> 将输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>但当后面加上一个命令，比如 <code>docker run -it [image] /bin/bash</code>，<code>CMD</code> 会被忽略掉，命令 <code>bash</code> 将被执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@10a32dc7d3d3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p><code>ENTRYPOINT</code>指令可让容器以应用程序或者服务的形式运行。</p><p><code>ENTRYPOINT</code>看上去与<code>CMD</code>很像，它们都可以指定要执行的命令及其参数。不同的地方在于 <code>ENTRYPOINT</code>不会被忽略，一定会被执行，即使运行<code>docker run</code>时指定了其他命令。</p><p><code>ENTRYPOINT</code>有两种格式：</p><ol><li><code>Exec</code> 格式：<code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 这是 <code>ENTRYPOINT</code> 的推荐格式。</li><li><code>Shell</code> 格式：<code>ENTRYPOINT command param1 param2</code></li></ol><p>在为 <code>ENTRYPOINT</code> 选择格式时必须小心，因为这两种格式的效果差别很大。</p><h3 id="Exec-格式"><a href="#Exec-格式" class="headerlink" title="Exec 格式"></a>Exec 格式</h3><p><code>ENTRYPOINT</code> 的 <code>Exec</code> 格式用于设置要执行的命令及其参数，同时可通过 <code>CMD</code> 提供额外的参数。</p><p><code>ENTRYPOINT</code> 中的参数始终会被使用，而 <code>CMD</code> 的额外参数可以在容器启动时动态替换掉。</p><p>比如下面的 <code>Dockerfile</code> 片段：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/echo"</span>, <span class="string">"Hello"</span>]  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"world"</span>]</span></span><br></pre></td></tr></table></figure><p>当容器通过 <code>docker run -it [image]</code> 启动时，输出为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>而如果通过 <code>docker run -it [image] TonyDeng</code> 启动，则输出为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello TonyDengq</span><br></pre></td></tr></table></figure><h3 id="Shell-格式"><a href="#Shell-格式" class="headerlink" title="Shell 格式"></a>Shell 格式</h3><p><code>ENTRYPOINT</code> 的 <code>Shell</code> 格式会忽略任何 <code>CMD</code> 或 <code>docker run</code> 提供的参数。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>使用 <code>RUN</code> 指令安装应用和软件包，构建镜像。</p><p>如果 <code>Docker</code> 镜像的用途是运行应用程序或服务，比如运行一个 <code>MySQL</code>，应该优先使用 <code>Exec</code> 格式的 <code>ENTRYPOINT</code> 指令。<code>CMD</code> 可为 <code>ENTRYPOINT</code> 提供额外的默认参数，同时可利用 <code>docker run</code> 命令行替换默认参数。</p><p>如果想为容器设置默认的启动命令，可使用 <code>CMD</code> 指令。用户可在 <code>docker run</code> 命令行中替换此默认命令。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/" target="_blank" rel="noopener">Dockerfile: ENTRYPOINT vs CMD</a><br><a href="https://www.slideshare.net/abhishtomar/docker-43811773" target="_blank" rel="noopener">Abhishek Tomar在Slideshare关于Docker的分享</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://logo-logos.com/wp-content/uploads/2016/10/Docker_logo_horizontal.png&quot; alt=&quot;docker logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RUN&lt;/code&gt;、&lt;code&gt;CMD&lt;/code&gt; 和 &lt;code&gt;ENTIRYPOINT&lt;/code&gt;这三个&lt;code&gt;Dockerfile&lt;/code&gt;指令看起来都很类似，很容易搞混。我们来通过一些实践来详细讨论一下它们之间的差别。&lt;/p&gt;
&lt;p&gt;简单的说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;RUN&lt;/code&gt;执行命令并创建新的镜像层，&lt;code&gt;RUN&lt;/code&gt;经常用来安装Docker image中需要的软件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMD&lt;/code&gt;设置容器启动后默认执行的命令及其参数，但&lt;code&gt;CMD&lt;/code&gt;能够被&lt;code&gt;docker run&lt;/code&gt;后面跟着的命令行参数代替。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ENTIRYPOINT&lt;/code&gt;配置容器启动时运行的命令。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="效率" scheme="http://tonydeng.github.io/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="docker" scheme="http://tonydeng.github.io/tags/docker/"/>
    
      <category term="Dockerfile" scheme="http://tonydeng.github.io/tags/Dockerfile/"/>
    
      <category term="run" scheme="http://tonydeng.github.io/tags/run/"/>
    
      <category term="cmd" scheme="http://tonydeng.github.io/tags/cmd/"/>
    
      <category term="entrypoint" scheme="http://tonydeng.github.io/tags/entrypoint/"/>
    
  </entry>
  
  <entry>
    <title>Git常见分支管理实践</title>
    <link href="http://tonydeng.github.io/2017/08/31/git-common-branch-management-practices/"/>
    <id>http://tonydeng.github.io/2017/08/31/git-common-branch-management-practices/</id>
    <published>2017-08-31T08:41:28.000Z</published>
    <updated>2019-06-20T12:10:27.479Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wac-cdn.atlassian.com/dam/jcr:389059a7-214c-46a3-bc52-7781b4730301/hero.svg?cdnVersion=if" alt="git branches"></p><p>Git是目前最流行的代码版本管理系统，像<a href="https://github.io" target="_blank" rel="noopener">Github</a>也被称为全球最大的同性交友网站 ;-) 可见Git在工程师人群中的流行程度。不过在使用Git时，经常会碰到一个问题，就是采用什么样用的分支模型进行管理，Git官方也提供了很多分支模型推荐（<a href="https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener">分布式工作流程</a>这篇文章有相应的记载）。</p><p>我们这次主要介绍三种常见的Git分支模型。</p><a id="more"></a><h2 id="单主干"><a href="#单主干" class="headerlink" title="单主干"></a>单主干</h2><p>单主干的分支实践（Trunk-based development,TBD）在SVN中比较流行。<a href="http://paulhammant.com/2013/05/06/googles-scaled-trunk-based-development/" target="_blank" rel="noopener">Google</a>和<a href="http://paulhammant.com/2013/03/13/facebook-tbd-take-2/" target="_blank" rel="noopener">Facebook</a>都使用这种方式。<code>trunk</code>是SVN中主干分支的名称，对应Git中则是<code>master</code>分支。</p><p>TBD的特点是所有团队成员都在单个主干分支上进行开发。当需要发布时，先考虑使用标签（<code>tag</code>）,即<code>tag</code>某个<code>commit</code>来作为发布的版本。</p><p>如果仅仅依靠<code>tag</code>不能满足要求，则从主干分支创建发布分支。</p><p><code>bug</code>修复在主干分支进行，再<code>cherry-pick</code>到发布分支。</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-git-mange/img001.png" alt="TBD中分支流程"></p><p>由于所有开发人员都在同一个分支工作，团队需要合理的分工和充分沟通来保证不同开发人员的代码尽可能少的发生冲突。因此持续集成和自动化是必要的，用来及时发现主干分支中的bug。因为主干分支是所有开发人员公用的，一个开发人员引入的bug可能对所有人造成影响。</p><p>不过好处是由于分支所带来的额外开销非常小。开发人员不用频繁在不同的分支之间切换。</p><h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><p><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">Git Flow</a>应该是目前流传最广的Git分支管理实践。</p><p><img src="http://nvie.com/img/git-model@2x.png" alt="git flow"></p><p>Git Flow围绕的核心概念是版本发布（release）。因此Git Flow适用于各种版本发布周期的项目。</p><p>Git Flow流程中包含5类分支，分别是master、develop、feature（新功能分支）、release（发布分支）和 hotfix（热修复分支）。这些分支的作用和生命周期各不相同。</p><h3 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h3><p><img src="http://nvie.com/img/main-branches@2x.png" alt="the main branches"><br>主分支是<code>git flow</code>整个分支模型的核心，它们有无限的声明周期。主分支分别是<code>master</code>和<code>develop</code>分支。</p><p><code>origin/master</code>分支应该对每个<code>Git</code>用户都很熟悉。与<code>master</code>分支并行，另一个分支称为<code>develop</code>。</p><p>我们认为<code>origin/master</code>是<code>HEAD</code>源代码生产就绪状态的主要分支。</p><p><code>origin/develop</code>是<code>HEAD</code>源代码反映下一版本的最新发展变化的状态的主要分支。也有人会称之为“整合分支”，可以基于<code>develop</code>分支定时执行每日构建的工作。</p><p>当<code>develop</code>分支中的源代码达到一个稳定点并准备被<code>release</code>时，所有的改变应该以某种方式合并回<code>master</code>，然后用一个版本号来标记。</p><p>因此，每次将更改合并回主数据库时，这都是定义的新产品发布。在这方面往往非常严格，所以可以使用一个<code>Git Hook</code>脚本来自动构建和发布软件到生产服务器。</p><h3 id="支持分支"><a href="#支持分支" class="headerlink" title="支持分支"></a>支持分支</h3><p>除了主分支以外，<code>git flow</code>还定义了三类支持分支，分别用于不同场景。这些分支都是有限的声明周期，最终都是会被删除的。</p><p>这些分支分别是：</p><ul><li>Feature分支</li><li>Release分支</li><li>Hotfix分支</li></ul><p>每个分支都有特定的目的，对于哪些分支是用于开发工作，哪些分支是其他分支的合并目标，都有严格的规定。 </p><p>分支类型只是按照我们使用它们来进行的分类。从技术的角度来看，这些分支并不“特殊”的，它们也仅仅只是普通的Git分支。</p><h4 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h4><p><img src="http://nvie.com/img/fb@2x.png" alt="feature branchs"></p><p>从上面的图就能够很清楚的知道，<code>feature</code>分支可能来源于<code>develop</code>，并且只能合并回<code>develop</code>。</p><p><code>feature</code>分支（或有时称为<code>topic</code>分支）用于为即将到来的版本开发新功能。 </p><p>当开始一个特征的开发时，这个特征将被合并到的目标版本可能在那个时候是未知的。 feature分支的本质是，只要功能处于开发阶段，它就会存在，但最终会被合并回<code>develop</code>（为了明确地添加新功能到即将发布的版本）或丢弃（如果是令人失望的实验）。</p><h4 id="Release分支"><a href="#Release分支" class="headerlink" title="Release分支"></a>Release分支</h4><p><img src="/images/blog/git-flow-release-branches.png" alt="release branches"></p><p><code>release</code>分支可能来源于<code>develop</code>，并且只能合并回<code>develop</code>和<code>master</code>。</p><p><code>release</code>分支主要用来产品发布的准备。<code>release</code>分支允许有一些小的bug修复和准备发表的一些配置或元数据(版本号，生成日期等)的修改和提交，在发表版本之前，在<code>release</code>分支上完成这些所有的工作。此时，<code>develop</code>可以继续接受下一个大版本的feature分支的合并。</p><p>在<code>release</code>分支建立之后，即将发行的版本才被分配了一个版本号。在创建<code>release</code>分支之前，<code>develop</code>分支只是反映了“下一个版本”将要有的变化，但是不知道这个“下一个版本”是否最终会变成<code>0.3</code>或<code>1.0</code>，直到<code>release</code>分支开始创建才能确定。正常来说，这个版本号确定的决定是在<code>release</code>分支开始的时候做出的，并且需要遵循项目的版本号规则。</p><h4 id="Hotfix分支"><a href="#Hotfix分支" class="headerlink" title="Hotfix分支"></a>Hotfix分支</h4><p><img src="http://nvie.com/img/hotfix-branches@2x.png" alt="hotfix beanches"></p><p><code>hotfix</code>分支可能来源于<code>master</code>，并且只能合并回<code>develop</code>和<code>master</code>。</p><p><code>hotfix</code>分支非常类似于<code>release</code>分支，因为它也意味着准备新的产品发布，尽管是无计划的。</p><p> <code>hotfix</code>分支是由于需要立即修复生产版本的<code>bug</code>而产生的。 当生产版本中的关键错误必须立即解决时，将会基于<code>master</code>来创建一个新的<code>hotfix</code>分支出来。</p><p>这时团队成员（开发部门）的工作可以在<code>develop</code>、<code>feature</code>、<code>release</code>分支中继续，而另一个人则在<code>hotfix</code>分支中解决生产环境的bug，紧急修复并上线发布。</p><h2 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h2><p><a href="http://scottchacon.com/2011/08/31/github-flow.html" target="_blank" rel="noopener">Github Flow</a>是<a href="https://github.com" target="_blank" rel="noopener">Github</a>所使用的一种流程，它主要是依托于<code>git-flow</code>，并依托Github的<code>pull request</code>功能创建的分支模型和流程。</p><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-git-mange/img002.png" alt="Github Flow的分支流程"></p><p><code>GitHub flow</code>的好处在于非常简单实用。开发人员需要注意的事项非常少，很容易形成习惯。当需要进行任何修改时，总是从<code>master</code>分支创建新分支。完成之后通过<code>pull request</code>和相关的代码审查来合并回<code>master</code>分支。<code>GitHub flow</code>要求项目有完善的自动化测试、持续集成和部署等相关的基础设施。每个新分支都需要测试和部署，如果这些不能自动化进行，会增加开发人员的工作量，导致无法有效地实施该流程。这种分支实践也要求团队有代码审查的相应流程。</p><p>在<code>Github Flow</code>中，<code>master</code>分支中也是代表着稳定的代码。该分支已经或即将被部署在生产环境。</p><p><img src="https://cloud.githubusercontent.com/assets/70/6769770/61a2dcba-d0a8-11e4-9924-3576232053ee.png" alt="pull requests"></p><p><code>master</code>分支的作用是提供一个稳定可靠的代码基础。任何开发人员都不允许把未测试或未审核的代码直接提交到<code>master</code>分支。</p><p>对于代码的任何修改，包括<code>bug</code>修复，<code>hotfix</code>、新功能开发都在单独的分支中进行。不管是一行代码的小改动，还是需要几个星期开发的新功能，都采用同样的方式来管理。当需要进行修改时，从<code>master</code>创建一个新的分支。新分支的名称应该简单清晰的描述该分支的作用。所有相关的代码修改都在新分支中进行。开发人员可以自由的提交代码和<code>push</code>到远程仓库。</p><p>当新分支中的代码全部完成之后，通过<code>Github</code>提交一个新的<code>pull request</code>。团队中的其他人会对代码进行审核，提出相关修改意见。由持续集成服务器（如<code>Jenkins</code>）对新分支进行自动化测试。当代码通过自动化测试和代码审核之后，该分支的代码被合并到<code>master</code>分支。然后从<code>master</code>分支不是到生产环境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://wac-cdn.atlassian.com/dam/jcr:389059a7-214c-46a3-bc52-7781b4730301/hero.svg?cdnVersion=if&quot; alt=&quot;git branches&quot;&gt;&lt;/p&gt;
&lt;p&gt;Git是目前最流行的代码版本管理系统，像&lt;a href=&quot;https://github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;也被称为全球最大的同性交友网站 ;-) 可见Git在工程师人群中的流行程度。不过在使用Git时，经常会碰到一个问题，就是采用什么样用的分支模型进行管理，Git官方也提供了很多分支模型推荐（&lt;a href=&quot;https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分布式工作流程&lt;/a&gt;这篇文章有相应的记载）。&lt;/p&gt;
&lt;p&gt;我们这次主要介绍三种常见的Git分支模型。&lt;/p&gt;
    
    </summary>
    
      <category term="效率" scheme="http://tonydeng.github.io/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="git" scheme="http://tonydeng.github.io/tags/git/"/>
    
      <category term="branch" scheme="http://tonydeng.github.io/tags/branch/"/>
    
      <category term="scm" scheme="http://tonydeng.github.io/tags/scm/"/>
    
  </entry>
  
  <entry>
    <title>浅谈传统企业转型互联网</title>
    <link href="http://tonydeng.github.io/2017/08/17/traditional-enterprises-transform-the-internet-pain/"/>
    <id>http://tonydeng.github.io/2017/08/17/traditional-enterprises-transform-the-internet-pain/</id>
    <published>2017-08-17T03:34:59.000Z</published>
    <updated>2019-06-20T12:10:27.479Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog/traditional-enterprises-transform-the-internet-pain/change.png" alt><br>最近几年的确有很多原来传统行业的企业都在做一件事情，就是<strong>拥抱互联网</strong>。这些企业都希望能够进入这个在中国发展只有20年（1996年-2017年），但是却制造了太多奇迹和富豪的行业。尤其是国家全面提出了“互联网+”这个概念，所有的人都蜂拥而至，貌似如果再不和这个奇妙的“Internet”建立联系，就会被整个时代所抛弃。</p><p>我这几年也一直在一家传统医疗器械出身的互联网医疗公司负责产品和技术相关的工作，最近也和一些在类似从传统企业转型到互联网的老板们、管理者及员工聊在互联网转型过程中的一些事情，其中发现了很多共同的困境和痛苦。</p><p>下面就简单聊聊，我在这方面的一些思考。</p><a id="more"></a><p>传统企业进行互联网转型很多时候是这样的，我用一个故事来描述一下。</p><h2 id="卖袜子小贩的互联网造梦记"><a href="#卖袜子小贩的互联网造梦记" class="headerlink" title="卖袜子小贩的互联网造梦记"></a>卖袜子小贩的互联网造梦记</h2><blockquote><p>一个卖袜子的小贩，之前生意做的也不错，但是同一个市场上的卖内衣裤的小贩将他们的商品放在电子商务网站上面卖的非常好，一个月的利润翻了几番，大家都在报道卖内衣裤的小贩，说他引领传统行业转型互联网的潮流。<br>卖袜子的小贩很眼红卖内衣裤的小贩所获得的利润和名声，心想：“不就是将做一个买东西的网站，并且将商品放上去销售吗？多么easy的事情，我也能干，还能比那个卖内衣裤的小子做的更好，我不仅仅只是要将袜子放在网站上卖，而且还要自己做一个卖袜子的网站，让所有卖袜子的其他小贩也使用我的网站，创造一个伟大的袜子电商公司。”</p><p>小贩于是雇了一个写代码的做了一个卖袜子的网站。几个月之后，卖袜子的网站上线了，小贩的袜子也把他的袜子放在自己的网站上进行销售。<br>小贩认为有了网站，袜子就自然可以卖出去了，就可以是伟大的电子商务了，就可以收获到比卖内衣裤的小贩更大的利润和名声，。<br>写代码的也天天翻着Nginx、Java、MySQL、Redis等等一系列技术文档，朝着一个伟大的电子商务网站的方向努力。</p></blockquote><blockquote><p>网站上线之后，小贩天天等着人来网站上买袜子，然而并没有人来这个网站上买袜子。<br>然而，这个伟大的电子商务网站，并没有给小贩带来想象中的收益，更别提名声了。</p><p>小贩就觉得应该是网站上的功能并不够吸引人，于是让写代码的加着或者抄着其他网站各种奇怪的功能。写代码的也一味听着迎合小贩的想法，并且痛苦的实现着小贩的各种功能。</p></blockquote><blockquote><p>过了几个月之后，小贩发现他这个卖袜子的网站依然没有给带来想象中的收益，反而是由于他将之前的积蓄和大部分的精力投入到网站建设中，他原来在市场上的销售下降了，马上就面临资金链断掉的问题。<br>小贩思考良久，将所有的问题都推到写代码的身上，因为别人也是在网上卖内衣裤，卖的就非常好。但是他的卖袜子网站就没有人光顾，肯定是写代码的做的网站不够好，不够吸引人。<br>于是他愤愤炒掉了那个写代码的，心痛的关掉了网站，感叹着“都是这个写代码的没有做好，害的我赔了夫人又折兵。互联网是一个吸血狂魔，以后一定要离它远远的。”</p></blockquote><h2 id="卖袜子小贩故事后面的思考"><a href="#卖袜子小贩故事后面的思考" class="headerlink" title="卖袜子小贩故事后面的思考"></a>卖袜子小贩故事后面的思考</h2><p>上面这个卖袜子小贩的故事，大家发现了一些什么问题吗？</p><p>小贩是业务的主导，在他的眼中，写代码的是小贩用来生产网站的工具。小贩可能很懂得如何在他之前市场中如何销售袜子，知道来市场上买袜子的人要什么，他以为将袜子简单的放在网站上就可以轻松的将袜子卖给更多人，但是这些买袜子的人怎么来？这些人在哪儿？原来的市场和网站之间的关系和差异是什么？这些都问题他都不了解。结果可想而知，这件事情肯定是以失败而告终。</p><p>小贩和写代码的失败的原因就是业务和工具没有结合。小贩只是看到了卖内衣裤的成功案例，并不了解网站是一个什么样的工具？现在是否有一些什么样的工具可以把他的袜子展示更生动，更加吸引顾客来购买？不清楚如何通过什么样的推广方式，让更多人了解到可以在他的网站上可以购买到适合的袜子？</p><p>硅谷最近这几年更愿意投资公司的合伙人模式基本上都是“企业家+教授”模式，因为世界上任何一个成功的公司，尤其是互联网公司，背后一定是<strong>一群既懂得运营，又明白如何利用技术的业务和一群懂得驱动业务的技术大神们的故事</strong>。上述的组合其实指的是业务（商业）和工具（技术）要很好的结合，才能产生颠覆行业现状的新产品。</p><p>传统行业与互联网结合本质上来说是对原来行业的其他公司进行一个<strong>升维攻击</strong>，把原来这个行业大家血腥厮杀的战场从传统战场转到互联网战场，但是不同的战场就好比不同的世界，参与者必须要了解这个世界的运行规则，要不然还没有开始战斗就会在这个新世界中“水土不服”。</p><h2 id="互联网本质"><a href="#互联网本质" class="headerlink" title="互联网本质"></a>互联网本质</h2><h3 id="互联网不是什么"><a href="#互联网不是什么" class="headerlink" title="互联网不是什么"></a>互联网不是什么</h3><p>既然要和互联网结合，那互联网本质是什么？<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E6%9C%AC%E8%B4%A8" target="_blank" rel="noopener">百度百科</a>上也有很多大佬们给出相应的解释。</p><p>但我想，互联网不只是搜索、下载、游戏、电子商务、社交网络、移动终端、可穿戴设备、智能家居……这些只是互联网产品。</p><p>也不是只有自由、分享、开放、免费、痛点、体验、参与、去中心化、颠覆传统、持续创新……这只是互联网精神。</p><p>甚至也不是生态系统、个性定制、快速迭代、云计算、大数据、人工智能……这些知识互联网技术。</p><p>互联网，起于信息，基于计算机网络技术，创造了互联网产业，深刻的改变了社会的方方面面，但这背后，应当有某种更本质的东西造就了这一切。</p><h3 id="回顾过去"><a href="#回顾过去" class="headerlink" title="回顾过去"></a>回顾过去</h3><p>游牧时代 -&gt; 农业时代 -&gt; 工业时代 -&gt; 信息时代，这种划分标准是产业形态，产业是人类社会的根本。</p><p>农业时代以动植物养殖技术获得比游牧时代更稳定的食物来源。<br> %&gt;%<br>工业时代利用了机器和化石能源，创造出大工业，制造出农业社会所不能想象的无数产品。工业一直在改造农业，如果有一天工业生产用人工合成物取代了动植物产品，则农业将会消亡。</p><p>信息时代（互联网时代） 目前看来是以信息为生产对象，算是第三产业服务业的一部分。这本不该是什么巨变，自古人类社会就有信息的流通网络。然而计算机信息居然极大改变了世界，影响了工业和农业以及大量的服务业，独自成为这个时代的标志。</p><p>而且，如同农业吞并牧业，工业改造农业，互联网也对工业进行改造，虽然刚刚开始。</p><h3 id="互联网本质是人脑的延伸"><a href="#互联网本质是人脑的延伸" class="headerlink" title="互联网本质是人脑的延伸"></a>互联网本质是人脑的延伸</h3><p>我想，互联网的本质应当来源于人的本质。</p><p>意识和物质世界的二元对立，是人类眼中的世界最大的对立。</p><p><strong>人的本质就是大脑中意识</strong>。思想，灵魂，精神，自由意志，自我意识，也可以认为是一种程序软件。有些科学家认为，人类的意识就是人脑中的程序，换一个类似人脑的电脑载体，把程序拷进去，人依然还是人。</p><p>人的本质就在于灵魂，灵魂就是算法和信息。</p><p>人脑的意识通过感官获取信息，通过信息进行思想，意识也是一种信息。而互联网最基本的功能就是传递信息进入大脑，因此，信息互联网就是人脑的延伸，正如机器是身体的延伸。</p><p>而且，同样为信息而生，互联网和人类的大脑非常像，人脑内部的神经网络就仿佛一个互联网，神经元的联网形成了人的自我意识，人和人的联网形成了社会，电脑和电脑联网形成了现在的信息互联网。科学家已经在模拟人脑了。见 <a href="http://www.guokr.com/article/403444/" target="_blank" rel="noopener">Spaun：最逼真的人工大脑IBM:用超级计算机模拟人脑</a></p><p><strong>互联网的本质就是对人脑的延伸，从内容到形式都是。</strong></p><p>从整个社会发展的过程来看，<strong>社会发展的趋势是追求生产力的高效和强大</strong>。 追求生产力的高效和强大必然会要求产业和社会的协调统一，互联网就实现人类社会协调统一的重要工具。</p><h2 id="互相抱怨的农夫和铁匠"><a href="#互相抱怨的农夫和铁匠" class="headerlink" title="互相抱怨的农夫和铁匠"></a>互相抱怨的农夫和铁匠</h2><p>我们再来看另外一个农夫和铁匠的故事</p><blockquote><p>农夫拿着铁匠打造的镰刀年复一年的收割庄稼，农夫不停的对铁匠提出关于镰刀的需求，“不够锋利”，“再做大一点”，“做长一点”等等。铁匠也在每天不停抱怨需求不合理，“你根本不懂镰刀是怎么打出来的，还没有磨快，就叫我打大一点，你到底想怎么样？”。</p><p>但是，铁匠还是每天在敲打这他的铁锤打着那把镰刀，抱怨多于思考。铁匠更多时候想的是换一个农夫，去给另一个农夫打镰刀，可能会不被挨骂。</p><p>而农夫依然在用者他的那把镰刀不停的收割庄稼，心里想的永远是要把铁匠换掉。因为他觉得是他收割的粮食养活着这个铁匠，但是铁匠却不能给他提供更好的镰刀，让他在收割庄稼时能够省点力气，费力、费时又费钱，挺不靠谱的。</p><p>这样日复一日，年复一年，农夫和铁匠一直这样互相抱怨、互相“折磨”的收割庄稼、打造镰刀。镰刀是越来越大，需要收割农田也越来越多，两人都累的要死。</p></blockquote><blockquote><p>终于有一天有人开来一台收割机，此时农夫和铁匠只能在旁边看着这台收割机一天之内，把他们需要一个月收割的农田都收割完了。他们目惊口呆，互相望了一眼，异口同声的说，我们之前怎么没有想到这个东西？当他们现在想到了这样的工具和收割方式，但是农田已经和他们没有关系了。</p></blockquote><p>这个故事虽然比较简短，相信大家也在这个故事中看到了一些东西。</p><h2 id="农夫和铁匠故事的思考"><a href="#农夫和铁匠故事的思考" class="headerlink" title="农夫和铁匠故事的思考"></a>农夫和铁匠故事的思考</h2><p>从故事上看，是收割机淘汰了这名农夫和铁匠。那我们来分析一下，收割机是怎么出现的？农夫每天的工作方式有没有可能提出一个要收割机的需求？正常分析来说不可能，因为他每天最核心的工作是在和庄稼的较量，更懂得是庄稼如何生长的，但并不会像镰刀怎么造出来的，也不会去弄明白使用镰刀是不是最合理的收割方式（当然，如果这个农夫见过收割机就另当别论，但是可能只是逼着铁匠打出一个很像收割机的镰刀而已）。</p><p>每天打造镰刀的铁匠可不可能做出一个收割机呢？也不可能。因为他每天的核心工作永远是锤子和铁，并没有关心锄头被怎么使用，也不知道庄稼是如何被收割的。</p><p>但是如果他们是互相渗透合作，倒是有可能做出收割机。可是实际上，从农夫的角度认为铁匠只是给他造工具的人，他自己才是一切。从铁匠的角度，农夫只是一个每天折磨他的魔鬼，让他不停的敲打这把锄头，而且他本身也忘记了做这个锄头的目的是什么？只是一味的迎合云顶的要求，没有更多的思索。此时铁匠只是农夫的一个工具，这就好比<strong>农夫是业务，铁匠好比技术</strong>。此时两者都是失败者，因为生产力的革命是不会停下来的，总有一天会有另一帮人带着更先进的方式来接替他们的工作。</p><p>当然，有人可能会说，农夫为什么不给铁匠更多时间去思考，提出更合理的需求，更平等的地位，但是这真是问题的全部吗？仔细想想其实不然。农夫只是一味的想着用<strong>已知的方式</strong>收割庄稼（就是那把镰刀），并不懂镰刀是怎么做出来的，更不懂如何换一种方式去收割庄稼。</p><p>那这样看<strong>农夫不是一个好业务</strong>。他没有合理的重组和整合资源。</p><p>我们在来看看铁匠，是不是这个铁匠只是遇到了一个不懂事的农夫，而没有造出那个收割机？我觉得也不仅仅是这样，因为他也从来没有想过农夫是怎么来收割庄稼，镰刀是不是收割庄稼最好的工具。</p><p><strong>铁匠也不是一个好技术</strong>，因为他没有真正的运用好、制造好工具。</p><blockquote><p>其实最可怜的是那个镰刀，它只是一个原始的工具，永远没有进化的机会。</p></blockquote><h2 id="传统企业如何和互联网结合？"><a href="#传统企业如何和互联网结合？" class="headerlink" title="传统企业如何和互联网结合？"></a>传统企业如何和互联网结合？</h2><p>对于传统企业来说，互联网本质上就是一个工具。</p><p>通过农夫和铁匠的故事分析，可以大概明白了，业务、技术、工具三者之间的关系：<strong>业务与技术充分合作，制造出了工具，并在过程中不停升级进化工具，这样最终提升的是生产力，并在生产力的推动下，不停革着旧生产力的命</strong>。</p><p>这样生产力的革命电费原有行业的例子还有很多，比如之前通过电话来叫出租车，这样的平台也很多，也活的很好。业务每天经营着他的电话，技术支撑着这个电话系统，其乐融融。但是在各大打车应用大行其道的今天，这些电话叫车的平台又在哪里？</p><p>还有几年前有很多饭店也在做自己的订餐网站，自己送的并不快的外餐。一样在各大外卖平台的今天，这些小订餐网站去哪儿了？</p><p>无不证明了一件事情，一个行业通过与技术的结合，产生的具体生产力正在颠覆着这个行业。</p><p>而传统企业希望和互联网结合的目的也是为了通过互联网这样的一个新的技术和工具来颠覆原来行业，那就要考虑好传统业务如何和互联网技术整合，那必须要有一群懂的传统业务，同时也懂得互联网如何来运营、如何来工作的人，一起紧密结合来共同创造一个新的生态体系。</p><p>比如我们来看看淘宝，淘宝真正的业务是淘宝的产品团队做的平台系统规划和实现。各个淘宝的店主正在这样的技术和业务之上做着他们的业务。微店等大量的平台级的应用也是如此。</p><p>真正的技术和业务并不是小贩和他的程序员们，而是构建这个平台后面的技术和业务们。试想一下，如果这样的大平台是用这样的小贩和他的程序员们的方式可以做出来的吗？这不正是技术加业务提升了生产力之后对原生产力的革命吗（农夫铁匠的故事也是一样）？</p><p>所以，在我看来，传统企业和互联网结合其实是一个已经成型的企业如何拥抱新的技术，新的工具的过程，是这个企业持续迭代的过程。<strong>任何一个产生生产力革命的行业一定是由业务和技术结合而产生的，但是革命之后也许有可能又回到新的“农夫和铁匠”的故事中</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog/traditional-enterprises-transform-the-internet-pain/change.png&quot; alt&gt;&lt;br&gt;最近几年的确有很多原来传统行业的企业都在做一件事情，就是&lt;strong&gt;拥抱互联网&lt;/strong&gt;。这些企业都希望能够进入这个在中国发展只有20年（1996年-2017年），但是却制造了太多奇迹和富豪的行业。尤其是国家全面提出了“互联网+”这个概念，所有的人都蜂拥而至，貌似如果再不和这个奇妙的“Internet”建立联系，就会被整个时代所抛弃。&lt;/p&gt;
&lt;p&gt;我这几年也一直在一家传统医疗器械出身的互联网医疗公司负责产品和技术相关的工作，最近也和一些在类似从传统企业转型到互联网的老板们、管理者及员工聊在互联网转型过程中的一些事情，其中发现了很多共同的困境和痛苦。&lt;/p&gt;
&lt;p&gt;下面就简单聊聊，我在这方面的一些思考。&lt;/p&gt;
    
    </summary>
    
      <category term="管理" scheme="http://tonydeng.github.io/categories/%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="转型" scheme="http://tonydeng.github.io/tags/%E8%BD%AC%E5%9E%8B/"/>
    
      <category term="互联网" scheme="http://tonydeng.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
      <category term="创业" scheme="http://tonydeng.github.io/tags/%E5%88%9B%E4%B8%9A/"/>
    
      <category term="产品" scheme="http://tonydeng.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>管理者的六项关键能力</title>
    <link href="http://tonydeng.github.io/2017/05/07/six-key-ability-of-managers/"/>
    <id>http://tonydeng.github.io/2017/05/07/six-key-ability-of-managers/</id>
    <published>2017-05-07T02:03:50.000Z</published>
    <updated>2019-06-20T12:10:27.479Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog/six-key-ability-of-managers.jpg" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在国内的程序员圈子里面流传着一句经典名言：“程序员干不过30岁”（可能现在已经将这个年龄推迟到35岁）。这句名言行内的人大部分人都听过，字面上的意思大家应该都明白，说的是在软件开发领域里面，如果到一定年龄之后，如果你还是在做单纯的编码工作的话，发展空间就不大了。所以行业内的很多年轻人，在入行的时候，就有一个目标，“我要在做几年程序员之后，一定要做管理者或者转到其他职位”。在网上相关问题也是一搜一大把。</p><p>这句话，我其实还想引申到其他行业和职位上，貌似大家都会觉得当年龄增长之后，只有当上管理者之后，才算是一个顺利的或者说是安全的职业发展。</p><p>今天在这里，我先不谈所谓的国人的“官本位”思想，也不撒鸡汤来鼓吹“有技者，事竟成”，只是和大家聊聊我对管理的理解，以及对管理者需要具备的关键能力的理解。</p><p>希望大家能够在本文中看到管理应该是怎么样的，以及管理者应该是怎么样的，并且和自身对照，看看自己是否真的适合走这条道路。</p><a id="more"></a><h2 id="管理者的六项关键能力"><a href="#管理者的六项关键能力" class="headerlink" title="管理者的六项关键能力"></a>管理者的六项关键能力</h2><p>多数人都面临过做管理还是做业务的选择。很多人都想在管理上有所尝试，有的人进入了管理通道，但发展并不顺利。企业为了扩张发展而绞尽脑汁、不惜代价地培养管理者，可他们面临的最大困惑是，到底更适合带来一个团队前进?</p><p>作为一个进入职场15年的互联网人，伴随着整个互联网行业的发展，我也从一线工程师一步步到现在负责公司整个产品、研发、测试、运维多个部门的CTO，见过非常多的管理者和想晋升管理岗位却不知该如何来走的员工，其中不乏优秀杰出的管理者，也有表现一般的管理者，还有一些不合格的管理者。我一直在观察和总结，如何判断一个人是否具有管理的能力和潜力?</p><p>下面是我总结出来的管理者需要具备的关键能力，大家可以看看这些能力是否你已经具备。</p><h3 id="一、抓重点，思路清晰"><a href="#一、抓重点，思路清晰" class="headerlink" title="一、抓重点，思路清晰"></a>一、抓重点，思路清晰</h3><blockquote><p>抓重点是指能快速地将纷繁复杂的各种表面现象归纳总结为结构清晰的事物特征，抓住事物的根本、问题的关键，并确定工作重心的能力。</p></blockquote><p>管理工作涉及到的环境和对象很复杂，范围越广规模越大，复杂度就成几何级数上升。所以“抓重点”是管理者必须具有的第一项能力。</p><p>抓重点能力弱的管理人员，在工作上表现上往往是没有主见和工作思路，左右摇摆，拿不定主意，力气使不到点上。</p><p>他可能很努力、很辛苦，团队成员跟着他不停地东奔西跑，但基本上是瞎忙活，因为没有结果和成绩。</p><p>古人说“将帅无能，累死三军”就是指这种情况。</p><p>时间一长，团队成员就会失去对管理者的信心，这时候必须更换管理者了。</p><p><strong>那如何来判断一个人抓重点的能力呢？</strong></p><p>首先看他的思维是否具有结构性，能否对较为繁杂的事物进行归纳和分类，其次判断他的分类标准和原则是否正确，与解决问题的方向是否相符。</p><p>前者比较容易判断，但往往被人们忽略，第二个方面则需要具有一定的行业或管理经验才能判断他的分类原则是否准确可行。</p><p>我在很多面试或晋升管理者的场合，一般都会给应聘者3-5分钟时间作自我介绍和对目标岗位的理解，有的候选人时间过半了还在报流水帐式地介绍自己的工作经历，</p><p>如果是这样的介绍，我对这样的人基本上会做出否定判断，因为他抓重点的能力很差，对管理者来说，抓重点这个能力可以实行一票否决。</p><p>如果你想成为一个优秀的管理者，需要训练自己结构化的思考能力，简单地说就是归纳、概括和总结的能力。</p><p>普通人关注的是思维的逻辑性，讲的是前后的连续性和流畅性。而管理者需要具有较强的结构化思考能力。</p><h3 id="二、强烈的目标导向意识"><a href="#二、强烈的目标导向意识" class="headerlink" title="二、强烈的目标导向意识"></a>二、强烈的目标导向意识</h3><blockquote><p>结果导向也就是目标导向，是杰出管理者最突出的思维特征。</p><p>管理是为了达成目标，而且是团队或组织的目标，不能达成预期目标的管理者一定不是好的管理者，优秀管理者一定是目标感很强的人。</p></blockquote><p>目标导向意识就是以终为始，高度关注和聚焦目标和结果，将团队或组织的核心资源、策略都指向目标的达成，所有行动都必须是对目标达成有高度贡献的。</p><p>这种管理者给外部的印象就是目标清晰、执行力很强。</p><p>之所以目标导向特别重要，是因为有很多人出发的时候有目标，在路途往往忘了或偏离了目标，或者被一些新鲜的、好奇的事物所吸引，或者是因为碰到了困难、挫折、受了苦或委曲，放弃了既定的目标。</p><p>优秀管理者设定目标的时候很慎重，一旦确立了目标，就会坚定不移、不受任何干扰的向着目标前行，直到达成为止。</p><p><strong>专业技术人才向管理者转型的时遇到的最大障碍就是结果导向思维模式的建立。</strong></p><p>因为长期的技术工作训练了专业技术人才的技术思维方式。导致专业技术人员的思维和管理人员的思维方式有根本的不同。</p><p>专业技术人员的思维是直线式思维，由始到终，就是从已知条件推导出结果，一旦已知条件项缺少时，就无法推出结果，他们就会很焦虑。把这种思维带到管理中，最典型表现的是他们会跟上级要求很多条件，因为在他的思维中是只有当条件足够时，才能得到结果，而当结果没有达成时，他们给出的理由都是上级给的条件不充分或者环境改变、对手太快，责任不在他本人。</p><p>而管理者是结果导向的思维，以终为始，从目标开始考虑需要什么条件，然后主动想办法去创造条件从而达成问题的解决，技术思维者往往是被动的等待条件成熟。</p><h3 id="三、发现规律，预测结果"><a href="#三、发现规律，预测结果" class="headerlink" title="三、发现规律，预测结果"></a>三、发现规律，预测结果</h3><p>在当今快速变化的时代，管理者所面对的环境瞬息万变，要求管理者能够快速做出判断，也就通常说的要具有快速反应、灵活应变的能力。</p><p>快速灵活应变只是一种行为表现，其背后的能力是什么呢?</p><p>实际上是管理者善于并快速发现事物的运行规律并能够对事情的发展结果进行准确预测。如果不能把握事物的运行规律并做出准确预测结果，就容易做出错误的判断，影响管理目标的达成。</p><p>在同一家企业，为什么有的团队的运转节奏快、效率高，有的团队的运转节奏慢、效率低，其背后十有八九的原因是这两个团队的Leader他们在发现规律和预测结果的能力上有差异。</p><p>此项能力弱的管理者，他为了做出正确的判断，就需要做大量的调查、研究、查资料、开会、讨论，团队Leader决策效率的下降带来整个团队的工作节奏下降，工作效率降低。</p><p>有的人将这种能力称为直觉，即不需要思考就能判断的能力，并认为是天生的能力。</p><p>从表面观察看，直觉思维很强的人在紧急情况下快速判断，似乎是没有经过思考，当我们对他的决策过程进行深入分析时，就会发现他们的大脑中实际上存储了有关事物运行的基本原理、原则等相关概念，他们提取的速度很快，使我们感觉不到他的思考过程。</p><p>这种能力强的人有一个共同的特点，就是他们知识面比较广，而且这些知识是经过整理以后以他自己的方式存储的，所以提取和加工起来很快。</p><p>要练就这种能力，必须要加强学习，不是简单的死记硬背一些知识，而是以自己便于记忆和提取的方式进行学习。这种能力也是可以培养的，是靠知识和经验的有效积累。</p><p><strong>优秀的管理者他们的思维具有很强的辩证思维的特征。</strong></p><h3 id="四、格局与大局观"><a href="#四、格局与大局观" class="headerlink" title="四、格局与大局观"></a>四、格局与大局观</h3><p>有些人工作后很快就走上基层主管岗位，他们雄心勃勃，非常努力，表现很好，执行力很强，任务完成也不错。但当他到了中层岗位后，尽管做得很努力很辛苦，业绩反而会往下走，要么苦苦支撑，要么被撒换掉。</p><p>我分析了很多这样的人，发现他们有一定共同的问题，就是大局观不够。</p><blockquote><p>大局观指能够全面地、系统地、前瞻性地看问题、思考问题，能够从整体上把握事物发展的趋势和规律。</p></blockquote><p>具有大局观的人，一般都会站位比较高，能够从高处俯瞰事物，视野开阔，能够看到事物的全部，在思考时遗漏就很少，决策的错误就会减少。</p><p>缺乏大局观的人往往会只抓住眼前或局部一点猛攻，但常常顾此失彼，对于公司和上级的战略意图，他们难于理解，要么简单执行，要么曲解打折扣地执行。</p><p>具有大局观的人具有很强的历史观，他们往往能够从历史的角度来分析事物的发展演变规律，具有历史观的人看问题具有穿透力，够看到未来，从而具有前瞻性。</p><p>自我中心主义、私心、小九九是制约一个人大局观的重要因素，要培养大局观，就要把个人的小我和私心放下，把个人的利益放到一边，视野才会变得开阔，全局观就会提高。</p><p><strong>大局观决定一个人层次，而决定一个人大局观的是他的志向。</strong></p><h3 id="五、突破常规"><a href="#五、突破常规" class="headerlink" title="五、突破常规"></a>五、突破常规</h3><p>多数人都能想到的方案、通用做法都属于常规办法。</p><p>当然，一种思路或办法能够成为常规，说明这个思路和办法对解决问题是有一定效果的，至少在过去是有效的，否则它不会成为常规。</p><p>但是，当新问题出现或问题中新元素越来越多的时候，常规思路和方法就会开始失效，而且效果就会越来越差，必须另辟蹊径才能有效解决问题。</p><blockquote><p>突破常规是指管理者在面对复杂棘手的问题时，常常以不寻常的思维方式提出一些意想不到的观点、策略和措施，而且这种思路和办法是有效的、能够切实解决问题。</p></blockquote><p>判断是否突破了常规，有两个基本标志。</p><ol><li><p>新颖性，别人没有做过的，或者说在已知的圈子里没有人这么想或这么做过，这是基本点。</p></li><li><p>有效性，就是用这种方法比其它已知的方法都有效得多。</p></li></ol><p>真正高水平的突破常规往往能够做到奇效，即指构思精巧，抓住了关键环节和杠杆点，具有四两拨千斤之力，投入少，产出大，一题解则百难消，令人赞叹和称奇。</p><blockquote><p>突破常规并不是别出心裁、为求新而求异。</p></blockquote><p>我们不能忘了管理的根本任务是面对事实、解决问题，达成目标，所以有效性是第一原则。</p><p>突破常规也是有底线的，就是法律和道德伦理的底线。那些踩红线、打擦边球的做法并不是突破常规的思维，而是侥幸心理。</p><p><strong>突破常规就是不走寻常路，从思维特征上看具有逆向思维、发散思维的特点。</strong></p><p><strong>那些爱思考、善于总结、不盲从的人突破常规的能力较强。突破常规是建立在对事物规律和人性本质的深刻洞察之上，它与投机取巧、耍小聪明是有根本差别的。</strong></p><p><strong>突破常规需要开放的心态，一个封闭的，自我保护很严的人，是不可能提升这项能力的。</strong></p><h3 id="六、创设沟通平台"><a href="#六、创设沟通平台" class="headerlink" title="六、创设沟通平台"></a>六、创设沟通平台</h3><p>沟通能力对处于现代开放社会在成员来说十分重要，每个人都在不断提升自己的沟通能力，管理者也不例外，只能是要求更高。</p><p>但是人们通常所说的沟通能力主要是指人际沟通能力，市面上绝大多数的沟通培训课程也都是为了提高管理者的人际沟通能力而设计的。</p><p>对一个组织来说，管理者的最大价值是能够做出正确的决策，指明前行和胜利的方向。</p><p>因此，必须使管理者的意图、思想、决定得到准确的理解和彻底的执行，否则，管理者所具有的思维优势、判断决策优势就没有意义了。</p><p>所以，对于<strong>管理者来说，仅有人际沟通技能是不够的，因为人际沟通的效率和范围是有限的，在组织规模扩大后，他必须具备很好的管理沟通能力才能管理好组织，我们把这种能力称为创设沟通平台的能力。</strong></p><p>组织规模越大，管理层级越高，对这个能力要求也越高，即使在组织扁平化、团队小型化成为流行趋势的今天，这种能力要求也是越来越高，因为你的沟通不仅限于你的团队内部，团队外部沟通会越来越多，当你的决策涉及到很多部门、很多地区、很多管理层级、很多人员时，仅有人际沟通能力显然是不够的。</p><blockquote><p>所谓沟通平台，简单地说就是建立沟通的机制、渠道和制度。</p></blockquote><p>在一个正式组织内部，都有一定的沟通渠道和机制、制度，但当你做出一个新的决定时，可能原有的渠道和机制不起作用了，或者，它的效率和效果达不到你想要的要求，这时候，你就要创设新的沟通平台来畅通信息的渠道。</p><p>创设沟通平台时，首先必须明白你的决定需要告知的对象，这些对象的链条有多长，现有渠道的弱点是什么，用什么方式可以打通，而且让这种沟通成为一种机制。</p><p>比如，周会制度，晨会制度，联席会议制度等，这些都是比较好的管理沟通平台，遗憾的是很多管理者对此认识并不深刻，没有认识到会议的沟通价值，当然，必须是有效的会议。</p><p>要使会议有效则需要会议管理的技能。沟通平台绝不仅仅限于常规的会议方式。</p><p>管理者还要熟悉各种管理沟通工具，包括现代移动互联通信工具如微信等等。</p><h2 id="组建管理团队的建议"><a href="#组建管理团队的建议" class="headerlink" title="组建管理团队的建议"></a>组建管理团队的建议</h2><p>当然，在现实中，六个方面都很强的人很少，多数人可能是在某一或某几个方面具有较强的优势，所以在一个公司里面管理者团队搭建的时候最好能够完成以上六种能力的组合。</p><p>这样，你会发现和这样的团队一起工作是已经非常幸福的事情。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog/six-key-ability-of-managers.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在国内的程序员圈子里面流传着一句经典名言：“程序员干不过30岁”（可能现在已经将这个年龄推迟到35岁）。这句名言行内的人大部分人都听过，字面上的意思大家应该都明白，说的是在软件开发领域里面，如果到一定年龄之后，如果你还是在做单纯的编码工作的话，发展空间就不大了。所以行业内的很多年轻人，在入行的时候，就有一个目标，“我要在做几年程序员之后，一定要做管理者或者转到其他职位”。在网上相关问题也是一搜一大把。&lt;/p&gt;
&lt;p&gt;这句话，我其实还想引申到其他行业和职位上，貌似大家都会觉得当年龄增长之后，只有当上管理者之后，才算是一个顺利的或者说是安全的职业发展。&lt;/p&gt;
&lt;p&gt;今天在这里，我先不谈所谓的国人的“官本位”思想，也不撒鸡汤来鼓吹“有技者，事竟成”，只是和大家聊聊我对管理的理解，以及对管理者需要具备的关键能力的理解。&lt;/p&gt;
&lt;p&gt;希望大家能够在本文中看到管理应该是怎么样的，以及管理者应该是怎么样的，并且和自身对照，看看自己是否真的适合走这条道路。&lt;/p&gt;
    
    </summary>
    
      <category term="管理" scheme="http://tonydeng.github.io/categories/%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="management" scheme="http://tonydeng.github.io/tags/management/"/>
    
      <category term="管理" scheme="http://tonydeng.github.io/tags/%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Plantuml介绍以及在Hexo中的相关插件</title>
    <link href="http://tonydeng.github.io/2017/04/14/hexo-plantuml-diagram-plugin/"/>
    <id>http://tonydeng.github.io/2017/04/14/hexo-plantuml-diagram-plugin/</id>
    <published>2017-04-14T08:31:48.000Z</published>
    <updated>2019-06-20T12:10:27.478Z</updated>
    
    <content type="html"><![CDATA[<p><img src="data:image/png;base64,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" alt="plantuml logo"></p><h2 id="PlantUML-简介"><a href="#PlantUML-简介" class="headerlink" title="PlantUML 简介"></a>PlantUML 简介</h2><p><a href="http://plantuml.com/" target="_blank" rel="noopener">PlantUML</a>是一个画图脚本语言，官方介绍如下：</p><blockquote><p>Generate UML diagram from textual description</p></blockquote><a id="more"></a><p>用它可以快速地画出：</p><ol><li><a href="http://plantuml.com/sequence-diagram" target="_blank" rel="noopener">Sequence diagram</a></li><li><a href="http://plantuml.com/use-case-diagram" target="_blank" rel="noopener">Use case diagram</a></li><li><a href="http://plantuml.com/class-diagram" target="_blank" rel="noopener">Class diagram</a></li><li><a href="http://plantuml.com/activity-diagram-beta" target="_blank" rel="noopener">Activity diagram</a></li><li><a href="http://plantuml.com/component-diagram" target="_blank" rel="noopener">Component diagram</a></li><li><a href="http://plantuml.com/state-diagram" target="_blank" rel="noopener">State diagram</a></li><li><a href="http://plantuml.com/object-diagram" target="_blank" rel="noopener">Object diagram</a></li><li><a href="http://plantuml.com/deployment-diagram" target="_blank" rel="noopener">Deployment diagram</a></li><li><a href="http://plantuml.com/timing-diagram" target="_blank" rel="noopener">Timing diagram</a></li></ol><p>对于工程师们来说，用代码的方式来画图，简直是为其量身定做的。PlantUML语法也非常简单，参见<a href="http://plantuml.com/PlantUML_Language_Reference_Guide.pdf" target="_blank" rel="noopener">PlantUML Language Reference Guide</a>，它支持很多<a href="http://plantuml.com/running.html" target="_blank" rel="noopener">工具</a>，可以生成PNG、SVG、LaTeX和二进制图片。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>有非常多的工具来协助工程师们使用PlantUML的语法来进行画图，比如ATOM有<a href="https://atom.io/packages/language-plantuml" target="_blank" rel="noopener">language-plantuml</a>、<a href="https://atom.io/packages/plantuml-viewer" target="_blank" rel="noopener">plantuml-viewer</a>、<a href="https://atom.io/packages/markdown-preview-enhanced" target="_blank" rel="noopener">markdown-preview-enhanced</a>等各种Packages。当然其他的编辑器也有同样的类似的插件。</p><p>另外，我也写了一个<a href="https://github.com/tonydeng/plantuml-tour" target="_blank" rel="noopener">plantuml-tour</a>的项目，其中有哦PlantUML的一些例子，执行脚本，以及安装说明等。大家有兴趣，也可以去看看这个项目。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面的例子是通过<a href="http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000" target="_blank" rel="noopener">在线示例工具</a>生成的。</p><h3 id="比如这样简单的三行文本，就能生成一个基本的时序图。"><a href="#比如这样简单的三行文本，就能生成一个基本的时序图。" class="headerlink" title="比如这样简单的三行文本，就能生成一个基本的时序图。"></a>比如这样简单的三行文本，就能生成一个基本的时序图。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Bob -&gt; Alice : hello</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="http://www.plantuml.com/plantuml/png/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000" alt="plantuml online sequence diagram"></p><p><a href="http://www.planttext.com/planttext" target="_blank" rel="noopener">http://www.planttext.com/planttext</a>也是一个类似的导出工具，并且可以在这个网站上直接查看和测试<code>Plantuml</code>不同图形的语法。</p><h3 id="除了之前说过的可以生成的图形，还能生成其他图形，比如生成🌍图形。"><a href="#除了之前说过的可以生成的图形，还能生成其他图形，比如生成🌍图形。" class="headerlink" title="除了之前说过的可以生成的图形，还能生成其他图形，比如生成🌍图形。"></a>除了之前说过的可以生成的图形，还能生成其他图形，比如生成🌍图形。</h3><p><img src="https://www.planttext.com/plantuml/img/RLVRSjis47tNLs2ObtGcml0caNfgV4aQtnBNafjftrOIBAAY01KauoXVtxEWRCcayg8Cl0livUmvouzLJQvkDkNWfy9_Ye4OHpBAn30QXJ8CHN1c5eLrj5A1EFnx9yvAgjRqGJnEpmOYoTbKY3YHMGANkb2cEhRtBdyufHOArebC-IHD-JSufrMnf6NGiRvozDz0HFv64OMX78LiQrPhk-xQpWhI9Pabxfx8IGpxQ2nJH7AkzB_QhBhs5uKsD12ZM8vmEJ-IncpiIctwOIkt8RF3tR5aw-4ubPdmvfjcITsxzyS3aS8SziCiac4ESrlLjd_x7LKLBOgcKdLTjUL4wMNE3wMPdF13ZYfTwhSluI57ltGvW9cC-GHUIMlzwnVzq6Lvr36aRCtA3eP9AiS8VZZAstesojXAd6cd3lr2SzrAcThNA47q8npYDnw9u8AqivqauF1fjTlM0n6Ze7oGvpwK2oeNJLrt0xyoIqq89P4JN_rSfXaRRvMOsMVp5cTJszI5E7joUa4UEcC-7sRy2v-AvcZyulW9rDGwkrXOyVw1vbJ__Xjw4ScSUv5dCkCi2josiZt8bUY_rTKBgcEPeG_3oLZcgDKbbS1yhu4pzPDUFE9SZZcbB9CnFBwgPt6foaA_JQdDdw6AM8PHEF9pTgdC3-Lwrr_O4jEtj2yleDdymcWaOu3gifcJxhVZyUoJU7ysRyHbGNED0WpZJ4Q27vlucVj4LQsSkAfuQe9NlpV7m276cXkKvUmSVCOiTT-24n_xGUNMHnXgr2puew7D2Li-1iE4Ck8auZRpBwgij5dhe7klQMSQg6A0Hr7gm_W298iR-tQgtudNOpX4CecPmJBkEZlOiYcRplrVw9cqtjTrj7yZJ3rohzowgQiUp-oFFuY7fgguXy0LLqZ44_uDha2cPjwKdPTcZLkh7JfYrkI8yJWS-mf4uTZZyPhmXxf79G2ADSe_XF7B-J0PSPp1jN9DHQNQT91LELAW14ovdyFnn5lVK3ScRttsj2h8Q8uPDSkOr32wBOlSK5s0zPRDsmU-gYtXVaY3P_0av7U26wr-d6ZsuzgHDY1yaUopZMI6VjyqL9AuRJRRnXsHpXrETpvP0VBsyIUU6MungjsvurZqIZacaYYMKSYSa35L1RTwGoUYkKV947d4l0VZa4KkkBLSujxGFHfTgwMuWNGiBG2RXYmGy88QGIZkQEdqikSrtI9TJ4BgEIgAFJPWRA1DVTeebBWlmD9wYnfL7hHjpXC_G7TgiUYbWJUeMMhmCyOQXOhyD8EX9duoxjHF3TgxqFNkcFhRum6FMyxMUUXHSQTfSu8xFeDlzF95sT4AdtWKjb5Pu-oFdXJTwhblXKX7FebXvjc0pMkdg3iFVpPghXOVn0KPOgK4cMLUOpAFZpjRBUnphs8lCpUCcFfWFVRJ_PKLQQwxitEZp8wldkn59lI3zgqgU-h5KBBkcQ3mQIvpFmLUkeDxSle4y3uxA8w2WCKjFK9uMQO1iBeuCMLDLJig3zK1NhrC1lVMrSVyktVuvjJAcdtzXs5RVr0mk_pPwFgK_2uQI8G3iu8Y-Gc0QG9uFwZT-b_i0kiEJInKI_089CzvqKYycZneAvPAN9DH1vK_B1eiebnup1ll3WzseqxKyggc4gMCMcRq3ET9cvSkSQTDSS3dE_6NLhMXZNZ_XI2yp8n9rgeYGWC715CoRRqrC74GAcmM-iawerznYZvp9dagmwnrkxQLwfJs0ZiOYGU_IaHv2zNnsC-EzsZ8T3pk6tJLielr6qkBxj3d19TQTzS8lroMJ7hHNb4IZuufk8IsrdNMwDTZlo_oQiPBT8BoJksJFa40vqsv8ZzhW7QotvzulvpMTh4kRDcHXEcpMYhJRbky68_yTXzCTqkZThqPEu1r6FaLQnYb4u-y6HMwxj85QCmVevhZLf_0a25RwysyMTTToGN5Q_7-d3QqjhxP8vzorAv2mSokToVGVKrRLYY05Eo0wa_yjZx3acUwmu3fCVYUqVP0BfZI2Vy92mgptipfhIrxT046OxfeDswFMcxQ8yP4d5DjZ_SotY-nIxSJ3O7bJGCzWmG5Vm6ejkciSUYPl927W40oiKV6M2Re14R0cBu--4vuvSzzI5xT4D9tgl3nidhxAV6gMDEQQeZ9C6qvCifINc63xuetsvuJxwV_W9xzbZMEMtAAsWteRxZOvxNHJsy-8xxAsL4gax3zxXFjfo9e5BlwlJt-ycZPTNyy67Oysks-vt4u7dnKM48svVy0" alt="xearth diagram"></p><p>下面是生成上面地图的plantuml描述</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">xearth</span><br><span class="line"> 61.17 -150.00 &quot;Anchorage&quot;           # Alaska, USA</span><br><span class="line"> 38.00   23.73 &quot;Athens&quot;              # Greece</span><br><span class="line"> 33.4    44.4  &quot;Baghdad&quot;             # Iraq</span><br><span class="line"> 13.73  100.50 &quot;Bangkok&quot;             # Thailand</span><br><span class="line"> 39.92  116.43 &quot;Beijing&quot;             # China</span><br><span class="line"> 52.53   13.42 &quot;Berlin&quot;              # Germany</span><br><span class="line"> 32.3   -64.7  &quot;Bermuda&quot;             # Bermuda</span><br><span class="line"> 42.33  -71.08 &quot;Boston&quot;              # Massachusetts, USA</span><br><span class="line">-15.8   -47.9  &quot;Brasilia&quot;            # Brazil</span><br><span class="line"> -4.2    15.3  &quot;Brazzaville&quot;         # Congo</span><br><span class="line">-34.67  -58.50 &quot;Buenos Aires&quot;        # Argentina</span><br><span class="line"> 31.05   31.25 &quot;Cairo&quot;               # Egypt</span><br><span class="line"> 22.5    88.3  &quot;Calcutta&quot;            # India</span><br><span class="line">-33.93   18.47 &quot;Cape Town&quot;           # South Africa</span><br><span class="line"> 33.6    -7.6  &quot;Casablanca&quot;          # Morocco (Rabat?)</span><br><span class="line"> 41.83  -87.75 &quot;Chicago&quot;             # Illinois, USA</span><br><span class="line"> 32.78  -96.80 &quot;Dallas&quot;              # Texas, USA</span><br><span class="line"> 28.63   77.20 &quot;New Delhi&quot;           # India</span><br><span class="line"> 39.75 -105.00 &quot;Denver&quot;              # Colorado, USA</span><br><span class="line"> 24.23   55.28 &quot;Dubai&quot;               # UAE (Abu Dhabi?)</span><br><span class="line">-27.1  -109.4  &quot;Easter Island&quot;       # Easter Island</span><br><span class="line">-18.0   178.1  &quot;Fiji&quot;                # Fiji</span><br><span class="line"> 13.5   144.8  &quot;Guam&quot;                # Guam</span><br><span class="line"> 60.13   25.00 &quot;Helsinki&quot;            # Finland</span><br><span class="line"> 22.2   114.1  &quot;Hong Kong&quot;           # Hong Kong</span><br><span class="line"> 21.32 -157.83 &quot;Honolulu&quot;            # Hawaii, USA</span><br><span class="line"> 52.2   104.3  &quot;Irkutsk&quot;             # Irkutsk, Russia</span><br><span class="line"> 41.0    29.0  &quot;Istanbul&quot;            # Turkey (Ankara?)</span><br><span class="line"> -6.13  106.75 &quot;Jakarta&quot;             # Indonesia</span><br><span class="line"> 31.8    35.2  &quot;Jerusalem&quot;           # Israel</span><br><span class="line"> 34.5    69.2  &quot;Kabul&quot;               # Afghanistan</span><br><span class="line"> 27.7    85.3  &quot;Kathmandu&quot;           # Nepal</span><br><span class="line"> 50.4    30.5  &quot;Kiev&quot;                # Ukraine</span><br><span class="line">  3.13  101.70 &quot;Kuala Lumpur&quot;        # Malaysia</span><br><span class="line">  6.45    3.47 &quot;Lagos&quot;               # Nigeria</span><br><span class="line">-12.10  -77.05 &quot;Lima&quot;                # Peru</span><br><span class="line"> 51.50   -0.17 &quot;London&quot;              # United Kingdom</span><br><span class="line"> 40.42   -3.72 &quot;Madrid&quot;              # Spain</span><br><span class="line"> 14.6   121.0  &quot;Manila&quot;              # The Phillipines</span><br><span class="line"> 21.5    39.8  &quot;Mecca&quot;               # Saudi Arabia</span><br><span class="line"> 19.4   -99.1  &quot;Mexico City&quot;         # Mexico</span><br><span class="line"> 25.8   -80.2  &quot;Miami&quot;               # Florida, USA</span><br><span class="line">  6.2   -10.8  &quot;Monrovia&quot;            # Liberia</span><br><span class="line"> 45.5   -73.5  &quot;Montreal&quot;            # Quebec, Canada</span><br><span class="line"> 55.75   37.70 &quot;Moscow&quot;              # Russia</span><br><span class="line"> -1.28   36.83 &quot;Nairobi&quot;             # Kenya</span><br><span class="line"> 59.93   10.75 &quot;Oslo&quot;                # Norway</span><br><span class="line"> 48.87    2.33 &quot;Paris&quot;               # France</span><br><span class="line">-32.0   115.9  &quot;Perth&quot;               # Australia</span><br><span class="line"> 45.5  -122.5  &quot;Portland&quot;            # Oregon, USA</span><br><span class="line"> -0.2   -78.5  &quot;Quito&quot;               # Ecuador</span><br><span class="line"> 64.15  -21.97 &quot;Reykjavik&quot;           # Iceland</span><br><span class="line">-22.88  -43.28 &quot;Rio de Janeiro&quot;      # Brazil</span><br><span class="line"> 41.88   12.50 &quot;Rome&quot;                # Italy</span><br><span class="line"> 11.0   106.7  &quot;Ho Chi Minh City&quot;    # Vietnam (Hanoi?)</span><br><span class="line"> 37.75 -122.45 &quot;San Francisco&quot;       # California, USA</span><br><span class="line">  9.98  -84.07 &quot;San Jose&quot;            # Costa Rica</span><br><span class="line"> 18.5   -66.1  &quot;San Juan&quot;            # Puerto Rico</span><br><span class="line">-33.5   -70.7  &quot;Santiago&quot;            # Chile</span><br><span class="line">  1.2   103.9  &quot;Singapore&quot;           # Singapore</span><br><span class="line"> 42.67   23.30 &quot;Sofia&quot;               # Bulgaria</span><br><span class="line"> 59.33   18.08 &quot;Stockholm&quot;           # Sweden</span><br><span class="line">-33.92  151.17 &quot;Sydney&quot;              # Australia</span><br><span class="line">-17.6  -149.5  &quot;Tahiti&quot;              # Tahiti</span><br><span class="line"> 16.8    -3.0  &quot;Timbuktu&quot;            # Mali (Bamako?)</span><br><span class="line"> 35.67  139.75 &quot;Tokyo&quot;               # Japan</span><br><span class="line"> 43.70  -79.42 &quot;Toronto&quot;             # Ontario, Canada</span><br><span class="line"> 32.9    13.2  &quot;Tripoli&quot;             # Libya</span><br><span class="line"> 47.9   106.9  &quot;Ulan Bator&quot;          # Mongolia</span><br><span class="line"> 49.22 -123.10 &quot;Vancouver&quot;           # B.C., Canada</span><br><span class="line"> 48.22   16.37 &quot;Vienna&quot;              # Austria</span><br><span class="line"> 38.9   -77.0  &quot;Washington&quot;          # United States</span><br><span class="line">-41.28  174.78 &quot;Wellington&quot;          # New Zealand</span><br><span class="line"> 62.5  -114.3  &quot;Yellowknife&quot;         # N.T., Canada</span><br><span class="line"> 90.00    0.00 &quot;North Pole&quot;          # North Pole</span><br><span class="line">-90.00    0.00 &quot;South Pole&quot;          # South Pole</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h2 id="PlantUML和Hexo整合"><a href="#PlantUML和Hexo整合" class="headerlink" title="PlantUML和Hexo整合"></a>PlantUML和Hexo整合</h2><p>无意中，发现一个Hexo的插件，就是<a href="https://github.com/oohcoder/hexo-tag-plantuml" target="_blank" rel="noopener">hexo-tag-plantuml</a>，这个插件能够让Hexo生成的网站可以方便的集成PlantUML来生成相关的图。</p><p>使用起来也非常简单，只需要将原来的plantuml文件中的<code>@startuml</code>、<code>@enduml</code>分别改成<code><img src="http://www.plantuml.com/plantuml/svg/ItZSq9W00000"></code>，既可以将原来一个个的plantuml文件中的图形，展示在网站上。</p><h3 id="安装hexo-tag-plantuml"><a href="#安装hexo-tag-plantuml" class="headerlink" title="安装hexo-tag-plantuml"></a>安装hexo-tag-plantuml</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-tag-plantuml <span class="comment">--save</span></span><br></pre></td></tr></table></figure><h3 id="比如我们通过hexo-tag-plantuml插件，在网站上展示相对复杂的类图"><a href="#比如我们通过hexo-tag-plantuml插件，在网站上展示相对复杂的类图" class="headerlink" title="比如我们通过hexo-tag-plantuml插件，在网站上展示相对复杂的类图"></a>比如我们通过hexo-tag-plantuml插件，在网站上展示相对复杂的类图</h3><img src="http://www.plantuml.com/plantuml/svg/TLLTJnj757tVNp6Fk0Z5IPjMGYXIIbIfYYfLCdzWlJk4RPOTj1wIqZRIEWto6Z1E2KqeWJGEE7RRu1XHkSOB-CTaPtRzn5_edPtr1pP-GSkvvvvxxvaxOsfG4oEsNGlALRxNufiLvZQ2wZfh5HKbewaGl7axcKIF3PqkABDaSObOsA9evfUfANGVhwI9Qkje6WLUXUVRRFKaEF66QIdDnjWQHcSXyPvjFCBsQ2Ipa3897SQ_jmsB0hrNDaBlQjGWLXSR2iuPsaDCxnkMFePm3sUeOQbN99IhacXcQkgpM2b5J3srag5uCPhv6NlknZEFLhe-JxccuXYcz6rCi6_VM89qSKmuDdDCLCayDAmbrLONaMQgcSnTIcqZlKpnjngnKiPF62KLnI8K8qgM49b7_QEQHdpjF3mkTNwj-buZEFOkppPutk5x-HuIx3uBNF4X9KmyJuN6m3frO25VxqWXmOkQ62Zoiu8c3SkW4udfHyJG5OGcTPB2vlmSkDi5dyHfFLsHzG3cn2RMA1O71LIm0PWnDRPS43CBvF4S_d54RS3uM6_MndhKIWfCiXv4pU2qGRzHRGoeJfRJ9WOKJU8VeF1tGc5KDJwjhYRytrViihg79aXBubiUt80BKOMhQ3TvQAlZGXBj-I2fronpJEz7HhkxRhFZj87GBD7nQEx8zHA9uB4nlzApDqs8YLLBZ0aFaxPigXHVzVX9l9Hgj2kBi2dAZ4PCOa_RP4KrlpQNyPs9cmaKlAx13hAzkjopOBlAzylXnGksMWvB6_3yzGZmr_SEWhVPopFNlrXdxv_2EjzA9iDIDJXiSSSB_ldZyYp_oNawSoEgT4UPk9L0_kaEgxrZnO--L-uuks4x5vw_XoTMrkiuURx-bqI2IY6w8ouh_2uAbwkVd2mxtEKVIkp22TlRWB2j3TQgiEPHbopgAHEV9yIp6tX7DrZn9M-uKjnlhedM8uHlv3jRDHZFRsrA9Fpt20IX7wW5ayXyIMEhsR3Mb9s7xJU00za_hKCpxEnjr1WK_IA1-Cu5pCwEY_93Ncvnfq-ymFjJs9XhGSl2LVS_NdmE7BzTujcFaS1j42XkiKA95G_uPfaLNqKN0Xm8DkkTt6yGWG55RwKFh9a5bj1gDU6RLyvbXcH6Sb-2NFu5AzJXrqiEAXkGxaQKhmIb_m2n_HmS3Akz0PKmzpS_SDXfWsVViSC2S-lCtMULzM2jmPsioCQMZiHE_Gy0"><p>最后，再安利一句，<strong>plantuml</strong>和<strong>hexo-tag-plantuml</strong>，你值得拥有。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;plantuml logo&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;PlantUML-简介&quot;&gt;&lt;a href=&quot;#PlantUML-简介&quot; class=&quot;headerlink&quot; title=&quot;PlantUML 简介&quot;&gt;&lt;/a&gt;PlantUML 简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://plantuml.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PlantUML&lt;/a&gt;是一个画图脚本语言，官方介绍如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Generate UML diagram from textual description&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="效率" scheme="http://tonydeng.github.io/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="plantuml" scheme="http://tonydeng.github.io/tags/plantuml/"/>
    
      <category term="hexo" scheme="http://tonydeng.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>机器学习常见算法分类汇总</title>
    <link href="http://tonydeng.github.io/2017/03/03/common-algorithms-for-machine-learning/"/>
    <id>http://tonydeng.github.io/2017/03/03/common-algorithms-for-machine-learning/</id>
    <published>2017-03-03T06:41:31.000Z</published>
    <updated>2019-06-20T12:10:27.477Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习无疑是当前数据分析领域的一个热点内容。很多人在平时的工作中都或多或少会用到机器学习的算法。本文为您总结一下常见的机器学习算法，以供您在工作和学习中参考。</p><p>机器学习的算法很多。很多时候困惑人们都是，很多算法是一类算法，而有些算法又是从其他算法中延伸出来的。这里，从两个方面来给大家介绍，第一个方面是学习的方式，第二个方面是算法的类似性。</p><a id="more"></a><h1 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h1><p>根据数据类型的不同，对一个问题的建模有不同的方式。在机器学习或者人工智能领域，人们首先会考虑算法的学习方式。在机器学习领域，有几种主要的学习方式。将算法按照学习方式分类是一个不错的想法，这样可以让人们在建模和算法选择的时候考虑能根据输入数据来选择最合适的算法来获得最好的结果。</p><h2 id="监督式学习："><a href="#监督式学习：" class="headerlink" title="监督式学习："></a>监督式学习：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b15.jpg" alt="监督式学习"></p><p>在监督式学习下，输入数据被称为“训练数据”，每组训练数据有一个明确的标识或结果，如对防垃圾邮件系统中“垃圾邮件”“非垃圾邮件”，对手写数字识别中的“1“，”2“，”3“，”4“等。在建立预测模型的时候，监督式学习建立一个学习过程，将预测结果与“训练数据”的实际结果进行比较，不断的调整预测模型，直到模型的预测结果达到一个预期的准确率。监督式学习的常见应用场景如分类问题和回归问题。常见算法有逻辑回归（Logistic Regression）和反向传递神经网络（Back Propagation Neural Network）</p><h2 id="非监督式学习："><a href="#非监督式学习：" class="headerlink" title="非监督式学习："></a>非监督式学习：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b2.png" alt="非监督式学习"></p><p>在非监督式学习中，数据并不被特别标识，学习模型是为了推断出数据的一些内在结构。常见的应用场景包括关联规则的学习以及聚类等。常见算法包括Apriori算法以及k-Means算法。</p><h2 id="半监督式学习："><a href="#半监督式学习：" class="headerlink" title="半监督式学习："></a>半监督式学习：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b3.png" alt="半监督式学习"></p><p>在此学习方式下，输入数据部分被标识，部分没有被标识，这种学习模型可以用来进行预测，但是模型首先需要学习数据的内在结构以便合理的组织数据来进行预测。应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，这些算法首先试图对未标识数据进行建模，在此基础上再对标识的数据进行预测。如图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM.）等。</p><h2 id="强化学习："><a href="#强化学习：" class="headerlink" title="强化学习："></a>强化学习：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b4.png" alt="强化学习"></p><p>在这种学习模式下，输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式，在强化学习下，输入数据直接反馈到模型，模型必须对此立刻作出调整。常见的应用场景包括动态系统以及机器人控制等。常见算法包括Q-Learning以及时间差学习（Temporal difference learning）</p><p>在企业数据应用的场景下， 人们最常用的可能就是监督式学习和非监督式学习的模型。 在图像识别等领域，由于存在大量的非标识的数据和少量的可标识数据， 目前半监督式学习是一个很热的话题。 而强化学习更多的应用在机器人控制及其他需要进行系统控制的领域。</p><h1 id="算法类似性"><a href="#算法类似性" class="headerlink" title="算法类似性"></a>算法类似性</h1><p>根据算法的功能和形式的类似性，我们可以把算法分类，比如说基于树的算法，基于神经网络的算法等等。当然，机器学习的范围非常庞大，有些算法很难明确归类到某一类。而对于有些分类来说，同一分类的算法可以针对不同类型的问题。这里，我们尽量把常用的算法按照最容易理解的方式进行分类。</p><h2 id="回归算法："><a href="#回归算法：" class="headerlink" title="回归算法："></a>回归算法：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b22.jpg" alt="回归算法"></p><p>回归算法是试图采用对误差的衡量来探索变量之间的关系的一类算法。回归算法是统计机器学习的利器。在机器学习领域，人们说起回归，有时候是指一类问题，有时候是指一类算法，这一点常常会使初学者有所困惑。常见的回归算法包括：最小二乘法（Ordinary Least Square），逻辑回归（Logistic Regression），逐步式回归（Stepwise Regression），多元自适应回归样条（Multivariate Adaptive Regression Splines）以及本地散点平滑估计（Locally Estimated Scatterplot Smoothing）</p><h2 id="基于实例的算法"><a href="#基于实例的算法" class="headerlink" title="基于实例的算法"></a>基于实例的算法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b33.jpg" alt="基于实例的算法"></p><p>基于实例的算法常常用来对决策问题建立模型，这样的模型常常先选取一批样本数据，然后根据某些近似性把新数据与样本数据进行比较。通过这种方式来寻找最佳的匹配。因此，基于实例的算法常常也被称为“赢家通吃”学习或者“基于记忆的学习”。常见的算法包括 k-Nearest Neighbor(KNN), 学习矢量量化（Learning Vector Quantization， LVQ），以及自组织映射算法（Self-Organizing Map ， SOM）</p><h2 id="正则化方法"><a href="#正则化方法" class="headerlink" title="正则化方法"></a>正则化方法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b11.png" alt="正则化方法"></p><p>正则化方法是其他算法（通常是回归算法）的延伸，根据算法的复杂度对算法进行调整。正则化方法通常对简单模型予以奖励而对复杂算法予以惩罚。常见的算法包括：Ridge Regression， Least Absolute Shrinkage and Selection Operator（LASSO），以及弹性网络（Elastic Net）。</p><h2 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b12.png" alt="决策树学习"></p><p>决策树算法根据数据的属性采用树状结构建立决策模型， 决策树模型常常用来解决分类和回归问题。常见的算法包括：分类及回归树（Classification And Regression Tree， CART）， ID3 (Iterative Dichotomiser 3)， C4.5， Chi-squared Automatic Interaction Detection(CHAID), Decision Stump, 随机森林（Random Forest）， 多元自适应回归样条（MARS）以及梯度推进机（Gradient Boosting Machine， GBM）</p><h2 id="贝叶斯方法"><a href="#贝叶斯方法" class="headerlink" title="贝叶斯方法"></a>贝叶斯方法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b131.jpg" alt="贝叶斯方法"></p><p>贝叶斯方法算法是基于贝叶斯定理的一类算法，主要用来解决分类和回归问题。常见算法包括：朴素贝叶斯算法，平均单依赖估计（Averaged One-Dependence Estimators， AODE），以及Bayesian Belief Network（BBN）。</p><h2 id="基于核的算法"><a href="#基于核的算法" class="headerlink" title="基于核的算法"></a>基于核的算法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b141.jpg" alt="基于核的算法"></p><p>基于核的算法中最著名的莫过于支持向量机（SVM）了。 基于核的算法把输入数据映射到一个高阶的向量空间， 在这些高阶向量空间里， 有些分类或者回归问题能够更容易的解决。 常见的基于核的算法包括：支持向量机（Support Vector Machine， SVM）， 径向基函数（Radial Basis Function ，RBF)， 以及线性判别分析（Linear Discriminate Analysis ，LDA)等</p><h2 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b14.png" alt="聚类算法"></p><p>聚类，就像回归一样，有时候人们描述的是一类问题，有时候描述的是一类算法。聚类算法通常按照中心点或者分层的方式对输入数据进行归并。所以的聚类算法都试图找到数据的内在结构，以便按照最大的共同点将数据进行归类。常见的聚类算法包括 k-Means算法以及期望最大化算法（Expectation Maximization， EM）。</p><h2 id="关联规则学习"><a href="#关联规则学习" class="headerlink" title="关联规则学习"></a>关联规则学习</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b151.jpg" alt="关联规则学习"></p><p>关联规则学习通过寻找最能够解释数据变量之间关系的规则，来找出大量多元数据集中有用的关联规则。常见算法包括 Apriori算法和Eclat算法等。</p><h2 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b16.png" alt="人工神经网络"></p><p>人工神经网络算法模拟生物神经网络，是一类模式匹配算法。通常用于解决分类和回归问题。人工神经网络是机器学习的一个庞大的分支，有几百种不同的算法。（其中深度学习就是其中的一类算法，我们会单独讨论），重要的人工神经网络算法包括：感知器神经网络（Perceptron Neural Network）, 反向传递（Back Propagation）， Hopfield网络，自组织映射（Self-Organizing Map, SOM）。学习矢量量化（Learning Vector Quantization， LVQ）</p><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b16.jpg" alt="深度学习"></p><p>深度学习算法是对人工神经网络的发展。 在近期赢得了很多关注， 特别是AlphaGO战胜李世石之后后， 更是在国内引起了很多关注。   在计算能力变得日益廉价的今天，深度学习试图建立大得多也复杂得多的神经网络。很多深度学习的算法是半监督式学习算法，用来处理存在少量未标识数据的大数据集。常见的深度学习算法包括：受限波尔兹曼机（Restricted Boltzmann Machine， RBN）， Deep Belief Networks（DBN），卷积网络（Convolutional Network）, 堆栈式自动编码器（Stacked Auto-encoders）。</p><h2 id="降低维度算法"><a href="#降低维度算法" class="headerlink" title="降低维度算法"></a>降低维度算法</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b17.jpg" alt="降低维度算法"></p><p>像聚类算法一样，降低维度算法试图分析数据的内在结构，不过降低维度算法是以非监督学习的方式试图利用较少的信息来归纳或者解释数据。这类算法可以用于高维数据的可视化或者用来简化数据以便监督式学习使用。常见的算法包括：主成份分析（Principle Component Analysis， PCA），偏最小二乘回归（Partial Least Square Regression，PLS）， Sammon映射，多维尺度（Multi-Dimensional Scaling, MDS）,  投影追踪（Projection Pursuit）等。</p><h2 id="集成算法："><a href="#集成算法：" class="headerlink" title="集成算法："></a>集成算法：</h2><p><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2014/09/b18.jpg" alt="集成算法"></p><p>集成算法用一些相对较弱的学习模型独立地就同样的样本进行训练，然后把结果整合起来进行整体预测。集成算法的主要难点在于究竟集成哪些独立的较弱的学习模型以及如何把学习结果整合起来。这是一类非常强大的算法，同时也非常流行。常见的算法包括：Boosting， Bootstrapped Aggregation（Bagging）， AdaBoost，堆叠泛化（Stacked Generalization， Blending），梯度推进机（Gradient Boosting Machine, GBM），随机森林（Random Forest）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习无疑是当前数据分析领域的一个热点内容。很多人在平时的工作中都或多或少会用到机器学习的算法。本文为您总结一下常见的机器学习算法，以供您在工作和学习中参考。&lt;/p&gt;
&lt;p&gt;机器学习的算法很多。很多时候困惑人们都是，很多算法是一类算法，而有些算法又是从其他算法中延伸出来的。这里，从两个方面来给大家介绍，第一个方面是学习的方式，第二个方面是算法的类似性。&lt;/p&gt;
    
    </summary>
    
      <category term="算法及实现" scheme="http://tonydeng.github.io/categories/%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="algorithms" scheme="http://tonydeng.github.io/tags/algorithms/"/>
    
      <category term="machine learning" scheme="http://tonydeng.github.io/tags/machine-learning/"/>
    
      <category term="机器学习算法" scheme="http://tonydeng.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python的JIT</title>
    <link href="http://tonydeng.github.io/2017/03/03/jit-in-python/"/>
    <id>http://tonydeng.github.io/2017/03/03/jit-in-python/</id>
    <published>2017-03-03T05:37:38.000Z</published>
    <updated>2019-06-20T12:10:27.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译型-or-解释型？"><a href="#编译型-or-解释型？" class="headerlink" title="编译型 or 解释型？"></a>编译型 or 解释型？</h2><p>玩过 <code>Python</code> 的同学应该都听过 <code>python</code> 是解释型语言，那么什么是解释型语言，其实在现代的编程语言中，关于解释型 和 编译型 的界限越来越模糊了，这里我根据我自己的理解下个定义：</p><ul><li>解释型：不能直接编译成可执行二进制程序的语言</li><li>编译型：可以直接编译成可执行二进制程序运行的语言</li></ul><p>根据这个定义的话，可以明确给出界定，<code>C/C++</code> 是 编译型 的，而 <code>Java</code> 则是 解释型 的，为什么我没说 <code>Python，因为</code> Python 我也不敢说它是哪种类型的。为什么？因为这要看你说的 <code>Python</code> 是什么？是说 <code>Python</code> 编程语言，还是 <code>CPython</code> 解释器。如果说的是 <code>CPython</code> 解释器，那么毫无疑问 <code>Python</code> 是解释型的；那如果说的是编程语言，那么还真无法界定，因为 <code>Python</code> 规范只定义了 <code>Python</code> 的语法规定，并没有规定要如何实现编译解析，所以无法确定。</p><a id="more"></a><p><img src="https://ooo.0o0.ooo/2017/02/04/58959aaa98af7.jpg" alt="python is a programming language"></p><p>那么是否就可以说解释型语言一无是处呢？那肯定不是的，存在即合理，虽然解释型语言的速度相比编译型会慢很多，但是解释型语言具有一些编译型无法比拟的优点：</p><ol><li>一次编译，处处执行(Java的最大卖点)</li><li>可以确保你看到的代码就是你执行的代码(python)</li><li>弱类型，开发速度很快</li></ol><h2 id="Python-执行过程"><a href="#Python-执行过程" class="headerlink" title="Python 执行过程"></a>Python 执行过程</h2><p>当然，这里扯那么多其实都不是关键，但是，关键是我这里的观点是 Python 是解释型的，而且我所说的 <code>Python</code> 是指 <code>CPython</code> 解释器器执行的 <code>Python</code> 语言代码。那么这里的问题就来了，<code>CPython</code> 解释器执行 <code>Python</code> 代码的时候是直接将原始的 <code>Python</code> 代码加载进行逐条执行么？可以说无论是 <code>Python2</code> 还是 <code>Python3</code> 都不是，原始的 <code>Python</code> 代码都会被编译成字节码，然后再执行。但是新版本的 <code>Python</code> 和旧版本的 <code>Python</code> 有一些不一样，旧版本的 <code>Python</code> 是在内存中编译成字节码，而新版本的 <code>Python</code> 则会编译成 <code>pyc</code> 文件，放置在源文件的目录。用一张图来表示就是这样的：</p><p><img src="https://ooo.0o0.ooo/2017/02/04/58959ffd5678f.png" alt="python build source code"></p><p>那么这里就有一个问题了，为什么不直接执行 <code>Python</code> 代码呢，而是要编译一遍转换成字节码？其实很多人也想得到，其实就想加快一下 <code>Python</code> 的执行速度，因为边执行边编译速度肯定比先编译好快的，尤其是 <code>CPU</code> 资源占用多的情况更是如此；同时，先编译的话我们可以有更好得优化空间，我们可以做一些更好得代码优化，例如这样的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">a = a + b</span><br></pre></td></tr></table></figure><p>如果一边编译一边执行，我们就需要执行 3 条语句了，如果我们预先编译的话，完全可以优化成这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = 3</span><br></pre></td></tr></table></figure><p>就是这么好的效果。随着人们的不断使用，人们觉得仅仅编译成字节码的速度不够快，因为毕竟不是机器码，于是就有人想把 <code>python</code> 从源码编译成二进制可执行程序的，不是没有，有！现在有很多工具可以将 Python 代码编译成可执行程序，例如：<code>Py2exe</code>、<code>Installer</code> 和 <code>freeze</code>。正如前面所说，编译成二进制代码是不错，但是缺抛弃了可迁移性，就不能一次编写，处处执行了。</p><p>##JIT(just-in-time)</p><p>为了兼具移植性和性能，聪明的工程师们发明了 <code>JIT</code> 这个东西，所谓的 <code>JIT</code> 就是说在解释型语言中，对于经常用到的或者说有较大性能提升的代码在解释的时候编译成机器码，其他一次性或者说没有太大性能提升的代码还是以字节码的方式执行。这样的话，就能在保证移植性的同时，又能让性能提升一大截，这里学问其实是很深的，因为我们怎么知道编译哪段代码能让我们的性能提升一大截呢？最简单的方式就是看循环，循环体中的代码都给他编译的，这样的话，大部分情况下我们的代码都是比原来高效的，但是，这也仅仅提高了循环的速度，还有其他很多代码有提升的可能，关于这个问题，这里也无法详说，有兴趣的同学可以自行搜索学习。</p><p>继续以 Python 为例介绍一下 <code>Python</code> 中的 <code>JIT</code>，在 <code>CPython</code> 中是没有 <code>JIT</code> 这个功能的，但是，有一个扩展模块 <code>Psyco</code> 可以实现这个功能；除此之外，其他的 <code>python</code> 解释器实现自带 <code>JIT</code>，例如 <code>pypy</code>。这里也不讨论如何使用 <code>Psyco</code> 加速 <code>Python</code> 代码了，有兴趣的同学可以看下 <a href="https://www.ibm.com/developerworks/library/l-psyco/" target="_blank" rel="noopener">Charming Python: Make Python run as fast as C with Psyco</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文从简单的介绍 <code>Python</code> 代码的执行过程出发，探讨了一下解释型和编译型程序的区别，然后引出 JIT 的必要性和强大。然而在生产中 <code>JIT</code> 并不会太多用到，因为目前 <code>Python</code> 还未被大规模应用于高并发的互联网应用中，或者说是性能要求高的场景。然而当真的需要面对这些场景的时候，难道直接编译 <code>Python</code> 代码不会是更好的选择？</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/" target="_blank" rel="noopener">深入浅出 JIT 编译器（java）</a><br><a href="http://www.devshed.com/c/a/python/how-python-runs-programs/" target="_blank" rel="noopener">How Python Runs Programs</a><br><a href="http://stackoverflow.com/questions/2998215/if-python-is-interpreted-what-are-pyc-files" target="_blank" rel="noopener">If Python is interpreted, what are .pyc files?</a><br><a href="https://www.ibm.com/developerworks/library/l-psyco/" target="_blank" rel="noopener">Charming Python: Make Python run as fast as C with Psyco</a><br><a href="http://www.cnblogs.com/kym/archive/2012/05/14/2498728.html" target="_blank" rel="noopener">说说Python程序的执行过程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译型-or-解释型？&quot;&gt;&lt;a href=&quot;#编译型-or-解释型？&quot; class=&quot;headerlink&quot; title=&quot;编译型 or 解释型？&quot;&gt;&lt;/a&gt;编译型 or 解释型？&lt;/h2&gt;&lt;p&gt;玩过 &lt;code&gt;Python&lt;/code&gt; 的同学应该都听过 &lt;code&gt;python&lt;/code&gt; 是解释型语言，那么什么是解释型语言，其实在现代的编程语言中，关于解释型 和 编译型 的界限越来越模糊了，这里我根据我自己的理解下个定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解释型：不能直接编译成可执行二进制程序的语言&lt;/li&gt;
&lt;li&gt;编译型：可以直接编译成可执行二进制程序运行的语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据这个定义的话，可以明确给出界定，&lt;code&gt;C/C++&lt;/code&gt; 是 编译型 的，而 &lt;code&gt;Java&lt;/code&gt; 则是 解释型 的，为什么我没说 &lt;code&gt;Python，因为&lt;/code&gt; Python 我也不敢说它是哪种类型的。为什么？因为这要看你说的 &lt;code&gt;Python&lt;/code&gt; 是什么？是说 &lt;code&gt;Python&lt;/code&gt; 编程语言，还是 &lt;code&gt;CPython&lt;/code&gt; 解释器。如果说的是 &lt;code&gt;CPython&lt;/code&gt; 解释器，那么毫无疑问 &lt;code&gt;Python&lt;/code&gt; 是解释型的；那如果说的是编程语言，那么还真无法界定，因为 &lt;code&gt;Python&lt;/code&gt; 规范只定义了 &lt;code&gt;Python&lt;/code&gt; 的语法规定，并没有规定要如何实现编译解析，所以无法确定。&lt;/p&gt;
    
    </summary>
    
      <category term="性能" scheme="http://tonydeng.github.io/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="python" scheme="http://tonydeng.github.io/tags/python/"/>
    
      <category term="JIT" scheme="http://tonydeng.github.io/tags/JIT/"/>
    
  </entry>
  
  <entry>
    <title>协同过滤实现及算法</title>
    <link href="http://tonydeng.github.io/2017/01/01/implementation-and-algorithm-of-collaborative-filtering/"/>
    <id>http://tonydeng.github.io/2017/01/01/implementation-and-algorithm-of-collaborative-filtering/</id>
    <published>2017-01-01T02:51:08.000Z</published>
    <updated>2019-06-20T12:10:27.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文来自团队中学科同学的分享</p></blockquote><p><img src="/images/blog/recomm.jpg" alt="recommend"></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>根据用户行为分析用户偏好，将不同偏好的用户进行群组划分和“商品”推荐<br>常见于网上购物，点评，游戏市场等</p><h3 id="SPARK实现"><a href="#SPARK实现" class="headerlink" title="SPARK实现"></a>SPARK实现</h3><ul><li><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><em>步骤</em></h4></li></ul><ol><li>读取原始数据</li><li>格式化成RDD数据：用户，产品，评分</li><li>矩阵SVD分解</li><li>计算用户相似度</li><li>根据加权评分计算推荐结果</li></ol><a id="more"></a><ul><li><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><em>代码</em></h3><p>读取文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(sparkConf);</span><br><span class="line">JavaRDD&lt;String&gt; lines = sc.textFile(<span class="string">"..."</span>);</span><br></pre></td></tr></table></figure><p>格式化数据</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JavaRDD&lt;Vector&gt; simple = lines.map(line -&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> Vectors.dense(values);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SVD分解</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RowMatrix mat = <span class="keyword">new</span> RowMatrix(simple.rdd());</span><br><span class="line">SingularValueDecomposition&lt;RowMatrix, Matrix&gt; svd = mat.computeSVD(<span class="number">2</span>, <span class="keyword">true</span>, <span class="number">1.0E-9</span>d);</span><br></pre></td></tr></table></figure><p>计算用户相似度</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dist =  Vectors.sqdist(v1._1.vector(), v1._2.vector());</span><br></pre></td></tr></table></figure></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><hr><ul><li><h4 id="构建用户评分矩阵"><a href="#构建用户评分矩阵" class="headerlink" title="构建用户评分矩阵"></a><em>构建用户评分矩阵</em></h4></li></ul><table><thead><tr><th>Table</th><th>小时代1</th><th>小时代2</th><th>小时代3</th><th>小时代4</th><th>…</th><th>疾病N</th></tr></thead><tbody><tr><td>用户1</td><td>5</td><td>0</td><td>5</td><td>0</td><td></td><td></td></tr><tr><td>用户2</td><td>5</td><td>2</td><td>4</td><td>0</td><td></td><td></td></tr><tr><td>用户3</td><td>3</td><td>1</td><td>3</td><td>0</td><td></td><td></td></tr><tr><td>用户4</td><td>1</td><td>5</td><td>1</td><td>4</td><td></td><td></td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>患者N</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li><h4 id="SVD分解（Singular-value-decomposition）"><a href="#SVD分解（Singular-value-decomposition）" class="headerlink" title="SVD分解（Singular value decomposition）"></a><em>SVD分解（Singular value decomposition）</em></h4></li></ul><p><img src="data:image/png;base64,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" alt></p><ul><li><h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a><em>几何意义</em></h4>  <img src="http://img.blog.csdn.net/20140524002918937" alt></li></ul><ul><li><h4 id="降维原理"><a href="#降维原理" class="headerlink" title="降维原理"></a><em>降维原理</em></h4><p>  <img src="http://img.blog.csdn.net/20160730135911445" alt></p><p>  分解后，U、V是正交矩阵，∑是对角矩阵</p><p>  <img src="http://img.blog.csdn.net/20160730141314586" alt></p><p>  舍弃不重要的特征向量，把数据集映射到低维空间中去，构建近似矩阵，达到降维的目的</p></li><li><h4 id="SVD的作用"><a href="#SVD的作用" class="headerlink" title="SVD的作用"></a><em>SVD的作用</em></h4><p> 将高维空间数据投影至低维空间，提炼出主要特征维度</p><p> 维度的降低极大的减少计算量</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来自团队中学科同学的分享&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/recomm.jpg&quot; alt=&quot;recommend&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;根据用户行为分析用户偏好，将不同偏好的用户进行群组划分和“商品”推荐&lt;br&gt;常见于网上购物，点评，游戏市场等&lt;/p&gt;
&lt;h3 id=&quot;SPARK实现&quot;&gt;&lt;a href=&quot;#SPARK实现&quot; class=&quot;headerlink&quot; title=&quot;SPARK实现&quot;&gt;&lt;/a&gt;SPARK实现&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;&lt;em&gt;步骤&lt;/em&gt;&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;读取原始数据&lt;/li&gt;
&lt;li&gt;格式化成RDD数据：用户，产品，评分&lt;/li&gt;
&lt;li&gt;矩阵SVD分解&lt;/li&gt;
&lt;li&gt;计算用户相似度&lt;/li&gt;
&lt;li&gt;根据加权评分计算推荐结果&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法及实现" scheme="http://tonydeng.github.io/categories/%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="sprak" scheme="http://tonydeng.github.io/tags/sprak/"/>
    
      <category term="协同过滤" scheme="http://tonydeng.github.io/tags/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>etcd4j阻塞排查和解除过程</title>
    <link href="http://tonydeng.github.io/2016/11/03/etcd4j-blocking-investigation-and-lifting-process/"/>
    <id>http://tonydeng.github.io/2016/11/03/etcd4j-blocking-investigation-and-lifting-process/</id>
    <published>2016-11-03T05:19:42.000Z</published>
    <updated>2019-06-20T12:10:27.477Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog/etcd4j/debug.jpg" alt="debug"></p><h2 id="先说一下背景"><a href="#先说一下背景" class="headerlink" title="先说一下背景"></a>先说一下背景</h2><p>最近将整个微服务的体系从原来的通过使用<a href="https://github.com/tonydeng/tcp4j" target="_blank" rel="noopener">TCP4J</a>加上固定的<code>HOST+PORT</code>的方式转成使用<a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">ETCD</a>的服务发现体系（大家想了解ETCD可以关注我之前的两篇博文<a href="/2015/11/24/etcd-the-first-using/">初试ETCD</a>,<a href="/2015/10/19/etcd-application-scenarios/">ETCD应用场景 </a>）。</p><a id="more"></a><h3 id="基于ETCD的注册-amp-服务发现架构"><a href="#基于ETCD的注册-amp-服务发现架构" class="headerlink" title="基于ETCD的注册 &amp; 服务发现架构"></a>基于ETCD的注册 &amp; 服务发现架构</h3><p><img src="/images/blog/etcd4j/etcd-registry.png" alt="etcd registry"></p><ol><li>etcd registry 做为服务中心，提供注册与服务发现。</li><li>资源服务在准备完毕之后将服务实例注册到服务中心。</li><li>客户端到服务注册中心根据服务名称获取资源服务的地址。</li><li>客户端获取资源服务的地址后，调用资源服务。</li><li>资源服务在关闭时需要将服务实例在服务中心进行注销操作。</li></ol><p>我们使用<a href="https://github.com/jurmous/etcd4j" target="_blank" rel="noopener">etcd4j</a>这个etcd的java client实现，在使用的过程中，etcd4j-client会首先去请求一下etcd server，看看当前etcd server的版本是多少。</p><p>比如这样：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">http <span class="string">http:</span><span class="comment">//etcd.dev.cim.in:2379/version</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-<span class="string">Length:</span> <span class="number">44</span></span><br><span class="line">Content-<span class="string">Type:</span> application/json</span><br><span class="line"><span class="string">Date:</span> Wed, <span class="number">02</span> Nov <span class="number">2016</span> <span class="number">08</span>:<span class="number">21</span>:<span class="number">34</span> GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"etcdcluster"</span>: <span class="string">"2.3.0"</span>,</span><br><span class="line">   <span class="string">"etcdserver"</span>: <span class="string">"2.3.7"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看看问题"><a href="#看看问题" class="headerlink" title="看看问题"></a>看看问题</h2><p>看起来貌似很简单的情况，但是在改造某个项目的时候，在这个简单的场景下，出现了一个问题，让@webwyz同学头疼了一下午。</p><p>在启动项目时，就停在get version这儿死活过不去了。</p><p>日志如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">06</span> DEBUG m.etcd4j.transport.EtcdNettyClient - Connected to etcd.dev.cim.in/<span class="number">192.168</span>.1.86:<span class="number">2379</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">06</span> DEBUG i.n.u.i.JavassistTypeParameterMatcherGenerator - Generated: io.netty.util.internal.__matchers__.io.netty.handler.codec.http.FullHttpResponseMatcher</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">07</span> DEBUG m.e.transport.EtcdResponseHandler - Received <span class="number">200</span> <span class="keyword">for</span> GET /version</span><br></pre></td></tr></table></figure><p>正确的启动日志应该如此：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> DEBUG m.etcd4j.transport.EtcdNettyClient - Connected to etcd.dev.cim.in/<span class="number">192.168</span>.1.86:<span class="number">2379</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> DEBUG m.e.transport.EtcdResponseHandler - Received <span class="number">200</span> <span class="keyword">for</span> GET /version</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> DEBUG m.etcd4j.transport.EtcdNettyClient - Connection closed <span class="keyword">for</span> request GET on uri /version</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> INFO  c.c.a.k.etcd.EtcdAutoConfiguration - etcd version is <span class="number">2.3</span>.0 , urls are [ http:<span class="comment">//etcd.dev.cim.in:2379 ]</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><h2 id="排查异常"><a href="#排查异常" class="headerlink" title="排查异常"></a>排查异常</h2><h3 id="是否是网络连接问题？"><a href="#是否是网络连接问题？" class="headerlink" title="是否是网络连接问题？"></a>是否是网络连接问题？</h3><p>当时我查看网络状况，网络连接也是正常的。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">lsof -nP -iTCP:2379</span><br><span class="line">COMMAND   PID    <span class="built_in"> USER </span>  FD  <span class="built_in"> TYPE </span>            DEVICE SIZE/OFF NODE NAME</span><br><span class="line">java     7142 tonydeng  317u <span class="built_in"> IPv6 </span>0x235c7b856fde6855      0t0  TCP 192.168.2.231:50774-&gt;192.168.1.86:2379 (ESTABLISHED)</span><br><span class="line">java    12179 tonydeng  293u <span class="built_in"> IPv6 </span>0x235c7b857295c315      0t0  TCP 192.168.2.231:52504-&gt;192.168.1.86:2379 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>甚至通过tcpdump来进行抓包也没有发现什么问题。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo tcpdump host 192.168.2.231 <span class="keyword">and</span> 192.168.1.86 <span class="keyword">and</span> tcp<span class="built_in"> port </span>2379 -vv</span><br></pre></td></tr></table></figure><p>看来不是在网络层面的问题。</p><h3 id="追追代码"><a href="#追追代码" class="headerlink" title="追追代码"></a>追追代码</h3><p>从日志上看，最后的输出应该是<a href="https://github.com/jurmous/etcd4j/blob/release-2.12.0/src/main/java/mousio/etcd4j/transport/EtcdResponseHandler.java#L100" target="_blank" rel="noopener">mousio.etcd4j.transport.EtcdResponseHandler</a>，先看看这个类的代码(有兴趣的同学，可以在Github上查看<a href="https://github.com/jurmous/etcd4j/blob/release-2.12.0/src/main/java/mousio/etcd4j/transport/EtcdResponseHandler.java" target="_blank" rel="noopener">相关代码</a>，就不列出所有代码了)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Received &#123;&#125; for &#123;&#125; &#123;&#125;"</span>, <span class="keyword">new</span> Object[]&#123;Integer.valueOf(status.code()), <span class="keyword">this</span>.request.getMethod().name(), <span class="keyword">this</span>.request.getUri()&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!status.equals(HttpResponseStatus.MOVED_PERMANENTLY) &amp;&amp; !status.equals(HttpResponseStatus.TEMPORARY_REDIRECT)) &#123;</span><br><span class="line">    EtcdResponseDecoder failureDecoder = (EtcdResponseDecoder)failureDecoders.get(status);</span><br><span class="line">    <span class="keyword">if</span>(failureDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.promise.setFailure((Throwable)failureDecoder.decode(headers, content));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!content.isReadable()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!status.equals(HttpResponseStatus.OK) &amp;&amp; !status.equals(HttpResponseStatus.ACCEPTED) &amp;&amp; !status.equals(HttpResponseStatus.CREATED)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.promise.setFailure(<span class="keyword">new</span> IOException(<span class="string">"Content was not readable. HTTP Status: "</span> + status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.promise.setSuccess(<span class="keyword">this</span>.request.getResponseDecoder().decode(headers, content));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">            <span class="keyword">if</span>(var10 <span class="keyword">instanceof</span> EtcdException) &#123;</span><br><span class="line">                <span class="keyword">this</span>.promise.setFailure(var10);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.promise.setFailure((Throwable)EtcdException.DECODER.decode(headers, content));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.promise.setFailure(var10);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码上看，应该是阻塞在<code>decode</code>过程中了（如果大家看到上面的代码和github上不一样，请不要奇怪，这个是用过java工具反编译出来的）。</p><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(failureDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.promise.setFailure((Throwable)failureDecoder.decode(headers, content));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是这样，那应该是在进行version信息的序列化时出现的问题，看看etcd4j使用的json序列化包是什么？</p><p>通过<code>mvn dependency:tree</code>命令查看，这里果然有问题。</p><p>正常启动项目的jackson相关的依赖及版本</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[INFO]</span> |  |  |  \<span class="selector-tag">-</span> <span class="selector-tag">org</span><span class="selector-class">.mousio</span><span class="selector-pseudo">:etcd4j</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.12.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-core</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-databind</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-annotations</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     \<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.module</span><span class="selector-pseudo">:jackson-module-afterburner</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br></pre></td></tr></table></figure><p>异常启动项目的jackson相关的依赖及版本</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[INFO]</span> +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-databind</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.7.4</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-annotations</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.7.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  \<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-core</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.7.4</span><span class="selector-pseudo">:compile</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |  \<span class="selector-tag">-</span> <span class="selector-tag">org</span><span class="selector-class">.mousio</span><span class="selector-pseudo">:etcd4j</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.12.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     \<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.module</span><span class="selector-pseudo">:jackson-module-afterburner</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br></pre></td></tr></table></figure><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>既然知道，这儿有问题，那就简单了，在启动异常的项目中去掉不一致的jackson依赖，一切问题就都解决了。</p><blockquote><p>etcd4j项目中也有人提到类似的问题<a href="https://github.com/jurmous/etcd4j/issues/116" target="_blank" rel="noopener">i update version to 2.12.0 my programmer has been blocked #116</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog/etcd4j/debug.jpg&quot; alt=&quot;debug&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;先说一下背景&quot;&gt;&lt;a href=&quot;#先说一下背景&quot; class=&quot;headerlink&quot; title=&quot;先说一下背景&quot;&gt;&lt;/a&gt;先说一下背景&lt;/h2&gt;&lt;p&gt;最近将整个微服务的体系从原来的通过使用&lt;a href=&quot;https://github.com/tonydeng/tcp4j&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCP4J&lt;/a&gt;加上固定的&lt;code&gt;HOST+PORT&lt;/code&gt;的方式转成使用&lt;a href=&quot;https://github.com/coreos/etcd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ETCD&lt;/a&gt;的服务发现体系（大家想了解ETCD可以关注我之前的两篇博文&lt;a href=&quot;/2015/11/24/etcd-the-first-using/&quot;&gt;初试ETCD&lt;/a&gt;,&lt;a href=&quot;/2015/10/19/etcd-application-scenarios/&quot;&gt;ETCD应用场景 &lt;/a&gt;）。&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://tonydeng.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="http://tonydeng.github.io/tags/java/"/>
    
      <category term="etcd" scheme="http://tonydeng.github.io/tags/etcd/"/>
    
      <category term="etcd4j" scheme="http://tonydeng.github.io/tags/etcd4j/"/>
    
  </entry>
  
  <entry>
    <title>为ZSH实现Fish Shell的效果</title>
    <link href="http://tonydeng.github.io/2016/08/05/zsh-plugins-like-fish-shell/"/>
    <id>http://tonydeng.github.io/2016/08/05/zsh-plugins-like-fish-shell/</id>
    <published>2016-08-05T06:26:00.000Z</published>
    <updated>2019-06-20T12:10:27.477Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog/zsh-like-fish-shell/fish-shell.jpg" alt></p><p>很久之前就见过同事用过<a href="https://fishshell.com" target="_blank" rel="noopener"><code>Fish Shell</code></a>，看到几个非常棒的特性和效果，比如下面两个特性就非常吸引我。</p><a id="more"></a><h2 id="Fish-Shell的炫酷"><a href="#Fish-Shell的炫酷" class="headerlink" title="Fish Shell的炫酷"></a>Fish Shell的炫酷</h2><p><img src="https://fishshell.com/assets/img/screenshots/autosuggestion.png" alt="智能提示"></p><p><img src="https://fishshell.com/assets/img/screenshots/colors.png" alt="语法高亮"></p><p><code>Fish Shell</code>的<strong>智能提示</strong>和<strong>语法高亮</strong>，是我觉得非常酷炫的功能，让我眼馋，为此我也试用过多次<code>Fish Shell</code>，但是每次都坚持不了多久，因为还是有很多地方不习惯：</p><ul><li>无插件系统，功能上还是比<a href="http://ohmyz.sh/" target="_blank" rel="noopener"><code>Oh My ZSH</code></a>少了很多</li><li>不兼容<code>bash</code>语法，导致我之前的很多脚本无法运行</li></ul><blockquote><p><a href="http://ohmyz.sh/" target="_blank" rel="noopener"><code>Oh My ZSH</code></a>才是我的真爱！</p></blockquote><h2 id="Oh-My-ZSH"><a href="#Oh-My-ZSH" class="headerlink" title="Oh My ZSH"></a>Oh My ZSH</h2><p>那么问题来了，<code>oh-my-zsh</code>中有没有插件可以实现类似的功能？</p><p>我先是在oh-my-zsh官方插件库里找了一下，但是没找到，后来发现了这样一个项目：</p><blockquote><p>zsh-users</p></blockquote><p>上面的介绍说是：<code>Zsh community projects</code>，感觉是非官方的项目。</p><p>里面有两个插件：</p><ol><li><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh-autosuggestions</a></li><li><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a></li></ol><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>这两个插件安装起来非常简单。</p><p>创建一个目录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.zsh/plugins</span><br></pre></td></tr></table></figure><p>clone这两个项目到刚刚创建的目录下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/zsh-users/zsh-autosuggestions.git ~/.zsh/plugins/zsh-autosuggestions</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:zsh-users/zsh-syntax-highlighting.git ~/.zsh/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>设置<code>.zshrc</code>中的<code>$ZSH_CUTOM</code>变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Would you like to use another custom folder than $ZSH/custom?</span></span><br><span class="line"><span class="comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span><br><span class="line">ZSH_CUSTOM=~/.zsh</span><br></pre></td></tr></table></figure><p>添加插件配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(zsh-autosuggestions zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure><p>最终效果图如下：</p><p><img src="/images/blog/zsh-like-fish-shell/autosuggestions.png" alt="autosuggestions"></p><p>途中可以看到git是绿色的，代表存在这个命令，如果打错了，它就是红色的：</p><p><img src="/images/blog/zsh-like-fish-shell/color.png" alt="color"></p><p>一目了然，不用等出错了再去修正错误了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog/zsh-like-fish-shell/fish-shell.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;很久之前就见过同事用过&lt;a href=&quot;https://fishshell.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Fish Shell&lt;/code&gt;&lt;/a&gt;，看到几个非常棒的特性和效果，比如下面两个特性就非常吸引我。&lt;/p&gt;
    
    </summary>
    
      <category term="效率" scheme="http://tonydeng.github.io/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="zsh" scheme="http://tonydeng.github.io/tags/zsh/"/>
    
      <category term="autosuggestions" scheme="http://tonydeng.github.io/tags/autosuggestions/"/>
    
      <category term="color" scheme="http://tonydeng.github.io/tags/color/"/>
    
  </entry>
  
  <entry>
    <title>利用Tesseract图片文字识别初探</title>
    <link href="http://tonydeng.github.io/2016/07/28/on-the-use-of-tesseract-picture-text-recognition/"/>
    <id>http://tonydeng.github.io/2016/07/28/on-the-use-of-tesseract-picture-text-recognition/</id>
    <published>2016-07-28T00:58:19.000Z</published>
    <updated>2019-06-20T12:10:27.476Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog/tesseract-to-pages.png" alt="tesseract-to-pages"></p><p>一直以来都想尝试一下图片的中文识别，直到最近才有点空闲时间，主要目的是证实一下到底可不可行，正确率能否达到 95% 以上。自己从头写起十分费时间，因为图片处理很麻烦，所以我选用了<code>Tesseract OCR</code>。</p><p>所谓 <code>OCR</code>(Optical Character Recognition)是指对文本资料进行扫描，然后对图像文件进行分析处理，获取文字和版面信息的过程。<code>OCR</code>是图像识别领域中的一个子领域，该领域专注于对图片中的文字信息进行识别并转换成能被常规文本编辑器编辑的文本。</p><a id="more"></a><h2 id="Tesseract介绍"><a href="#Tesseract介绍" class="headerlink" title="Tesseract介绍"></a>Tesseract介绍</h2><p><code>Tesseract</code>(/‘tesərækt/) 这个词的意思是”超立方体”，指的是几何学里的四维标准方体，又称”正八胞体”，是一款被广泛使用的开源 <code>OCR</code> 工具。</p><p><img src="http://linusp.github.io/assets/img/tesseract.gif" alt="tesseract"></p><p><code>Tesseract</code> 已经有 30 年历史，开始它是惠普实验室于1985年开始研发的一款专利软件，到1995年一件成为OCR业界内最准确的识别引擎之一。然而，HP不久便决定放弃OCR业务，<code>Tesseract</code>从此尘封。数年之后，HP意识到与其将Tesseract束之高阁，还不如贡献给开源，让其重焕新生。在 2005 年，<code>Tesseract</code>由美国内华达州信息技术研究所获得，并求助于<code>Google</code>对<code>Tesseract</code>进行改进、消除Bug、优化工作，并开源，其后一直由 <code>Google</code> 赞助进行后续的开发和维护。因为其免费与较好的效果，许多的个人开发者以及一些较小的团队在使用着 <code>Tesseract</code> ，诸如验证码识别、车牌号识别等应用中，不难见到 <code>Tesseract</code> 的身影。</p><p>现在<code>Tesseract</code>托管在<code>Github</code>上，大家有兴趣可以上<code>Github</code>上<code>Star</code>或<code>Frok</code><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">该项目</a>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Mac-OSX"><a href="#Mac-OSX" class="headerlink" title="Mac OSX"></a>Mac OSX</h3><p>在<code>Mac</code>上安装<code>Tesseract</code>是一件非常简单的事情，我们还是使用<code>brew</code>来进行安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install tesseract</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ tesseract --version</span><br><span class="line">tesseract 3.04.01</span><br><span class="line"> leptonica-1.73</span><br><span class="line">  libjpeg 8d : libpng 1.6.23 : libtiff 4.0.6 : zlib 1.2.5</span><br></pre></td></tr></table></figure><p>不过，如果你只是用上述命令来安装Tesseract的话，就会发现，只支持英文，因为它只默认安装了<code>eng</code>的语言包。如果我们需要识别其他的语言该如何来办呢？</p><p>安装指定的语言包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew intsall tesseract</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/Cellar/tesseract/&#123;version&#125;/share/tessdata</span><br><span class="line">wget https://github.com/tesseract-ocr/tessdata/raw/master/chi_sim.traineddata</span><br></pre></td></tr></table></figure><p>使用<code>brew</code>安装所有语言包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install tesseract --all-languages</span><br></pre></td></tr></table></figure><h3 id="其他平台安装"><a href="#其他平台安装" class="headerlink" title="其他平台安装"></a>其他平台安装</h3><p>更多Tesseract的安装可以查看这儿<a href="https://github.com/tesseract-ocr/tesseract/wiki" target="_blank" rel="noopener">Install Tesseract via pre-built binary package</a>或 <a href="https://github.com/tesseract-ocr/tesseract/wiki/Compiling" target="_blank" rel="noopener">build it from source</a></p><h2 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h2><p>这里只见到讲一下Tesseract识别图像的基本用法，关于训练和开发将来在另开新篇来专门讲述。</p><p>由于Tesseract只提供命令行工具，这里讲的用法对于Linux和Windows平台都适用。</p><p>首先可以通过<code>&quot;--list-langs&quot;</code>来查看哪些可用的“语言”，如果之前的<code>TESSDATA_PREFIX</code>环境变量没有设置错误，将看到这样的输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~tesseract --list-langs</span><br><span class="line">List of available languages (107):</span><br><span class="line">afr</span><br><span class="line">amh</span><br><span class="line">ara</span><br><span class="line">asm</span><br><span class="line">aze</span><br><span class="line">aze_cyrl</span><br><span class="line">bel</span><br><span class="line">ben</span><br><span class="line">bod</span><br><span class="line">bos</span><br><span class="line">bul</span><br><span class="line">cat</span><br><span class="line">ceb</span><br><span class="line">ces</span><br><span class="line">chi_sim</span><br><span class="line">chi_tra</span><br><span class="line">chr</span><br><span class="line">cym</span><br><span class="line">dan</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>大家可以看到，我安装了107个语言包，其中,<code>eng</code>和<code>chi_sim</code>是<code>Tesseract</code>提供的英文和简体中文的语言文件。</p><p>另外，要说明的是，这里的 “语言文件” 的本质是包含了某种 “自然语言” 的文字的特征等辅助识别的一些资源，但像 <code>chi_sim</code> 这个中文简体里也包含了英文字母与阿拉伯数字的资源。而我们也可以为了特定的用途而去训练产生对应的资源，并且可以给这个资源自定义一个名字。</p><p>如果发现以上命令的输出为空，那应该去检查一下 <code>TESSDATA_PREFIX</code> 这个环境变量。在这个环境变量无误且 “语言文件” 存在的情况下，假设我们有一张名为 <code>paper.png</code> 的图片，则通过以下命令对图片进行识别，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper -l chi_sim</span><br></pre></td></tr></table></figure><ol><li>第一个参数是待识别的图像的文件名</li><li>第二个参数用于指定输出，如果希望直接输出而不是保存到文件，那么就使用 <code>stdout</code>，否则这个参数将会作为保存结果的文件的前缀</li><li>-l <code>chi_sim</code> 这个应该很好理解，就是用来指定使用哪个 “语言文件”，如果是使用 英文(<code>eng</code>) ，这个参数可以不加，因为默认就是使用英文的 “语言文件” 来进行识别</li></ol><blockquote><p>以上命令如不出错，结果将会保存到 paper.txt 这个文本文件中。</p></blockquote><p>此外 <code>Tesseract</code> 还提供非常丰富的可选参数来对识别过程进行调整，可用的参数及其默认值可以通过以下命令进行查看:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract --<span class="built_in">print</span>-parameters</span><br></pre></td></tr></table></figure><p>参数的使用有两种:</p><ul><li>使用 -c 选项来设定单项参数的值，比如:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper -l chi_sim -c language_model_ngram_on=1</span><br></pre></td></tr></table></figure><p>允许使用多个 -c 选项来设置多个参数的值。</p><ul><li>将多项参数设置写入文件，然后在识别时使用该文件，比如:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper -l chi_sim tess.conf</span><br></pre></td></tr></table></figure><p>需要注意的是，如果使用配置文件，用作参数的配置文件名要放在最后面——这里也支持多个配置文件，但它们必须要在最后面。假如我有两个配置文件 tess_1.conf 和 tess_2.conf，那么这样是正确的:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper -l chi_sim tess_1.conf tess_2.conf</span><br></pre></td></tr></table></figure><p>而这样则是错误的:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper tess_1.conf -l chi_sim tess_2.conf</span><br></pre></td></tr></table></figure><p>至于 <code>Tesseract</code> 那些参数各有什么含义，官方没有提供任何文档来进行解释，这里有一个<a href="http://www.sk-spell.sk.cx/tesseract-ocr-parameters-in-302-version" target="_blank" rel="noopener">链接</a>提供了部分参数的用处说明，应该是阅读了 <code>Tesseract</code> 源代码后得到的结论。</p><h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>关于<code>Tesseract</code>的文档，可以查看<a href="http://tesseract-ocr.github.io/index.html" target="_blank" rel="noopener">Tetesseract官方Blog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog/tesseract-to-pages.png&quot; alt=&quot;tesseract-to-pages&quot;&gt;&lt;/p&gt;
&lt;p&gt;一直以来都想尝试一下图片的中文识别，直到最近才有点空闲时间，主要目的是证实一下到底可不可行，正确率能否达到 95% 以上。自己从头写起十分费时间，因为图片处理很麻烦，所以我选用了&lt;code&gt;Tesseract OCR&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所谓 &lt;code&gt;OCR&lt;/code&gt;(Optical Character Recognition)是指对文本资料进行扫描，然后对图像文件进行分析处理，获取文字和版面信息的过程。&lt;code&gt;OCR&lt;/code&gt;是图像识别领域中的一个子领域，该领域专注于对图片中的文字信息进行识别并转换成能被常规文本编辑器编辑的文本。&lt;/p&gt;
    
    </summary>
    
      <category term="效率" scheme="http://tonydeng.github.io/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="tesseact" scheme="http://tonydeng.github.io/tags/tesseact/"/>
    
  </entry>
  
  <entry>
    <title>看看程序猿是如何来下载和处理视频</title>
    <link href="http://tonydeng.github.io/2016/07/19/how-the-program-ape-is-coming-to-download-and-process-video/"/>
    <id>http://tonydeng.github.io/2016/07/19/how-the-program-ape-is-coming-to-download-and-process-video/</id>
    <published>2016-07-19T08:14:58.000Z</published>
    <updated>2019-06-20T12:10:27.476Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog/ffmpeg-youtube-dl.png" alt="FFMpeg and Youtube-dl"></p><p>我们经常在各大视频网站上看到一些很不错的视频，希望能够下载收藏起来，但是无法在网站上找到下载的按钮或者入口，很是郁闷。</p><p>那么来看看程序猿是如何来下载和处理视频的。</p><a id="more"></a><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>今天我看到了一个英国拍的工程师吐槽的视频，准备下载拿来做分享的素材。但是你如果在优酷上遍寻不到可以直接下载的链接，只有使用优酷的客户端才能给下载。</p><p>对于程序猿来说，这个事情实在是太让人不爽了，那我们该怎么办？</p><h3 id="YouTube-DL"><a href="#YouTube-DL" class="headerlink" title="YouTube-DL"></a>YouTube-DL</h3><p>那就该视频下载神器<code>youtube-dl</code>入场。别看名字和youtube相关，其实它支持大部分的视频网站。比如，我们现在要下载视频的优酷。</p><p>我们来试试<code>youtube-dl</code>的使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ youtube-dl http://v.youku.com/v_show/id_XNzE1NTk3Mzky.html</span><br><span class="line"></span><br><span class="line">[youku] XNzE1NTk3Mzky: Downloading JSON metadata</span><br><span class="line">[download] Downloading playlist: 工程师的痛只有工程师能懂_高清</span><br><span class="line">[youku] playlist 工程师的痛只有工程师能懂_高清: Collected 2 video ids (downloading 2 of them)</span><br><span class="line">[download] Downloading video 1 of 2</span><br><span class="line">[download] Destination: 工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part1.flv</span><br><span class="line">[download] 100% of 7.82MiB <span class="keyword">in</span> 00:07</span><br><span class="line">[download] Downloading video 2 of 2</span><br><span class="line">[download] Destination: 工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part2.flv</span><br><span class="line">[download] 100% of 7.73MiB <span class="keyword">in</span> 00:10</span><br><span class="line">[download] Finished downloading playlist: 工程师的痛只有工程师能懂_高清</span><br></pre></td></tr></table></figure><h3 id="FFMpeg"><a href="#FFMpeg" class="headerlink" title="FFMpeg"></a>FFMpeg</h3><p>很简单就下载了这个视频，不过新的问题就来了，我下载下来的视频有两个，怎么能合并成一个文件呢？</p><p>嗯，应该引入我们另外一个神器<code>FFMpeg</code>,这是一个在视频领域里面家喻户晓的类库+工具，我之前做的视频相关的应用就是利用了<code>FFMpeg</code>。有兴趣的同学可以去看看我开源的项目<a href="https://github.com/tonydeng/fmj" target="_blank" rel="noopener">FMJ</a>。</p><p>那继续看看，我们怎么利用<code>FFMpeg</code>合并视频的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i <span class="string">"工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part1.flv"</span> -c copy -bsf:v h264_mp4toannexb -f mpegts 1.ts</span><br><span class="line">ffmpeg -i <span class="string">"工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part2.flv"</span> -c copy -bsf:v h264_mp4toannexb -f mpegts 2.ts</span><br><span class="line">ffmpeg -i <span class="string">"concat:1.ts|2.ts"</span> -c copy -bsf:a aac_adtstoasc <span class="string">"工程师的痛只有工程师能懂.mp4"</span></span><br></pre></td></tr></table></figure><p>这样我们就解决了下载和视频处理的需求，看起来是不是和使用鼠标点点点来完成这些事情不一样呢？</p><p>其实，我这儿还只是粗浅的演示，更多的方式可以，去<a href="http://youtube-dl.org/" target="_blank" rel="noopener">Youtube-DL官网</a>、<a href="https://github.com/rg3/youtube-dl/" target="_blank" rel="noopener">youtube-dl的开源项目地址</a>,<a href="http://ffmpeg.org/" target="_blank" rel="noopener">FFMpeg官网</a>看看更详细的介绍和使用说明。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>另外，也可以看看其他人总结的一些更详细的经验和组合的自动化脚本工具。</p><p>比如：</p><ol><li><a href="http://www.5yun.org/7636.html" target="_blank" rel="noopener">youtube-dl高级使用方法，混合参数下载</a></li><li><a href="http://www.5yun.org/8224.html" target="_blank" rel="noopener">优酷付费vip视频下载方法</a></li><li><a href="https://github.com/kashu/ydl.sh" target="_blank" rel="noopener">使用youtube-dl下载视频的开源脚本</a></li><li><a href="https://github.com/kashu/merge.videos" target="_blank" rel="noopener">自动批量合并视频文件</a></li></ol><p>附上这个视频吧,有兴趣的人可以看看。</p><iframe height="498" width="510" src="http://player.youku.com/embed/XNzE1NTk3Mzky" frameborder="0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog/ffmpeg-youtube-dl.png&quot; alt=&quot;FFMpeg and Youtube-dl&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们经常在各大视频网站上看到一些很不错的视频，希望能够下载收藏起来，但是无法在网站上找到下载的按钮或者入口，很是郁闷。&lt;/p&gt;
&lt;p&gt;那么来看看程序猿是如何来下载和处理视频的。&lt;/p&gt;
    
    </summary>
    
      <category term="效率" scheme="http://tonydeng.github.io/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="video" scheme="http://tonydeng.github.io/tags/video/"/>
    
      <category term="ffmpeg" scheme="http://tonydeng.github.io/tags/ffmpeg/"/>
    
      <category term="youtube-dl" scheme="http://tonydeng.github.io/tags/youtube-dl/"/>
    
  </entry>
  
  <entry>
    <title>Leiningen + Clojure Hello World!</title>
    <link href="http://tonydeng.github.io/2016/07/19/leiningen-clojure-hello-world/"/>
    <id>http://tonydeng.github.io/2016/07/19/leiningen-clojure-hello-world/</id>
    <published>2016-07-19T01:01:58.000Z</published>
    <updated>2019-06-20T12:10:27.476Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog/hello-world.jpg" alt="hello world"></p><p>我们之前已经写过<a href="/categories/Leiningen-Clojure之旅/">Leiningen + Clojure之旅</a>一篇Blog<a href="/2015/11/19/install-leiningen/">安装Leiningen</a>。</p><p>今天我们在看看如何结合Leiningen写一个Clojure的Hello World，毕竟开始一门语言，都是从Hello World开始。</p><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>我们还是先用lein创建一个项目，使用标准项目模板。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein new app clojure-demo --force</span><br><span class="line">Generating a project called clojure-demo based on the <span class="string">'app'</span> template.</span><br></pre></td></tr></table></figure><p>这儿有关于new这个指令的详细使用介绍，包括项目模板的介绍。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein <span class="built_in">help</span> new</span><br><span class="line">Generate scaffolding <span class="keyword">for</span> a new project based on a template.</span><br><span class="line"></span><br><span class="line">If only one argument is passed to the <span class="string">"new"</span> task, the default template</span><br><span class="line">is used and the argument is used as the name of the project.</span><br><span class="line"></span><br><span class="line">If two arguments are passed, the first should be the name of a template,</span><br><span class="line">and the second is used as the name of the project, <span class="keyword">for</span> example:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span></span><br><span class="line"></span><br><span class="line">To generate to a directory different than your project<span class="string">'s name use --to-dir:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    lein new $TEMPLATE_NAME $PROJECT_NAME --to-dir $DIR</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">By default, the "new" task will not write to an existing directory.</span></span><br><span class="line"><span class="string">Supply the --force option to override this behavior:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    lein new $TEMPLATE_NAME $PROJECT_NAME --force</span></span><br><span class="line"><span class="string">    lein new $TEMPLATE_NAME $PROJECT_NAME --to-dir $DIR --force</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Arguments can be passed to templates by adding them after "new"'</span>s options. Use</span><br><span class="line">`--` to separate arguments to lein new and the actual template you are using:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span> --to-dir <span class="variable">$DIR</span> -- template-arg-1 template-arg-2</span><br><span class="line"></span><br><span class="line">If you<span class="string">'d like to use an unreleased (ie, SNAPSHOT) template, pass in --snapshot:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    lein new $TEMPLATE_NAME $PROJECT_NAME --snapshot</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If you'</span>d rather like to use a specific version of template, specify the version</span><br><span class="line">with --template-version option:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span> --template-version <span class="variable">$TEMPLATE_VERSION</span></span><br><span class="line"></span><br><span class="line">If you use the `--snapshot` or `--template-version` argument with template args</span><br><span class="line">you may need to use `--` to prevent template args from being interpreted as</span><br><span class="line">arguments to `lein new`:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span> --snapshot -- template-arg-1 template-arg-2</span><br><span class="line"></span><br><span class="line">Third-party templates can be found at https://clojars.org/search?q=lein-template.</span><br><span class="line">When creating a new project from a third-party template, use its group-id</span><br><span class="line">as the template name. Note that there<span class="string">'s no need to "install" a given third-</span></span><br><span class="line"><span class="string">party template --- lein will automatically fetch it for you.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Use `lein new :show $TEMPLATE` to see details about a given template.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To create a new template of your own, see the documentation for the</span></span><br><span class="line"><span class="string">lein-new Leiningen plug-in.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Subtasks available:</span></span><br><span class="line"><span class="string">default    A general project template for libraries.</span></span><br><span class="line"><span class="string">plugin     A leiningen plugin project template.</span></span><br><span class="line"><span class="string">app        An application project template.</span></span><br><span class="line"><span class="string">template   A meta-template for '</span>lein new<span class="string">' templates.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Run `lein help new $SUBTASK` for subtask details.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Arguments: ([project-name] [template project-name [-- &amp; args]])</span></span><br></pre></td></tr></table></figure><h2 id="project-clj说明"><a href="#project-clj说明" class="headerlink" title="project.clj说明"></a>project.clj说明</h2><p><code>project.clj</code>是<code>Leigingen</code>为项目添加的配置文件，类似于<code>Maven</code>的<code>pom.xml</code>。我们来先看看都有些什么内容。</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">defproject</span> clojure-demo <span class="string">"0.1.0-SNAPSHOT"</span></span><br><span class="line">  <span class="symbol">:description</span> <span class="string">"FIXME: write description"</span></span><br><span class="line">  <span class="symbol">:url</span> <span class="string">"http://example.com/FIXME"</span></span><br><span class="line">  <span class="symbol">:license</span> &#123;<span class="symbol">:name</span> <span class="string">"Eclipse Public License"</span></span><br><span class="line">            <span class="symbol">:url</span> <span class="string">"http://www.eclipse.org/legal/epl-v10.html"</span>&#125;</span><br><span class="line">  <span class="symbol">:dependencies</span> [[org.clojure/clojure <span class="string">"1.8.0"</span>]]</span><br><span class="line">  <span class="symbol">:main</span> ^<span class="symbol">:skip-aot</span> clojure-demo.core</span><br><span class="line">  <span class="symbol">:target-path</span> <span class="string">"target/%s"</span></span><br><span class="line">  <span class="symbol">:profiles</span> &#123;<span class="symbol">:uberjar</span> &#123;<span class="symbol">:aot</span> <span class="symbol">:all</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><ol><li>第一行，描述了项目名称以及版本，当前的项目名称就是 <code>clojure-demo</code>,版本是<code>0.1.0-SNAPSHOT</code>。如果一个项目版本以<code>SNAPSHOT</code>结尾，通常表明该项目还处于开发阶段，还没有正式的release。</li><li><code>description</code>是该项目的简要描述。</li><li><code>url</code>是可选的网址，可以是你项目将来上线后的实际地址。</li><li><code>license</code>是该项目使用License，默认给你设置为<code>Eclipse Public License</code>。</li><li><code>dependencies</code>是我们初期最需要关注的内容，也就是我们项目中需要依赖的其他项目及其版本的配置。比如<code>clojure-demo</code>这个项目就依赖了clojore-1.8.0的版本。</li><li><code>main</code>是配置了当前项目执行的文件，比如<code>clojure-demo.core</code>这个配置就表明了，执行文件就在<code>src/clojure-demo/core.clj</code>。</li><li><code>profiles</code>是我们自己个性化定制的不同profile的指令，比如，我们现在可以通过<code>lein uberjar</code>将项目生成一个jar供其他项目使用。</li></ol><h2 id="结合IntelliJ"><a href="#结合IntelliJ" class="headerlink" title="结合IntelliJ"></a>结合IntelliJ</h2><p>当你用IntelliJ打开<code>clojure-demo</code>，发现你根本看不到项目的结构，只能看到最外层的文件，比如<code>project.clj</code>等。src,test等目录和实际的代码你根本就看不到。那该怎么办？</p><p>可以先执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein pom</span><br></pre></td></tr></table></figure><p>这样lein帮你生成了一个<code>pom.xml</code>，你就可以按照Maven的方式import到IntelliJ中了。</p><h2 id="执行Hello-World"><a href="#执行Hello-World" class="headerlink" title="执行Hello World!"></a>执行Hello World!</h2><p>好，项目也生成了，IDE也可以使用了，我们就开始经典的<code>Hello World</code>吧。</p><p>我们在<code>project.clj</code>中配置了直接运行的方式，那我们现在开始编辑一下<code>core.clj</code>。</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> clojure-demo.core</span><br><span class="line">  (<span class="symbol">:gen-class</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> -main</span><br><span class="line">  <span class="string">"I don't do a whole lot ... yet."</span></span><br><span class="line">  [&amp; args]</span><br><span class="line">  (<span class="name">println</span> <span class="string">"Hello, Clojure World!"</span>))</span><br></pre></td></tr></table></figure><p>执行一下看看效果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein run</span><br><span class="line">Hello, Clojure World!</span><br></pre></td></tr></table></figure><h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><p>我们先添加一个简单的方法，然后测试一下。</p><p>在<code>core.clj</code>中添加<code>my-plus</code>方法，简单计算一下两个数的相加</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> my-plus</span><br><span class="line">  <span class="string">"I don't do a whole lot."</span></span><br><span class="line">  [a b]</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> a b))</span><br></pre></td></tr></table></figure><p>在<code>core_test.clj</code>中添加<code>my-plus-test</code>的测试方法，测试一下1+1是否等于2</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">deftest</span> my-plus-test</span><br><span class="line">  (<span class="name">testing</span> <span class="string">"Test my plus."</span></span><br><span class="line">    (<span class="name">is</span> (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">my-plus</span> <span class="number">1</span> <span class="number">1</span>) <span class="number">2</span>)))</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">lein <span class="built_in">test</span> clojure-demo.core-test</span><br><span class="line"></span><br><span class="line">Ran 1 tests containing 1 assertions.</span><br><span class="line">0 failures, 0 errors.</span><br></pre></td></tr></table></figure><p>如果，你做到这一步的话，欢迎你来到Leiningen + Clojure的世界，Java工程师也可以体验一把Clojure带给你的不同体验吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog/hello-world.jpg&quot; alt=&quot;hello world&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们之前已经写过&lt;a href=&quot;/categories/Leiningen-Clojure之旅/&quot;&gt;Leiningen + Clojure之旅&lt;/a&gt;一篇Blog&lt;a href=&quot;/2015/11/19/install-leiningen/&quot;&gt;安装Leiningen&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;今天我们在看看如何结合Leiningen写一个Clojure的Hello World，毕竟开始一门语言，都是从Hello World开始。&lt;/p&gt;
    
    </summary>
    
      <category term="Leiningen + Clojure之旅" scheme="http://tonydeng.github.io/categories/Leiningen-Clojure%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="leiningen" scheme="http://tonydeng.github.io/tags/leiningen/"/>
    
      <category term="clojure" scheme="http://tonydeng.github.io/tags/clojure/"/>
    
  </entry>
  
  <entry>
    <title>靠谱的产品经理之七字真言</title>
    <link href="http://tonydeng.github.io/2016/07/14/product-seven-words/"/>
    <id>http://tonydeng.github.io/2016/07/14/product-seven-words/</id>
    <published>2016-07-14T10:16:46.000Z</published>
    <updated>2019-06-20T12:10:27.475Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog/seven-words/kaopu.jpg" alt="怎样才算靠谱的产品经理"></p><p>工作那么多年，合作过的产品经理有很多，但是被我和工程师团队认为靠谱的产品经理却不多，工程师也经常吐槽产品经理不靠谱（貌似，我们之前合作过靠谱的产品经理女性居多，也不知道是什么原因……）。</p><a id="more"></a><h2 id="产品汪和程序猿之间的现状"><a href="#产品汪和程序猿之间的现状" class="headerlink" title="产品汪和程序猿之间的现状"></a>产品汪和程序猿之间的现状</h2><p>我们去通过Google或Baidu搜索关键词 “产品经理 程序员”，也经常出现如下的内容。</p><p>比如，想不通的……</p><p><img src="http://www.wanho.net/data/upload/ueditor/56d65d9d43914.jpg" alt="产品经理频繁改需求为什么会惹毛程序员？"></p><p>比如，比较暴力的……</p><p><img src="http://www.dongao.com/kjzx/UploadFiles_5705/201507/2015071016354845.png" alt="产品经理改需求惨遭囚禁凌虐"></p><p>或者，如此求解的……</p><p><img src="http://www.dongao.com/kjzx/UploadFiles_5705/201507/2015071016360147.png" alt="产品经理如何和程序员共处"></p><p>感觉整个互联网行业，甚至IT圈都在上演产品经理和程序员的“恩怨情仇”，堪比各大影院前段时间上映的迪斯尼大片《Zootopia》（疯狂动物城）。</p><p><img src="http://www.woshipm.com/wp-content/uploads/2015/07/QQ20150717145729.png" alt="产品经理和程序员的恩怨情仇"></p><h2 id="矛盾如何产生？"><a href="#矛盾如何产生？" class="headerlink" title="矛盾如何产生？"></a>矛盾如何产生？</h2><p>很多产品汪都经常会碰到这样的场景：</p><p>一个非常复杂的产品设计终于加班加点的完成了，你满心欢喜的召集程序猿们开产品讨论会，但是过程中却备受打击，经常会碰到如下问题，而你还回答不出来：</p><ul><li>是否要搜索？模糊搜索还是精确搜索？</li><li>是否有翻页，每页显示多少条数据？</li><li>能不能输入小数点、负数、字母？</li><li>公式怎么算的？</li><li>各种状态如何定义？如何转换状态？</li><li>……</li></ul><p>很郁闷的是上述问题，你在产品设计过程中，你根本没有考虑过这些问题，你一直在考虑如何来创建订单，应该让用户更简单的使用。而这些问题，你认为都是小问题，还需要我来考虑吗？</p><p>这个会议的效果可想而知。</p><p>程序猿们会认为这么长的时间了，你产品经理在想什么，这些都没有想明白，没干活啊！</p><p>产品汪们会非常委屈，觉得程序猿是有意刁难自己。要么觉得这些问题难道不是应该程序猿考虑的吗？要么觉得，这些问题复杂想不清楚。</p><p>最后会议草草收场，团队之间出现嫌隙。</p><p>当产品汪把上述问题的答案整理完之后，再次召集程序猿们开产品讨论会，发现貌似还是会有类似的问题。</p><p>哲人发出如此的感叹:</p><blockquote><p><img src="/images/blog/seven-words/product-workshop.png" alt="吐槽产品讨论会"></p></blockquote><p>慢慢的，产品汪和程序猿之间的情绪就越来越对立，对这个产品的热情也慢慢下降，更多的精力和时间都放在两边对耗上了，产品推行的非常之慢。</p><p>直到Boos来过问产品的状况，只有互相推诿和指责。</p><h2 id="回顾矛盾的产生"><a href="#回顾矛盾的产生" class="headerlink" title="回顾矛盾的产生"></a>回顾矛盾的产生</h2><p>其实矛盾产生的根源在于我们在产品讨论会上碰到哪些可能答不出来的问题。</p><p>那么，这些问题需要产品经理考虑吗？答案是显而易见的，产品经理必须要考虑这些问题、</p><p>因为这些最基本的问题会影响到系统的设计，没有考虑到，意味着产品经理对于规划的产品可以做什么？如何做？能做到什么程度？没有概念，规划产品的可行性就会大打折扣。</p><p><img src="/images/blog/seven-words/upstream-and-downstream.png" alt="产品流程的上下游"></p><p>一般产品研发的上下游基本上下图，程序猿处于产品汪的下游。</p><p>一个没有概念，规划的产品设计，你让一个思维严谨的程序猿如何能接受？他们只会认为，产品经理不靠谱，这种不靠谱的需求只会导致如下情况：</p><blockquote><p>如果让这个产品通过了产品讨论阶段，那么他们只能为这个不靠谱的产品设计和产品经理买单，程序猿们会产生这样的想法： 我TMD就是那个“接盘侠”。<br><img src="http://www.cyxqd.com/wp-content/uploads/2014/01/jiepanxia.jpg" alt="接盘侠"></p></blockquote><p>** 产品汪们，你们也想想，你们愿意当这个接盘侠吗？ **</p><h2 id="解决矛盾的办法"><a href="#解决矛盾的办法" class="headerlink" title="解决矛盾的办法"></a>解决矛盾的办法</h2><p>那么我们怎么来解决这些矛盾呢？</p><p>产品如同人一样，有样貌、皮肤等外在结构，也有筋骨、神经网络等内在体系。在产品设计及规划中，产品汪除了要对UI、UE等外在负责以外，还需要对产品的筋骨、神经网络负责。</p><p>产品的筋骨、神经网络就是产品隐含的逻辑规则，才是产品运转正常的保证。</p><p>我们推出一个产品，一般要解决两类问题：</p><ol><li>人的问题，业务的问题</li><li>计算机的问题，也就是技术的问题</li></ol><p>那我们设计一个产品，不管我们想的如何天马行空，如何炫酷，也一定要通过一整套的IT系统来支撑。而IT系统本质上就是对数据的各种处理，各种状态流转，使用了各种形态来展示这些数据和状态流转。</p><p>而产品汪一般的产品设计思路都是按照人的思维模式来进行设计的，但是人本身就是一种适配功能很强的“适配器”，人可以对模糊的信息做出自己的补充，完善自己对这个模糊的信息补充，并作出自己的反应。</p><p>但是计算机并非如此，比如，我们进出地铁，站在扶梯上，会有语音提示“上下楼梯，请握紧扶手”。我们很容易理解这个句话，并作出自己适当的反应，来握紧扶手。</p><p>但是计算机如何来理解？用手施加10牛顿的力吗？</p><p>那产品汪在做产品设计时，<strong>是否要考虑到如何来定义这个“紧”？！</strong></p><p>那很多产品汪就非常郁闷的说，这么多的问题，怎么样才能够都考虑到呢？</p><p><img src="http://images.rednet.cn/articleimage/2006/07/29/104016572.jpg" alt="我们不专业"></p><p>那怎么办呢？我们是不是需要进修一下呢？比如学星爷研读的秘籍《产品狗的自我修养》。</p><p><img src="http://image.woshipm.com/wp-files/2015/07/chanpingou.jpg" alt="产品狗的自我修养"></p><p>其实，我们并不需要研读那么深刻的著作，其实我们只要掌握了产品设计的<strong>七字真言</strong>，基本上也程序猿的在产品讨论会上碰到的问题就能解决的差不多了。</p><h2 id="七字真言"><a href="#七字真言" class="headerlink" title="七字真言"></a>七字真言</h2><p>很多人看到“七字真言”的第一反应可能是这样的。</p><p><img src="/images/blog/seven-words/seven.png" alt="七字真言"></p><p>其实产品设计的七字真言就是增 、删、改、查、显、算、 传</p><p>所有的产品设计，本质上都是对于一些数据、内容、结构层、信息做一些交互，这是产品的本质。</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ol><li>增加按钮的样式、位置</li><li>增加按钮的文案：添加、创建、新建？</li><li>增加内容的字段</li><li>字段的必填非必填说明</li><li>字段的验证、提示说明</li><li>界面排列的说明</li><li>弹窗还是当前页跳转？</li><li>……</li></ol><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ol><li>删除按钮的样式、位置</li><li>删除案例的文案： 删除</li><li>删除时是否要确认？确认窗口的样式</li><li>删除完以后界面布局的变化</li><li>逻辑删除</li><li>物理删除</li><li>删除之后是否会影响到其他的功能模块？</li><li>…….</li></ol><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ol><li>编辑按钮的样式、位置</li><li>编辑按钮的文案： 修改、编辑？</li><li>弹窗还是当前页面跳转？</li><li>可以修改与不可修改的说明</li><li>更改数据之后，对其他功能模块的影响</li><li>……</li></ol><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ol><li>按照哪些字段进行排序？</li><li>搜索框：需要对哪些进行搜索？是否可以组合搜索？搜索后的界面如何程序？模糊搜索还是精确搜索？</li><li>搜索结果的展示如何？是否和搜索条件有关系？</li><li>搜索条件之间是否有冲突？</li><li>查不到数据该如何？</li><li>需要查看哪些数据？</li><li>……</li></ol><blockquote><p>一般来说，产品经理做到以上四点就能把原型做的非常完善，例如数据做成了列表样式，是否考虑了分页？是否需要排序？排序的话按什么条件进行？排序满足不了需求的话是否需要搜索框？查询框？查看详细列表的打开方式是怎么样的？本页操作还是新窗口操作？跳转之后需不需要跳回来？选择数据支持单选还是多选？单选的话是用下拉还是radio？如此等等</p><p>细节交代的越清楚，和程序猿的沟通成本就越小</p></blockquote><h3 id="显"><a href="#显" class="headerlink" title="显"></a>显</h3><ol><li>页面内容的布局</li><li>每页多少条数据、数据的排序？</li><li>是否有翻页、翻页样式如何？</li><li>是否提供查看详情，如何查看？</li><li>查看是弹窗还是当前页打开，还是新页面？</li><li>如何从各个操作页面跳转回原页面的方法？</li><li>跳转回来的页面如何显示？</li><li>不同权限用户的数据展示是否有不同？展现规则是怎么样的？</li><li>……</li></ol><h3 id="算"><a href="#算" class="headerlink" title="算"></a>算</h3><ol><li>计算规则</li><li>页面公式、特定指标的计算规则</li><li>数据背后的逻辑</li><li>……</li></ol><h3 id="传"><a href="#传" class="headerlink" title="传"></a>传</h3><ol><li>不同用户之间、不同操作之间传递哪些数据？哪些字段？</li><li>需要提供哪些API的接口？整合其他第三方系统时，他们提供的API是否能够满足我们现有需求？</li><li>数据的流向规则</li><li>……</li></ol><p>每当我们在做产品设计的时候，都在心里默念着七个字，基本上设计出来的产品功能点就都覆盖到了，省去了产品讨论和产品研发过程中很多不必要的沟通、交流和冲突。</p><p>有一个比喻非常好，“产品是孩子，开发是妈妈，产品经理是爸爸，测试时医生”，<strong>We are 伐木累！</strong>，产品汪，你们觉得呢？</p><p><img src="http://www.android100.org/uploadfile/2015/0829/20150829004427_0.gif" alt="we are 伐木累"></p><p>最后说一句，不管怎么样，各位产品汪们，需要对产品经理本身的职责要搞清楚，如果你短时间内不能达到产品经理本身应该具备的素质，那你就应该努力提高自己对产品设计和产品经理职责的理解，good good study,day day up！并且，要发挥自己的亲和力将整个团队的各个成员的长处组合起来，一起完成一个满意的产品。</p><p><img src="http://image.woshipm.com/wp-files/2015/07/QQ20150727200359.png" alt="任何不能杀了我的只会让我更强"></p><p>另外，程序猿们也不要太过难为产品汪，大家都是在一个团队工作，为了同一个目标而努力，能够互相支持，互相补位的就多多支持和补位。毕竟大家也都是在<strong>同一个马勺里喝水</strong>。</p><p><img src="http://www.yixieshi.com/uploads/allimg/140525/1-14052520102TZ.jpg" alt="同一个马勺里喝水"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog/seven-words/kaopu.jpg&quot; alt=&quot;怎样才算靠谱的产品经理&quot;&gt;&lt;/p&gt;
&lt;p&gt;工作那么多年，合作过的产品经理有很多，但是被我和工程师团队认为靠谱的产品经理却不多，工程师也经常吐槽产品经理不靠谱（貌似，我们之前合作过靠谱的产品经理女性居多，也不知道是什么原因……）。&lt;/p&gt;
    
    </summary>
    
      <category term="产品设计" scheme="http://tonydeng.github.io/categories/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="product" scheme="http://tonydeng.github.io/tags/product/"/>
    
  </entry>
  
</feed>
